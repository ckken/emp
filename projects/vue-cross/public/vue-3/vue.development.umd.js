"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self1) {
    if (self1 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self1;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
    } else {
        _get = function get(target, property, receiver) {
            var base = _super_prop_base(target, property);
            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);
            if (desc.get) {
                return desc.get.call(receiver || target);
            }
            return desc.value;
        };
    }
    return _get(target, property, receiver || target);
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possible_constructor_return(self1, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self1);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _super_prop_base(object, property) {
    while(!Object.prototype.hasOwnProperty.call(object, property)){
        object = _get_prototype_of(object);
        if (object === null) break;
    }
    return object;
}
function _tagged_template_literal(strings, raw) {
    if (!raw) {
        raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v1) {
            return step([
                n,
                v1
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function _templateObject() {
    var data = _tagged_template_literal([
        "pipelineOperator"
    ]);
    _templateObject = function _templateObject() {
        return data;
    };
    return data;
}
function _templateObject1() {
    var data = _tagged_template_literal([
        "flow"
    ]);
    _templateObject1 = function _templateObject() {
        return data;
    };
    return data;
}
function _templateObject2() {
    var data = _tagged_template_literal([
        "jsx"
    ]);
    _templateObject2 = function _templateObject() {
        return data;
    };
    return data;
}
function _templateObject3() {
    var data = _tagged_template_literal([
        "typescript"
    ]);
    _templateObject3 = function _templateObject() {
        return data;
    };
    return data;
}
function _templateObject4() {
    var data = _tagged_template_literal([
        "placeholders"
    ]);
    _templateObject4 = function _templateObject() {
        return data;
    };
    return data;
}
var EMP_ADAPTER_VUE = function() {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __commonJS = function(cb, mod) {
        return function __require() {
            return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
                exports: {}
            }).exports, mod), mod.exports;
        };
    };
    var __copyProps = function(to, from, except, desc) {
        if (from && (typeof from === "undefined" ? "undefined" : _type_of(from)) === "object" || typeof from === "function") {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
            try {
                var _loop = function() {
                    var key = _step.value;
                    if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                        get: function() {
                            return from[key];
                        },
                        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                    });
                };
                for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally{
                try {
                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                    }
                } finally{
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
        return to;
    };
    var __reExport = function(target, mod, secondTarget) {
        return __copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default");
    };
    var __toESM = function(mod, isNodeMode, target) {
        return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
            value: mod,
            enumerable: true
        }) : target, mod);
    };
    var __toCommonJS = function(mod) {
        return __copyProps(__defProp({}, "__esModule", {
            value: true
        }), mod);
    };
    // ../../node_modules/.pnpm/@vue+shared@3.5.13/node_modules/@vue/shared/dist/shared.cjs.js
    var require_shared_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+shared@3.5.13/node_modules/@vue/shared/dist/shared.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            // @__NO_SIDE_EFFECTS__
            function makeMap(str) {
                var map = /* @__PURE__ */ Object.create(null);
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = str.split(",")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var key = _step.value;
                        map[key] = 1;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return function(val) {
                    return val in map;
                };
            }
            var EMPTY_OBJ = Object.freeze({});
            var EMPTY_ARR = Object.freeze([]);
            var NOOP = function() {};
            var NO = function() {
                return false;
            };
            var isOn = function(key) {
                return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
                (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
            };
            var isModelListener = function(key) {
                return key.startsWith("onUpdate:");
            };
            var extend = Object.assign;
            var remove = function(arr, el) {
                var i = arr.indexOf(el);
                if (i > -1) {
                    arr.splice(i, 1);
                }
            };
            var hasOwnProperty2 = Object.prototype.hasOwnProperty;
            var hasOwn = function(val, key) {
                return hasOwnProperty2.call(val, key);
            };
            var isArray = Array.isArray;
            var isMap = function(val) {
                return toTypeString(val) === "[object Map]";
            };
            var isSet = function(val) {
                return toTypeString(val) === "[object Set]";
            };
            var isDate = function(val) {
                return toTypeString(val) === "[object Date]";
            };
            var isRegExp = function(val) {
                return toTypeString(val) === "[object RegExp]";
            };
            var isFunction = function(val) {
                return typeof val === "function";
            };
            var isString = function(val) {
                return typeof val === "string";
            };
            var isSymbol = function(val) {
                return (typeof val === "undefined" ? "undefined" : _type_of(val)) === "symbol";
            };
            var isObject = function(val) {
                return val !== null && (typeof val === "undefined" ? "undefined" : _type_of(val)) === "object";
            };
            var isPromise = function(val) {
                return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
            };
            var objectToString = Object.prototype.toString;
            var toTypeString = function(value) {
                return objectToString.call(value);
            };
            var toRawType = function(value) {
                return toTypeString(value).slice(8, -1);
            };
            var isPlainObject = function(val) {
                return toTypeString(val) === "[object Object]";
            };
            var isIntegerKey = function(key) {
                return isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
            };
            var isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
            ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
            var isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
            var cacheStringFunction = function(fn) {
                var cache = /* @__PURE__ */ Object.create(null);
                return function(str) {
                    var hit = cache[str];
                    return hit || (cache[str] = fn(str));
                };
            };
            var camelizeRE = /-(\w)/g;
            var camelize = cacheStringFunction(function(str) {
                return str.replace(camelizeRE, function(_, c) {
                    return c ? c.toUpperCase() : "";
                });
            });
            var hyphenateRE = /\B([A-Z])/g;
            var hyphenate = cacheStringFunction(function(str) {
                return str.replace(hyphenateRE, "-$1").toLowerCase();
            });
            var capitalize = cacheStringFunction(function(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            });
            var toHandlerKey = cacheStringFunction(function(str) {
                var s = str ? "on".concat(capitalize(str)) : "";
                return s;
            });
            var hasChanged = function(value, oldValue) {
                return !Object.is(value, oldValue);
            };
            var invokeArrayFns = function(fns) {
                for(var _len = arguments.length, arg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    arg[_key - 1] = arguments[_key];
                }
                for(var i = 0; i < fns.length; i++){
                    var _fns;
                    (_fns = fns)[i].apply(_fns, _to_consumable_array(arg));
                }
            };
            var def = function(obj, key, value) {
                var writable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                Object.defineProperty(obj, key, {
                    configurable: true,
                    enumerable: false,
                    writable: writable,
                    value: value
                });
            };
            var looseToNumber = function(val) {
                var n = parseFloat(val);
                return isNaN(n) ? val : n;
            };
            var toNumber = function(val) {
                var n = isString(val) ? Number(val) : NaN;
                return isNaN(n) ? val : n;
            };
            var _globalThis;
            var getGlobalThis = function() {
                return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
            };
            var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
            function genPropsAccessExp(name) {
                return identRE.test(name) ? "__props.".concat(name) : "__props[".concat(JSON.stringify(name), "]");
            }
            function genCacheKey(source, options) {
                return source + JSON.stringify(options, function(_, val) {
                    return typeof val === "function" ? val.toString() : val;
                });
            }
            var PatchFlags = {
                "TEXT": 1,
                "1": "TEXT",
                "CLASS": 2,
                "2": "CLASS",
                "STYLE": 4,
                "4": "STYLE",
                "PROPS": 8,
                "8": "PROPS",
                "FULL_PROPS": 16,
                "16": "FULL_PROPS",
                "NEED_HYDRATION": 32,
                "32": "NEED_HYDRATION",
                "STABLE_FRAGMENT": 64,
                "64": "STABLE_FRAGMENT",
                "KEYED_FRAGMENT": 128,
                "128": "KEYED_FRAGMENT",
                "UNKEYED_FRAGMENT": 256,
                "256": "UNKEYED_FRAGMENT",
                "NEED_PATCH": 512,
                "512": "NEED_PATCH",
                "DYNAMIC_SLOTS": 1024,
                "1024": "DYNAMIC_SLOTS",
                "DEV_ROOT_FRAGMENT": 2048,
                "2048": "DEV_ROOT_FRAGMENT",
                "CACHED": -1,
                "-1": "CACHED",
                "BAIL": -2,
                "-2": "BAIL"
            };
            var _obj;
            var PatchFlagNames = (_obj = {}, _define_property(_obj, 1, "TEXT"), _define_property(_obj, 2, "CLASS"), _define_property(_obj, 4, "STYLE"), _define_property(_obj, 8, "PROPS"), _define_property(_obj, 16, "FULL_PROPS"), _define_property(_obj, 32, "NEED_HYDRATION"), _define_property(_obj, 64, "STABLE_FRAGMENT"), _define_property(_obj, 128, "KEYED_FRAGMENT"), _define_property(_obj, 256, "UNKEYED_FRAGMENT"), _define_property(_obj, 512, "NEED_PATCH"), _define_property(_obj, 1024, "DYNAMIC_SLOTS"), _define_property(_obj, 2048, "DEV_ROOT_FRAGMENT"), _define_property(_obj, -1, "HOISTED"), _define_property(_obj, -2, "BAIL"), _obj);
            var ShapeFlags = {
                "ELEMENT": 1,
                "1": "ELEMENT",
                "FUNCTIONAL_COMPONENT": 2,
                "2": "FUNCTIONAL_COMPONENT",
                "STATEFUL_COMPONENT": 4,
                "4": "STATEFUL_COMPONENT",
                "TEXT_CHILDREN": 8,
                "8": "TEXT_CHILDREN",
                "ARRAY_CHILDREN": 16,
                "16": "ARRAY_CHILDREN",
                "SLOTS_CHILDREN": 32,
                "32": "SLOTS_CHILDREN",
                "TELEPORT": 64,
                "64": "TELEPORT",
                "SUSPENSE": 128,
                "128": "SUSPENSE",
                "COMPONENT_SHOULD_KEEP_ALIVE": 256,
                "256": "COMPONENT_SHOULD_KEEP_ALIVE",
                "COMPONENT_KEPT_ALIVE": 512,
                "512": "COMPONENT_KEPT_ALIVE",
                "COMPONENT": 6,
                "6": "COMPONENT"
            };
            var SlotFlags = {
                "STABLE": 1,
                "1": "STABLE",
                "DYNAMIC": 2,
                "2": "DYNAMIC",
                "FORWARDED": 3,
                "3": "FORWARDED"
            };
            var _obj1;
            var slotFlagsText = (_obj1 = {}, _define_property(_obj1, 1, "STABLE"), _define_property(_obj1, 2, "DYNAMIC"), _define_property(_obj1, 3, "FORWARDED"), _obj1);
            var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
            var isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
            var isGloballyWhitelisted = isGloballyAllowed;
            var range = 2;
            function generateCodeFrame(source) {
                var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : source.length;
                start = Math.max(0, Math.min(start, source.length));
                end = Math.max(0, Math.min(end, source.length));
                if (start > end) return "";
                var lines = source.split(/(\r?\n)/);
                var newlineSequences = lines.filter(function(_, idx) {
                    return idx % 2 === 1;
                });
                lines = lines.filter(function(_, idx) {
                    return idx % 2 === 0;
                });
                var count = 0;
                var res = [];
                for(var i = 0; i < lines.length; i++){
                    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
                    if (count >= start) {
                        for(var j = i - range; j <= i + range || end > count; j++){
                            if (j < 0 || j >= lines.length) continue;
                            var line = j + 1;
                            res.push("".concat(line).concat(" ".repeat(Math.max(3 - String(line).length, 0)), "|  ").concat(lines[j]));
                            var lineLength = lines[j].length;
                            var newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                            if (j === i) {
                                var pad = start - (count - (lineLength + newLineSeqLength));
                                var length = Math.max(1, end > count ? lineLength - pad : end - start);
                                res.push("   |  " + " ".repeat(pad) + "^".repeat(length));
                            } else if (j > i) {
                                if (end > count) {
                                    var length1 = Math.max(Math.min(end - count, lineLength), 1);
                                    res.push("   |  " + "^".repeat(length1));
                                }
                                count += lineLength + newLineSeqLength;
                            }
                        }
                        break;
                    }
                }
                return res.join("\n");
            }
            function normalizeStyle(value) {
                if (isArray(value)) {
                    var res = {};
                    for(var i = 0; i < value.length; i++){
                        var item = value[i];
                        var normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
                        if (normalized) {
                            for(var key in normalized){
                                res[key] = normalized[key];
                            }
                        }
                    }
                    return res;
                } else if (isString(value) || isObject(value)) {
                    return value;
                }
            }
            var listDelimiterRE = /;(?![^(]*\))/g;
            var propertyDelimiterRE = /:([^]+)/;
            var styleCommentRE = /\/\*[^]*?\*\//g;
            function parseStringStyle(cssText) {
                var ret = {};
                cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(function(item) {
                    if (item) {
                        var tmp = item.split(propertyDelimiterRE);
                        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
                    }
                });
                return ret;
            }
            function stringifyStyle(styles) {
                if (!styles) return "";
                if (isString(styles)) return styles;
                var ret = "";
                for(var key in styles){
                    var value = styles[key];
                    if (isString(value) || typeof value === "number") {
                        var normalizedKey = key.startsWith("--") ? key : hyphenate(key);
                        ret += "".concat(normalizedKey, ":").concat(value, ";");
                    }
                }
                return ret;
            }
            function normalizeClass(value) {
                var res = "";
                if (isString(value)) {
                    res = value;
                } else if (isArray(value)) {
                    for(var i = 0; i < value.length; i++){
                        var normalized = normalizeClass(value[i]);
                        if (normalized) {
                            res += normalized + " ";
                        }
                    }
                } else if (isObject(value)) {
                    for(var name in value){
                        if (value[name]) {
                            res += name + " ";
                        }
                    }
                }
                return res.trim();
            }
            function normalizeProps(props) {
                if (!props) return null;
                var klass = props.class, style = props.style;
                if (klass && !isString(klass)) {
                    props.class = normalizeClass(klass);
                }
                if (style) {
                    props.style = normalizeStyle(style);
                }
                return props;
            }
            var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
            var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
            var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
            var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
            var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
            var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
            var isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
            var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
            var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
            var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
            var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected");
            function includeBooleanAttr(value) {
                return !!value || value === "";
            }
            var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
            var attrValidationCache = {};
            function isSSRSafeAttrName(name) {
                if (attrValidationCache.hasOwnProperty(name)) {
                    return attrValidationCache[name];
                }
                var isUnsafe = unsafeAttrCharRE.test(name);
                if (isUnsafe) {
                    console.error("unsafe attribute name: ".concat(name));
                }
                return attrValidationCache[name] = !isUnsafe;
            }
            var propsToAttrMap = {
                acceptCharset: "accept-charset",
                className: "class",
                htmlFor: "for",
                httpEquiv: "http-equiv"
            };
            var isKnownHtmlAttr = /* @__PURE__ */ makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap");
            var isKnownSvgAttr = /* @__PURE__ */ makeMap("xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan");
            var isKnownMathMLAttr = /* @__PURE__ */ makeMap("accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns");
            function isRenderableAttrValue(value) {
                if (value == null) {
                    return false;
                }
                var type = typeof value === "undefined" ? "undefined" : _type_of(value);
                return type === "string" || type === "number" || type === "boolean";
            }
            var escapeRE = /["'&<>]/;
            function escapeHtml(string) {
                var str = "" + string;
                var match = escapeRE.exec(str);
                if (!match) {
                    return str;
                }
                var html = "";
                var escaped;
                var index;
                var lastIndex = 0;
                for(index = match.index; index < str.length; index++){
                    switch(str.charCodeAt(index)){
                        case 34:
                            escaped = "&quot;";
                            break;
                        case 38:
                            escaped = "&amp;";
                            break;
                        case 39:
                            escaped = "&#39;";
                            break;
                        case 60:
                            escaped = "&lt;";
                            break;
                        case 62:
                            escaped = "&gt;";
                            break;
                        default:
                            continue;
                    }
                    if (lastIndex !== index) {
                        html += str.slice(lastIndex, index);
                    }
                    lastIndex = index + 1;
                    html += escaped;
                }
                return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
            }
            var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
            function escapeHtmlComment(src) {
                return src.replace(commentStripRE, "");
            }
            var cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
            function getEscapedCssVarName(key, doubleEscape) {
                return key.replace(cssVarNameEscapeSymbolsRE, function(s) {
                    return doubleEscape ? s === '"' ? '\\\\\\"' : "\\\\".concat(s) : "\\".concat(s);
                });
            }
            function looseCompareArrays(a, b) {
                if (a.length !== b.length) return false;
                var equal = true;
                for(var i = 0; equal && i < a.length; i++){
                    equal = looseEqual(a[i], b[i]);
                }
                return equal;
            }
            function looseEqual(a, b) {
                if (a === b) return true;
                var aValidType = isDate(a);
                var bValidType = isDate(b);
                if (aValidType || bValidType) {
                    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
                }
                aValidType = isSymbol(a);
                bValidType = isSymbol(b);
                if (aValidType || bValidType) {
                    return a === b;
                }
                aValidType = isArray(a);
                bValidType = isArray(b);
                if (aValidType || bValidType) {
                    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
                }
                aValidType = isObject(a);
                bValidType = isObject(b);
                if (aValidType || bValidType) {
                    if (!aValidType || !bValidType) {
                        return false;
                    }
                    var aKeysCount = Object.keys(a).length;
                    var bKeysCount = Object.keys(b).length;
                    if (aKeysCount !== bKeysCount) {
                        return false;
                    }
                    for(var key in a){
                        var aHasKey = a.hasOwnProperty(key);
                        var bHasKey = b.hasOwnProperty(key);
                        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
                            return false;
                        }
                    }
                }
                return String(a) === String(b);
            }
            function looseIndexOf(arr, val) {
                return arr.findIndex(function(item) {
                    return looseEqual(item, val);
                });
            }
            var isRef = function(val) {
                return !!(val && val["__v_isRef"] === true);
            };
            var toDisplayString = function(val) {
                return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
            };
            var replacer = function(_key, val) {
                if (isRef(val)) {
                    return replacer(_key, val.value);
                } else if (isMap(val)) {
                    return _define_property({}, "Map(".concat(val.size, ")"), _to_consumable_array(val.entries()).reduce(function(entries, param, i) {
                        var _param = _sliced_to_array(param, 2), key = _param[0], val2 = _param[1];
                        entries[stringifySymbol(key, i) + " =>"] = val2;
                        return entries;
                    }, {}));
                } else if (isSet(val)) {
                    return _define_property({}, "Set(".concat(val.size, ")"), _to_consumable_array(val.values()).map(function(v1) {
                        return stringifySymbol(v1);
                    }));
                } else if (isSymbol(val)) {
                    return stringifySymbol(val);
                } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
                    return String(val);
                }
                return val;
            };
            var stringifySymbol = function(v1) {
                var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                var _a;
                return(// Symbol.description in es2019+ so we need to cast here to pass
                // the lib: es2016 check
                isSymbol(v1) ? "Symbol(".concat((_a = v1.description) != null ? _a : i, ")") : v1);
            };
            exports.EMPTY_ARR = EMPTY_ARR;
            exports.EMPTY_OBJ = EMPTY_OBJ;
            exports.NO = NO;
            exports.NOOP = NOOP;
            exports.PatchFlagNames = PatchFlagNames;
            exports.PatchFlags = PatchFlags;
            exports.ShapeFlags = ShapeFlags;
            exports.SlotFlags = SlotFlags;
            exports.camelize = camelize;
            exports.capitalize = capitalize;
            exports.cssVarNameEscapeSymbolsRE = cssVarNameEscapeSymbolsRE;
            exports.def = def;
            exports.escapeHtml = escapeHtml;
            exports.escapeHtmlComment = escapeHtmlComment;
            exports.extend = extend;
            exports.genCacheKey = genCacheKey;
            exports.genPropsAccessExp = genPropsAccessExp;
            exports.generateCodeFrame = generateCodeFrame;
            exports.getEscapedCssVarName = getEscapedCssVarName;
            exports.getGlobalThis = getGlobalThis;
            exports.hasChanged = hasChanged;
            exports.hasOwn = hasOwn;
            exports.hyphenate = hyphenate;
            exports.includeBooleanAttr = includeBooleanAttr;
            exports.invokeArrayFns = invokeArrayFns;
            exports.isArray = isArray;
            exports.isBooleanAttr = isBooleanAttr;
            exports.isBuiltInDirective = isBuiltInDirective;
            exports.isDate = isDate;
            exports.isFunction = isFunction;
            exports.isGloballyAllowed = isGloballyAllowed;
            exports.isGloballyWhitelisted = isGloballyWhitelisted;
            exports.isHTMLTag = isHTMLTag;
            exports.isIntegerKey = isIntegerKey;
            exports.isKnownHtmlAttr = isKnownHtmlAttr;
            exports.isKnownMathMLAttr = isKnownMathMLAttr;
            exports.isKnownSvgAttr = isKnownSvgAttr;
            exports.isMap = isMap;
            exports.isMathMLTag = isMathMLTag;
            exports.isModelListener = isModelListener;
            exports.isObject = isObject;
            exports.isOn = isOn;
            exports.isPlainObject = isPlainObject;
            exports.isPromise = isPromise;
            exports.isRegExp = isRegExp;
            exports.isRenderableAttrValue = isRenderableAttrValue;
            exports.isReservedProp = isReservedProp;
            exports.isSSRSafeAttrName = isSSRSafeAttrName;
            exports.isSVGTag = isSVGTag;
            exports.isSet = isSet;
            exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
            exports.isString = isString;
            exports.isSymbol = isSymbol;
            exports.isVoidTag = isVoidTag;
            exports.looseEqual = looseEqual;
            exports.looseIndexOf = looseIndexOf;
            exports.looseToNumber = looseToNumber;
            exports.makeMap = makeMap;
            exports.normalizeClass = normalizeClass;
            exports.normalizeProps = normalizeProps;
            exports.normalizeStyle = normalizeStyle;
            exports.objectToString = objectToString;
            exports.parseStringStyle = parseStringStyle;
            exports.propsToAttrMap = propsToAttrMap;
            exports.remove = remove;
            exports.slotFlagsText = slotFlagsText;
            exports.stringifyStyle = stringifyStyle;
            exports.toDisplayString = toDisplayString;
            exports.toHandlerKey = toHandlerKey;
            exports.toNumber = toNumber;
            exports.toRawType = toRawType;
            exports.toTypeString = toTypeString;
        }
    });
    // ../../node_modules/.pnpm/@vue+shared@3.5.13/node_modules/@vue/shared/index.js
    var require_shared = __commonJS({
        "../../node_modules/.pnpm/@vue+shared@3.5.13/node_modules/@vue/shared/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_shared_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js
    var require_decode_data_html = __commonJS({
        "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-html.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = new Uint16Array(// prettier-ignore
            '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
                return c.charCodeAt(0);
            }));
        }
    });
    // ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js
    var require_decode_data_xml = __commonJS({
        "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/generated/decode-data-xml.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = new Uint16Array(// prettier-ignore
            "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
                return c.charCodeAt(0);
            }));
        }
    });
    // ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js
    var require_decode_codepoint = __commonJS({
        "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode_codepoint.js": function(exports) {
            "use strict";
            var _a;
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.replaceCodePoint = exports.fromCodePoint = void 0;
            var decodeMap = /* @__PURE__ */ new Map([
                [
                    0,
                    65533
                ],
                // C1 Unicode control character reference replacements
                [
                    128,
                    8364
                ],
                [
                    130,
                    8218
                ],
                [
                    131,
                    402
                ],
                [
                    132,
                    8222
                ],
                [
                    133,
                    8230
                ],
                [
                    134,
                    8224
                ],
                [
                    135,
                    8225
                ],
                [
                    136,
                    710
                ],
                [
                    137,
                    8240
                ],
                [
                    138,
                    352
                ],
                [
                    139,
                    8249
                ],
                [
                    140,
                    338
                ],
                [
                    142,
                    381
                ],
                [
                    145,
                    8216
                ],
                [
                    146,
                    8217
                ],
                [
                    147,
                    8220
                ],
                [
                    148,
                    8221
                ],
                [
                    149,
                    8226
                ],
                [
                    150,
                    8211
                ],
                [
                    151,
                    8212
                ],
                [
                    152,
                    732
                ],
                [
                    153,
                    8482
                ],
                [
                    154,
                    353
                ],
                [
                    155,
                    8250
                ],
                [
                    156,
                    339
                ],
                [
                    158,
                    382
                ],
                [
                    159,
                    376
                ]
            ]);
            exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
                var output = "";
                if (codePoint > 65535) {
                    codePoint -= 65536;
                    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                }
                output += String.fromCharCode(codePoint);
                return output;
            };
            function replaceCodePoint(codePoint) {
                var _a2;
                if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
                    return 65533;
                }
                return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
            }
            exports.replaceCodePoint = replaceCodePoint;
            function decodeCodePoint(codePoint) {
                return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
            }
            exports.default = decodeCodePoint;
        }
    });
    // ../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js
    var require_decode = __commonJS({
        "../../node_modules/.pnpm/entities@4.5.0/node_modules/entities/lib/decode.js": function(exports) {
            "use strict";
            var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
                if (k2 === void 0) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = {
                        enumerable: true,
                        get: function get() {
                            return m[k];
                        }
                    };
                }
                Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
                if (k2 === void 0) k2 = k;
                o[k2] = m[k];
            });
            var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v1) {
                Object.defineProperty(o, "default", {
                    enumerable: true,
                    value: v1
                });
            } : function(o, v1) {
                o["default"] = v1;
            });
            var __importStar = exports && exports.__importStar || function(mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) {
                    for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                }
                __setModuleDefault(result, mod);
                return result;
            };
            var __importDefault = exports && exports.__importDefault || function(mod) {
                return mod && mod.__esModule ? mod : {
                    "default": mod
                };
            };
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
            var decode_data_html_js_1 = __importDefault(require_decode_data_html());
            exports.htmlDecodeTree = decode_data_html_js_1.default;
            var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
            exports.xmlDecodeTree = decode_data_xml_js_1.default;
            var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
            exports.decodeCodePoint = decode_codepoint_js_1.default;
            var decode_codepoint_js_2 = require_decode_codepoint();
            Object.defineProperty(exports, "replaceCodePoint", {
                enumerable: true,
                get: function get() {
                    return decode_codepoint_js_2.replaceCodePoint;
                }
            });
            Object.defineProperty(exports, "fromCodePoint", {
                enumerable: true,
                get: function get() {
                    return decode_codepoint_js_2.fromCodePoint;
                }
            });
            var CharCodes;
            (function(CharCodes2) {
                CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
                CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
                CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
                CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
                CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
                CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
                CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
                CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
                CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
                CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
                CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
                CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
            })(CharCodes || (CharCodes = {}));
            var TO_LOWER_BIT = 32;
            var BinTrieFlags;
            (function(BinTrieFlags2) {
                BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
                BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
                BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
            })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
            function isNumber(code) {
                return code >= CharCodes.ZERO && code <= CharCodes.NINE;
            }
            function isHexadecimalCharacter(code) {
                return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
            }
            function isAsciiAlphaNumeric(code) {
                return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
            }
            function isEntityInAttributeInvalidEnd(code) {
                return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
            }
            var EntityDecoderState;
            (function(EntityDecoderState2) {
                EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
                EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
                EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
                EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
                EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
            })(EntityDecoderState || (EntityDecoderState = {}));
            var DecodingMode;
            (function(DecodingMode2) {
                DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
                DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
                DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
            })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
            var EntityDecoder = /** @class */ function() {
                function EntityDecoder2(decodeTree, emitCodePoint, errors) {
                    this.decodeTree = decodeTree;
                    this.emitCodePoint = emitCodePoint;
                    this.errors = errors;
                    this.state = EntityDecoderState.EntityStart;
                    this.consumed = 1;
                    this.result = 0;
                    this.treeIndex = 0;
                    this.excess = 1;
                    this.decodeMode = DecodingMode.Strict;
                }
                EntityDecoder2.prototype.startEntity = function(decodeMode) {
                    this.decodeMode = decodeMode;
                    this.state = EntityDecoderState.EntityStart;
                    this.result = 0;
                    this.treeIndex = 0;
                    this.excess = 1;
                    this.consumed = 1;
                };
                EntityDecoder2.prototype.write = function(str, offset) {
                    switch(this.state){
                        case EntityDecoderState.EntityStart:
                            {
                                if (str.charCodeAt(offset) === CharCodes.NUM) {
                                    this.state = EntityDecoderState.NumericStart;
                                    this.consumed += 1;
                                    return this.stateNumericStart(str, offset + 1);
                                }
                                this.state = EntityDecoderState.NamedEntity;
                                return this.stateNamedEntity(str, offset);
                            }
                        case EntityDecoderState.NumericStart:
                            {
                                return this.stateNumericStart(str, offset);
                            }
                        case EntityDecoderState.NumericDecimal:
                            {
                                return this.stateNumericDecimal(str, offset);
                            }
                        case EntityDecoderState.NumericHex:
                            {
                                return this.stateNumericHex(str, offset);
                            }
                        case EntityDecoderState.NamedEntity:
                            {
                                return this.stateNamedEntity(str, offset);
                            }
                    }
                };
                EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
                    if (offset >= str.length) {
                        return -1;
                    }
                    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
                        this.state = EntityDecoderState.NumericHex;
                        this.consumed += 1;
                        return this.stateNumericHex(str, offset + 1);
                    }
                    this.state = EntityDecoderState.NumericDecimal;
                    return this.stateNumericDecimal(str, offset);
                };
                EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
                    if (start !== end) {
                        var digitCount = end - start;
                        this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
                        this.consumed += digitCount;
                    }
                };
                EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
                    var startIdx = offset;
                    while(offset < str.length){
                        var char = str.charCodeAt(offset);
                        if (isNumber(char) || isHexadecimalCharacter(char)) {
                            offset += 1;
                        } else {
                            this.addToNumericResult(str, startIdx, offset, 16);
                            return this.emitNumericEntity(char, 3);
                        }
                    }
                    this.addToNumericResult(str, startIdx, offset, 16);
                    return -1;
                };
                EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
                    var startIdx = offset;
                    while(offset < str.length){
                        var char = str.charCodeAt(offset);
                        if (isNumber(char)) {
                            offset += 1;
                        } else {
                            this.addToNumericResult(str, startIdx, offset, 10);
                            return this.emitNumericEntity(char, 2);
                        }
                    }
                    this.addToNumericResult(str, startIdx, offset, 10);
                    return -1;
                };
                EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
                    var _a;
                    if (this.consumed <= expectedLength) {
                        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                        return 0;
                    }
                    if (lastCp === CharCodes.SEMI) {
                        this.consumed += 1;
                    } else if (this.decodeMode === DecodingMode.Strict) {
                        return 0;
                    }
                    this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
                    if (this.errors) {
                        if (lastCp !== CharCodes.SEMI) {
                            this.errors.missingSemicolonAfterCharacterReference();
                        }
                        this.errors.validateNumericCharacterReference(this.result);
                    }
                    return this.consumed;
                };
                EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
                    var decodeTree = this.decodeTree;
                    var current = decodeTree[this.treeIndex];
                    var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
                    for(; offset < str.length; offset++, this.excess++){
                        var char = str.charCodeAt(offset);
                        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
                        if (this.treeIndex < 0) {
                            return this.result === 0 || // If we are parsing an attribute
                            this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
                            (valueLength === 0 || // And there should be no invalid characters.
                            isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
                        }
                        current = decodeTree[this.treeIndex];
                        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
                        if (valueLength !== 0) {
                            if (char === CharCodes.SEMI) {
                                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                            }
                            if (this.decodeMode !== DecodingMode.Strict) {
                                this.result = this.treeIndex;
                                this.consumed += this.excess;
                                this.excess = 0;
                            }
                        }
                    }
                    return -1;
                };
                EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
                    var _a;
                    var _b = this, result = _b.result, decodeTree = _b.decodeTree;
                    var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
                    this.emitNamedEntityData(result, valueLength, this.consumed);
                    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
                    return this.consumed;
                };
                EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
                    var decodeTree = this.decodeTree;
                    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
                    if (valueLength === 3) {
                        this.emitCodePoint(decodeTree[result + 2], consumed);
                    }
                    return consumed;
                };
                EntityDecoder2.prototype.end = function() {
                    var _a;
                    switch(this.state){
                        case EntityDecoderState.NamedEntity:
                            {
                                return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
                            }
                        // Otherwise, emit a numeric entity if we have one.
                        case EntityDecoderState.NumericDecimal:
                            {
                                return this.emitNumericEntity(0, 2);
                            }
                        case EntityDecoderState.NumericHex:
                            {
                                return this.emitNumericEntity(0, 3);
                            }
                        case EntityDecoderState.NumericStart:
                            {
                                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                                return 0;
                            }
                        case EntityDecoderState.EntityStart:
                            {
                                return 0;
                            }
                    }
                };
                return EntityDecoder2;
            }();
            exports.EntityDecoder = EntityDecoder;
            function getDecoder(decodeTree) {
                var ret = "";
                var decoder = new EntityDecoder(decodeTree, function(str) {
                    return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
                });
                return function decodeWithTrie(str, decodeMode) {
                    var lastIndex = 0;
                    var offset = 0;
                    while((offset = str.indexOf("&", offset)) >= 0){
                        ret += str.slice(lastIndex, offset);
                        decoder.startEntity(decodeMode);
                        var len = decoder.write(str, // Skip the "&"
                        offset + 1);
                        if (len < 0) {
                            lastIndex = offset + decoder.end();
                            break;
                        }
                        lastIndex = offset + len;
                        offset = len === 0 ? lastIndex + 1 : lastIndex;
                    }
                    var result = ret + str.slice(lastIndex);
                    ret = "";
                    return result;
                };
            }
            function determineBranch(decodeTree, current, nodeIdx, char) {
                var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
                var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
                if (branchCount === 0) {
                    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
                }
                if (jumpOffset) {
                    var value = char - jumpOffset;
                    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
                }
                var lo = nodeIdx;
                var hi = lo + branchCount - 1;
                while(lo <= hi){
                    var mid = lo + hi >>> 1;
                    var midVal = decodeTree[mid];
                    if (midVal < char) {
                        lo = mid + 1;
                    } else if (midVal > char) {
                        hi = mid - 1;
                    } else {
                        return decodeTree[mid + branchCount];
                    }
                }
                return -1;
            }
            exports.determineBranch = determineBranch;
            var htmlDecoder = getDecoder(decode_data_html_js_1.default);
            var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
            function decodeHTML(str, mode) {
                if (mode === void 0) {
                    mode = DecodingMode.Legacy;
                }
                return htmlDecoder(str, mode);
            }
            exports.decodeHTML = decodeHTML;
            function decodeHTMLAttribute(str) {
                return htmlDecoder(str, DecodingMode.Attribute);
            }
            exports.decodeHTMLAttribute = decodeHTMLAttribute;
            function decodeHTMLStrict(str) {
                return htmlDecoder(str, DecodingMode.Strict);
            }
            exports.decodeHTMLStrict = decodeHTMLStrict;
            function decodeXML(str) {
                return xmlDecoder(str, DecodingMode.Strict);
            }
            exports.decodeXML = decodeXML;
        }
    });
    // ../../node_modules/.pnpm/@babel+parser@7.26.1/node_modules/@babel/parser/lib/index.js
    var require_lib = __commonJS({
        "../../node_modules/.pnpm/@babel+parser@7.26.1/node_modules/@babel/parser/lib/index.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            function _objectWithoutPropertiesLoose(r, e) {
                if (null == r) return {};
                var t = {};
                for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
                    if (e.includes(n)) continue;
                    t[n] = r[n];
                }
                return t;
            }
            var Position = function Position(line, col, index) {
                _class_call_check(this, Position);
                this.line = void 0;
                this.column = void 0;
                this.index = void 0;
                this.line = line;
                this.column = col;
                this.index = index;
            };
            var SourceLocation = function SourceLocation(start, end) {
                _class_call_check(this, SourceLocation);
                this.start = void 0;
                this.end = void 0;
                this.filename = void 0;
                this.identifierName = void 0;
                this.start = start;
                this.end = end;
            };
            function createPositionWithColumnOffset(position, columnOffset) {
                var line = position.line, column = position.column, index = position.index;
                return new Position(line, column + columnOffset, index + columnOffset);
            }
            var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
            var ModuleErrors = {
                ImportMetaOutsideModule: {
                    message: "import.meta may appear only with 'sourceType: \"module\"'",
                    code: code
                },
                ImportOutsideModule: {
                    message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                    code: code
                }
            };
            var NodeDescriptions = {
                ArrayPattern: "array destructuring pattern",
                AssignmentExpression: "assignment expression",
                AssignmentPattern: "assignment expression",
                ArrowFunctionExpression: "arrow function expression",
                ConditionalExpression: "conditional expression",
                CatchClause: "catch clause",
                ForOfStatement: "for-of statement",
                ForInStatement: "for-in statement",
                ForStatement: "for-loop",
                FormalParameters: "function parameter list",
                Identifier: "identifier",
                ImportSpecifier: "import specifier",
                ImportDefaultSpecifier: "import default specifier",
                ImportNamespaceSpecifier: "import namespace specifier",
                ObjectPattern: "object destructuring pattern",
                ParenthesizedExpression: "parenthesized expression",
                RestElement: "rest element",
                UpdateExpression: {
                    true: "prefix operation",
                    false: "postfix operation"
                },
                VariableDeclarator: "variable declaration",
                YieldExpression: "yield expression"
            };
            var toNodeDescription = function(node) {
                return node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression["".concat(node.prefix)] : NodeDescriptions[node.type];
            };
            var StandardErrors = {
                AccessorIsGenerator: function(param) {
                    var kind = param.kind;
                    return "A ".concat(kind, "ter cannot be a generator.");
                },
                ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
                AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
                AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
                AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
                AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
                AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
                AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
                AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
                BadGetterArity: "A 'get' accessor must not have any formal parameters.",
                BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
                BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
                ConstructorClassField: "Classes may not have a field named 'constructor'.",
                ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
                ConstructorIsAccessor: "Class constructor may not be an accessor.",
                ConstructorIsAsync: "Constructor can't be an async function.",
                ConstructorIsGenerator: "Constructor can't be a generator.",
                DeclarationMissingInitializer: function(param) {
                    var kind = param.kind;
                    return "Missing initializer in ".concat(kind, " declaration.");
                },
                DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
                DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
                DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
                DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
                DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
                DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
                DecoratorStaticBlock: "Decorators can't be used with a static block.",
                DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
                DeletePrivateField: "Deleting a private field is not allowed.",
                DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
                DuplicateConstructor: "Duplicate constructor in the same class.",
                DuplicateDefaultExport: "Only one default export allowed per module.",
                DuplicateExport: function(param) {
                    var exportName = param.exportName;
                    return "`".concat(exportName, "` has already been exported. Exported identifiers must be unique.");
                },
                DuplicateProto: "Redefinition of __proto__ property.",
                DuplicateRegExpFlags: "Duplicate regular expression flag.",
                DynamicImportPhaseRequiresImportExpressions: function(param) {
                    var phase = param.phase;
                    return "'import.".concat(phase, "(...)' can only be parsed when using the 'createImportExpressions' option.");
                },
                ElementAfterRest: "Rest element must be last element.",
                EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
                ExportBindingIsString: function(param) {
                    var localName = param.localName, exportName = param.exportName;
                    return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(localName, "' as '").concat(exportName, "' } from 'some-module'`?");
                },
                ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
                ForInOfLoopInitializer: function(param) {
                    var type = param.type;
                    return "'".concat(type === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
                },
                ForInUsing: "For-in loop may not start with 'using' declaration.",
                ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
                ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
                GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
                IllegalBreakContinue: function(param) {
                    var type = param.type;
                    return "Unsyntactic ".concat(type === "BreakStatement" ? "break" : "continue", ".");
                },
                IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
                IllegalReturn: "'return' outside of function.",
                ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
                ImportBindingIsString: function(param) {
                    var importName = param.importName;
                    return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(importName, '" as foo }`?');
                },
                ImportCallArity: "`import()` requires exactly one or two arguments.",
                ImportCallNotNewExpression: "Cannot use new with import(...).",
                ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
                ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
                ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
                ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
                IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
                InvalidBigIntLiteral: "Invalid BigIntLiteral.",
                InvalidCodePoint: "Code point out of bounds.",
                InvalidCoverInitializedName: "Invalid shorthand property initializer.",
                InvalidDecimal: "Invalid decimal.",
                InvalidDigit: function(param) {
                    var radix = param.radix;
                    return "Expected number in radix ".concat(radix, ".");
                },
                InvalidEscapeSequence: "Bad character escape sequence.",
                InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
                InvalidEscapedReservedWord: function(param) {
                    var reservedWord = param.reservedWord;
                    return "Escape sequence in keyword ".concat(reservedWord, ".");
                },
                InvalidIdentifier: function(param) {
                    var identifierName = param.identifierName;
                    return "Invalid identifier ".concat(identifierName, ".");
                },
                InvalidLhs: function(param) {
                    var ancestor = param.ancestor;
                    return "Invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
                },
                InvalidLhsBinding: function(param) {
                    var ancestor = param.ancestor;
                    return "Binding invalid left-hand side in ".concat(toNodeDescription(ancestor), ".");
                },
                InvalidLhsOptionalChaining: function(param) {
                    var ancestor = param.ancestor;
                    return "Invalid optional chaining in the left-hand side of ".concat(toNodeDescription(ancestor), ".");
                },
                InvalidNumber: "Invalid number.",
                InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
                InvalidOrUnexpectedToken: function(param) {
                    var unexpected = param.unexpected;
                    return "Unexpected character '".concat(unexpected, "'.");
                },
                InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
                InvalidPrivateFieldResolution: function(param) {
                    var identifierName = param.identifierName;
                    return "Private name #".concat(identifierName, " is not defined.");
                },
                InvalidPropertyBindingPattern: "Binding member expression.",
                InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
                InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
                LabelRedeclaration: function(param) {
                    var labelName = param.labelName;
                    return "Label '".concat(labelName, "' is already declared.");
                },
                LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
                LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
                MalformedRegExpFlags: "Invalid regular expression flag.",
                MissingClassName: "A class name is required.",
                MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
                MissingSemicolon: "Missing semicolon.",
                MissingPlugin: function(param) {
                    var missingPlugin = param.missingPlugin;
                    return "This experimental syntax requires enabling the parser plugin: ".concat(missingPlugin.map(function(name) {
                        return JSON.stringify(name);
                    }).join(", "), ".");
                },
                MissingOneOfPlugins: function(param) {
                    var missingPlugin = param.missingPlugin;
                    return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(missingPlugin.map(function(name) {
                        return JSON.stringify(name);
                    }).join(", "), ".");
                },
                MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
                MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
                ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
                ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
                ModuleAttributesWithDuplicateKeys: function(param) {
                    var key = param.key;
                    return 'Duplicate key "'.concat(key, '" is not allowed in module attributes.');
                },
                ModuleExportNameHasLoneSurrogate: function(param) {
                    var surrogateCharCode = param.surrogateCharCode;
                    return "An export name cannot include a lone surrogate, found '\\u".concat(surrogateCharCode.toString(16), "'.");
                },
                ModuleExportUndefined: function(param) {
                    var localName = param.localName;
                    return "Export '".concat(localName, "' is not defined.");
                },
                MultipleDefaultsInSwitch: "Multiple default clauses.",
                NewlineAfterThrow: "Illegal newline after throw.",
                NoCatchOrFinally: "Missing catch or finally clause.",
                NumberIdentifier: "Identifier directly after number.",
                NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
                ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
                OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
                OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
                OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
                ParamDupe: "Argument name clash.",
                PatternHasAccessor: "Object pattern can't contain getter or setter.",
                PatternHasMethod: "Object pattern can't contain methods.",
                PrivateInExpectedIn: function(param) {
                    var identifierName = param.identifierName;
                    return "Private names are only allowed in property accesses (`obj.#".concat(identifierName, "`) or in `in` expressions (`#").concat(identifierName, " in obj`).");
                },
                PrivateNameRedeclaration: function(param) {
                    var identifierName = param.identifierName;
                    return "Duplicate private name #".concat(identifierName, ".");
                },
                RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                RecordNoProto: "'__proto__' is not allowed in Record expressions.",
                RestTrailingComma: "Unexpected trailing comma after rest element.",
                SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
                SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
                SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
                StaticPrototype: "Classes may not have static property named prototype.",
                SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
                SuperPrivateField: "Private fields can't be accessed on super.",
                TrailingDecorator: "Decorators must be attached to a class element.",
                TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
                UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
                UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
                UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
                UnexpectedKeyword: function(param) {
                    var keyword = param.keyword;
                    return "Unexpected keyword '".concat(keyword, "'.");
                },
                UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
                UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
                UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
                UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
                UnexpectedPrivateField: "Unexpected private name.",
                UnexpectedReservedWord: function(param) {
                    var reservedWord = param.reservedWord;
                    return "Unexpected reserved word '".concat(reservedWord, "'.");
                },
                UnexpectedSuper: "'super' is only allowed in object methods and classes.",
                UnexpectedToken: function(param) {
                    var expected = param.expected, unexpected = param.unexpected;
                    return "Unexpected token".concat(unexpected ? " '".concat(unexpected, "'.") : "").concat(expected ? ', expected "'.concat(expected, '"') : "");
                },
                UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
                UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
                UnsupportedBind: "Binding should be performed on object property.",
                UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
                UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
                UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
                UnsupportedMetaProperty: function(param) {
                    var target = param.target, onlyValidPropertyName = param.onlyValidPropertyName;
                    return "The only valid meta property for ".concat(target, " is ").concat(target, ".").concat(onlyValidPropertyName, ".");
                },
                UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
                UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
                UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
                UnterminatedComment: "Unterminated comment.",
                UnterminatedRegExp: "Unterminated regular expression.",
                UnterminatedString: "Unterminated string constant.",
                UnterminatedTemplate: "Unterminated template.",
                UsingDeclarationExport: "Using declaration cannot be exported.",
                UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
                VarRedeclaration: function(param) {
                    var identifierName = param.identifierName;
                    return "Identifier '".concat(identifierName, "' has already been declared.");
                },
                YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
                YieldInParameter: "Yield expression is not allowed in formal parameters.",
                ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
            };
            var StrictModeErrors = {
                StrictDelete: "Deleting local variable in strict mode.",
                StrictEvalArguments: function(param) {
                    var referenceName = param.referenceName;
                    return "Assigning to '".concat(referenceName, "' in strict mode.");
                },
                StrictEvalArgumentsBinding: function(param) {
                    var bindingName = param.bindingName;
                    return "Binding '".concat(bindingName, "' in strict mode.");
                },
                StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
                StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
                StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
                StrictWith: "'with' in strict mode."
            };
            var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set([
                "ArrowFunctionExpression",
                "AssignmentExpression",
                "ConditionalExpression",
                "YieldExpression"
            ]);
            var PipelineOperatorErrors = {
                PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
                PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
                PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
                PipeTopicUnconfiguredToken: function(param) {
                    var token = param.token;
                    return "Invalid topic token ".concat(token, ". In order to use ").concat(token, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(token, '" }.');
                },
                PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
                PipeUnparenthesizedBody: function(param) {
                    var type = param.type;
                    return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({
                        type: type
                    }), "; please wrap it in parentheses.");
                },
                PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
                PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
                PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
                PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
                PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
                PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
            };
            var _excluded = [
                "message"
            ];
            function defineHidden(obj, key, value) {
                Object.defineProperty(obj, key, {
                    enumerable: false,
                    configurable: true,
                    value: value
                });
            }
            function toParseErrorConstructor(param) {
                var toMessage = param.toMessage, code2 = param.code, reasonCode = param.reasonCode, syntaxPlugin = param.syntaxPlugin;
                var hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
                {
                    var oldReasonCodes = {
                        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
                        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
                        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
                        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
                        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
                        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
                    };
                    if (oldReasonCodes[reasonCode]) {
                        reasonCode = oldReasonCodes[reasonCode];
                    }
                }
                return function constructor(loc, details) {
                    var error = new SyntaxError();
                    error.code = code2;
                    error.reasonCode = reasonCode;
                    error.loc = loc;
                    error.pos = loc.index;
                    error.syntaxPlugin = syntaxPlugin;
                    if (hasMissingPlugin) {
                        error.missingPlugin = details.missingPlugin;
                    }
                    defineHidden(error, "clone", function clone() {
                        var overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                        var _overrides$loc;
                        var _ref = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc, line = _ref.line, column = _ref.column, index = _ref.index;
                        return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
                    });
                    defineHidden(error, "details", details);
                    Object.defineProperty(error, "message", {
                        configurable: true,
                        get: function get() {
                            var message = "".concat(toMessage(details), " (").concat(loc.line, ":").concat(loc.column, ")");
                            this.message = message;
                            return message;
                        },
                        set: function set(value) {
                            Object.defineProperty(this, "message", {
                                value: value,
                                writable: true
                            });
                        }
                    });
                    return error;
                };
            }
            function ParseErrorEnum(argument, syntaxPlugin) {
                if (Array.isArray(argument)) {
                    return function(parseErrorTemplates) {
                        return ParseErrorEnum(parseErrorTemplates, argument[0]);
                    };
                }
                var ParseErrorConstructors = {};
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    var _loop = function() {
                        var reasonCode = _step.value;
                        var template = argument[reasonCode];
                        var _ref = typeof template === "string" ? {
                            message: function() {
                                return template;
                            }
                        } : typeof template === "function" ? {
                            message: template
                        } : template, message = _ref.message, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
                        var toMessage = typeof message === "string" ? function() {
                            return message;
                        } : message;
                        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
                            code: "BABEL_PARSER_SYNTAX_ERROR",
                            reasonCode: reasonCode,
                            toMessage: toMessage
                        }, syntaxPlugin ? {
                            syntaxPlugin: syntaxPlugin
                        } : {}, rest));
                    };
                    for(var _iterator = Object.keys(argument)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return ParseErrorConstructors;
            }
            var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(_templateObject())(PipelineOperatorErrors));
            var defineProperty = Object.defineProperty;
            var toUnenumerable = function(object, key) {
                if (object) {
                    defineProperty(object, key, {
                        enumerable: false,
                        value: object[key]
                    });
                }
            };
            function toESTreeLocation(node) {
                toUnenumerable(node.loc.start, "index");
                toUnenumerable(node.loc.end, "index");
                return node;
            }
            var estree = function(superClass) {
                var ESTreeParserMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(ESTreeParserMixin, superClass);
                    function ESTreeParserMixin() {
                        _class_call_check(this, ESTreeParserMixin);
                        return _call_super(this, ESTreeParserMixin, arguments);
                    }
                    _create_class(ESTreeParserMixin, [
                        {
                            key: "parse",
                            value: function parse() {
                                var file = toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin.prototype), "parse", this).call(this));
                                if (this.options.tokens) {
                                    file.tokens = file.tokens.map(toESTreeLocation);
                                }
                                return file;
                            }
                        },
                        {
                            key: "parseRegExpLiteral",
                            value: function parseRegExpLiteral(param) {
                                var pattern = param.pattern, flags = param.flags;
                                var regex = null;
                                try {
                                    regex = new RegExp(pattern, flags);
                                } catch (_) {}
                                var node = this.estreeParseLiteral(regex);
                                node.regex = {
                                    pattern: pattern,
                                    flags: flags
                                };
                                return node;
                            }
                        },
                        {
                            key: "parseBigIntLiteral",
                            value: function parseBigIntLiteral(value) {
                                var bigInt;
                                try {
                                    bigInt = BigInt(value);
                                } catch (_unused) {
                                    bigInt = null;
                                }
                                var node = this.estreeParseLiteral(bigInt);
                                node.bigint = String(node.value || value);
                                return node;
                            }
                        },
                        {
                            key: "parseDecimalLiteral",
                            value: function parseDecimalLiteral(value) {
                                var decimal = null;
                                var node = this.estreeParseLiteral(decimal);
                                node.decimal = String(node.value || value);
                                return node;
                            }
                        },
                        {
                            key: "estreeParseLiteral",
                            value: function estreeParseLiteral(value) {
                                return this.parseLiteral(value, "Literal");
                            }
                        },
                        {
                            key: "parseStringLiteral",
                            value: function parseStringLiteral(value) {
                                return this.estreeParseLiteral(value);
                            }
                        },
                        {
                            key: "parseNumericLiteral",
                            value: function parseNumericLiteral(value) {
                                return this.estreeParseLiteral(value);
                            }
                        },
                        {
                            key: "parseNullLiteral",
                            value: function parseNullLiteral() {
                                return this.estreeParseLiteral(null);
                            }
                        },
                        {
                            key: "parseBooleanLiteral",
                            value: function parseBooleanLiteral(value) {
                                return this.estreeParseLiteral(value);
                            }
                        },
                        {
                            key: "directiveToStmt",
                            value: function directiveToStmt(directive) {
                                var expression = directive.value;
                                delete directive.value;
                                expression.type = "Literal";
                                expression.raw = expression.extra.raw;
                                expression.value = expression.extra.expressionValue;
                                var stmt = directive;
                                stmt.type = "ExpressionStatement";
                                stmt.expression = expression;
                                stmt.directive = expression.extra.rawValue;
                                delete expression.extra;
                                return stmt;
                            }
                        },
                        {
                            key: "initFunction",
                            value: function initFunction(node, isAsync) {
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "initFunction", this).call(this, node, isAsync);
                                node.expression = false;
                            }
                        },
                        {
                            key: "checkDeclaration",
                            value: function checkDeclaration(node) {
                                if (node != null && this.isObjectProperty(node)) {
                                    this.checkDeclaration(node.value);
                                } else {
                                    _get(_get_prototype_of(ESTreeParserMixin.prototype), "checkDeclaration", this).call(this, node);
                                }
                            }
                        },
                        {
                            key: "getObjectOrClassMethodParams",
                            value: function getObjectOrClassMethodParams(method) {
                                return method.value.params;
                            }
                        },
                        {
                            key: "isValidDirective",
                            value: function isValidDirective(stmt) {
                                var _stmt$expression$extr;
                                return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
                            }
                        },
                        {
                            key: "parseBlockBody",
                            value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
                                var _this = this;
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseBlockBody", this).call(this, node, allowDirectives, topLevel, end, afterBlockParse);
                                var directiveStatements = node.directives.map(function(d) {
                                    return _this.directiveToStmt(d);
                                });
                                node.body = directiveStatements.concat(node.body);
                                delete node.directives;
                            }
                        },
                        {
                            key: "pushClassMethod",
                            value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                                this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
                                if (method.typeParameters) {
                                    method.value.typeParameters = method.typeParameters;
                                    delete method.typeParameters;
                                }
                                classBody.body.push(method);
                            }
                        },
                        {
                            key: "parsePrivateName",
                            value: function parsePrivateName() {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parsePrivateName", this).call(this);
                                {
                                    if (!this.getPluginOption("estree", "classFeatures")) {
                                        return node;
                                    }
                                }
                                return this.convertPrivateNameToPrivateIdentifier(node);
                            }
                        },
                        {
                            key: "convertPrivateNameToPrivateIdentifier",
                            value: function convertPrivateNameToPrivateIdentifier(node) {
                                var name = _get(_get_prototype_of(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);
                                node = node;
                                delete node.id;
                                node.name = name;
                                node.type = "PrivateIdentifier";
                                return node;
                            }
                        },
                        {
                            key: "isPrivateName",
                            value: function isPrivateName(node) {
                                {
                                    if (!this.getPluginOption("estree", "classFeatures")) {
                                        return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isPrivateName", this).call(this, node);
                                    }
                                }
                                return node.type === "PrivateIdentifier";
                            }
                        },
                        {
                            key: "getPrivateNameSV",
                            value: function getPrivateNameSV(node) {
                                {
                                    if (!this.getPluginOption("estree", "classFeatures")) {
                                        return _get(_get_prototype_of(ESTreeParserMixin.prototype), "getPrivateNameSV", this).call(this, node);
                                    }
                                }
                                return node.name;
                            }
                        },
                        {
                            key: "parseLiteral",
                            value: function parseLiteral(value, type) {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseLiteral", this).call(this, value, type);
                                node.raw = node.extra.raw;
                                delete node.extra;
                                return node;
                            }
                        },
                        {
                            key: "parseFunctionBody",
                            value: function parseFunctionBody(node, allowExpression) {
                                var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseFunctionBody", this).call(this, node, allowExpression, isMethod);
                                node.expression = node.body.type !== "BlockStatement";
                            }
                        },
                        {
                            key: "parseMethod",
                            value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
                                var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                                var funcNode = this.startNode();
                                funcNode.kind = node.kind;
                                funcNode = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseMethod", this).call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
                                funcNode.type = "FunctionExpression";
                                delete funcNode.kind;
                                node.value = funcNode;
                                if (type === "ClassPrivateMethod") {
                                    node.computed = false;
                                }
                                return this.finishNode(node, "MethodDefinition");
                            }
                        },
                        {
                            key: "nameIsConstructor",
                            value: function nameIsConstructor(key) {
                                if (key.type === "Literal") return key.value === "constructor";
                                return _get(_get_prototype_of(ESTreeParserMixin.prototype), "nameIsConstructor", this).call(this, key);
                            }
                        },
                        {
                            key: "parseClassProperty",
                            value: function parseClassProperty() {
                                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                    args[_key] = arguments[_key];
                                }
                                var _$_get;
                                var propertyNode = (_$_get = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseClassProperty", this)).call.apply(_$_get, [
                                    this
                                ].concat(_to_consumable_array(args)));
                                {
                                    if (!this.getPluginOption("estree", "classFeatures")) {
                                        return propertyNode;
                                    }
                                }
                                propertyNode.type = "PropertyDefinition";
                                return propertyNode;
                            }
                        },
                        {
                            key: "parseClassPrivateProperty",
                            value: function parseClassPrivateProperty() {
                                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                    args[_key] = arguments[_key];
                                }
                                var _$_get;
                                var propertyNode = (_$_get = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseClassPrivateProperty", this)).call.apply(_$_get, [
                                    this
                                ].concat(_to_consumable_array(args)));
                                {
                                    if (!this.getPluginOption("estree", "classFeatures")) {
                                        return propertyNode;
                                    }
                                }
                                propertyNode.type = "PropertyDefinition";
                                propertyNode.computed = false;
                                return propertyNode;
                            }
                        },
                        {
                            key: "parseObjectMethod",
                            value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseObjectMethod", this).call(this, prop, isGenerator, isAsync, isPattern, isAccessor);
                                if (node) {
                                    node.type = "Property";
                                    if (node.kind === "method") {
                                        node.kind = "init";
                                    }
                                    node.shorthand = false;
                                }
                                return node;
                            }
                        },
                        {
                            key: "parseObjectProperty",
                            value: function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseObjectProperty", this).call(this, prop, startLoc, isPattern, refExpressionErrors);
                                if (node) {
                                    node.kind = "init";
                                    node.type = "Property";
                                }
                                return node;
                            }
                        },
                        {
                            key: "isValidLVal",
                            value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                                return type === "Property" ? "value" : _get(_get_prototype_of(ESTreeParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
                            }
                        },
                        {
                            key: "isAssignable",
                            value: function isAssignable(node, isBinding) {
                                if (node != null && this.isObjectProperty(node)) {
                                    return this.isAssignable(node.value, isBinding);
                                }
                                return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                            }
                        },
                        {
                            key: "toAssignable",
                            value: function toAssignable(node) {
                                var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                                if (node != null && this.isObjectProperty(node)) {
                                    var key = node.key, value = node.value;
                                    if (this.isPrivateName(key)) {
                                        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                                    }
                                    this.toAssignable(value, isLHS);
                                } else {
                                    _get(_get_prototype_of(ESTreeParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                                }
                            }
                        },
                        {
                            key: "toAssignableObjectExpressionProp",
                            value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
                                if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
                                    this.raise(Errors.PatternHasAccessor, prop.key);
                                } else if (prop.type === "Property" && prop.method) {
                                    this.raise(Errors.PatternHasMethod, prop.key);
                                } else {
                                    _get(_get_prototype_of(ESTreeParserMixin.prototype), "toAssignableObjectExpressionProp", this).call(this, prop, isLast, isLHS);
                                }
                            }
                        },
                        {
                            key: "finishCallExpression",
                            value: function finishCallExpression(unfinished, optional) {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "finishCallExpression", this).call(this, unfinished, optional);
                                if (node.callee.type === "Import") {
                                    var _ref, _ref2;
                                    node.type = "ImportExpression";
                                    node.source = node.arguments[0];
                                    node.options = (_ref = node.arguments[1]) != null ? _ref : null;
                                    node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
                                    delete node.arguments;
                                    delete node.callee;
                                }
                                return node;
                            }
                        },
                        {
                            key: "toReferencedArguments",
                            value: function toReferencedArguments(node) {
                                if (node.type === "ImportExpression") {
                                    return;
                                }
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "toReferencedArguments", this).call(this, node);
                            }
                        },
                        {
                            key: "parseExport",
                            value: function parseExport(unfinished, decorators) {
                                var exportStartLoc = this.state.lastTokStartLoc;
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseExport", this).call(this, unfinished, decorators);
                                switch(node.type){
                                    case "ExportAllDeclaration":
                                        node.exported = null;
                                        break;
                                    case "ExportNamedDeclaration":
                                        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                                            node.type = "ExportAllDeclaration";
                                            node.exported = node.specifiers[0].exported;
                                            delete node.specifiers;
                                        }
                                    case "ExportDefaultDeclaration":
                                        {
                                            var _declaration$decorato;
                                            var declaration = node.declaration;
                                            if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                                                this.resetStartLocation(node, exportStartLoc);
                                            }
                                        }
                                        break;
                                }
                                return node;
                            }
                        },
                        {
                            key: "parseSubscript",
                            value: function parseSubscript(base, startLoc, noCalls, state) {
                                var node = _get(_get_prototype_of(ESTreeParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
                                if (state.optionalChainMember) {
                                    if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
                                        node.type = node.type.substring(8);
                                    }
                                    if (state.stop) {
                                        var chain = this.startNodeAtNode(node);
                                        chain.expression = node;
                                        return this.finishNode(chain, "ChainExpression");
                                    }
                                } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
                                    node.optional = false;
                                }
                                return node;
                            }
                        },
                        {
                            key: "isOptionalMemberExpression",
                            value: function isOptionalMemberExpression(node) {
                                if (node.type === "ChainExpression") {
                                    return node.expression.type === "MemberExpression";
                                }
                                return _get(_get_prototype_of(ESTreeParserMixin.prototype), "isOptionalMemberExpression", this).call(this, node);
                            }
                        },
                        {
                            key: "hasPropertyAsPrivateName",
                            value: function hasPropertyAsPrivateName(node) {
                                if (node.type === "ChainExpression") {
                                    node = node.expression;
                                }
                                return _get(_get_prototype_of(ESTreeParserMixin.prototype), "hasPropertyAsPrivateName", this).call(this, node);
                            }
                        },
                        {
                            key: "isObjectProperty",
                            value: function isObjectProperty(node) {
                                return node.type === "Property" && node.kind === "init" && !node.method;
                            }
                        },
                        {
                            key: "isObjectMethod",
                            value: function isObjectMethod(node) {
                                return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
                            }
                        },
                        {
                            key: "finishNodeAt",
                            value: function finishNodeAt(node, type, endLoc) {
                                return toESTreeLocation(_get(_get_prototype_of(ESTreeParserMixin.prototype), "finishNodeAt", this).call(this, node, type, endLoc));
                            }
                        },
                        {
                            key: "resetStartLocation",
                            value: function resetStartLocation(node, startLoc) {
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "resetStartLocation", this).call(this, node, startLoc);
                                toESTreeLocation(node);
                            }
                        },
                        {
                            key: "resetEndLocation",
                            value: function resetEndLocation(node) {
                                var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                                _get(_get_prototype_of(ESTreeParserMixin.prototype), "resetEndLocation", this).call(this, node, endLoc);
                                toESTreeLocation(node);
                            }
                        }
                    ]);
                    return ESTreeParserMixin;
                }(superClass);
                return ESTreeParserMixin;
            };
            var TokContext = function TokContext(token, preserveSpace) {
                _class_call_check(this, TokContext);
                this.token = void 0;
                this.preserveSpace = void 0;
                this.token = token;
                this.preserveSpace = !!preserveSpace;
            };
            var types = {
                brace: new TokContext("{"),
                j_oTag: new TokContext("<tag"),
                j_cTag: new TokContext("</tag"),
                j_expr: new TokContext("<tag>...</tag>", true)
            };
            {
                types.template = new TokContext("`", true);
            }
            var beforeExpr = true;
            var startsExpr = true;
            var isLoop = true;
            var isAssign = true;
            var prefix = true;
            var postfix = true;
            var ExportedTokenType = function ExportedTokenType(label) {
                var conf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _class_call_check(this, ExportedTokenType);
                this.label = void 0;
                this.keyword = void 0;
                this.beforeExpr = void 0;
                this.startsExpr = void 0;
                this.rightAssociative = void 0;
                this.isLoop = void 0;
                this.isAssign = void 0;
                this.prefix = void 0;
                this.postfix = void 0;
                this.binop = void 0;
                this.label = label;
                this.keyword = conf.keyword;
                this.beforeExpr = !!conf.beforeExpr;
                this.startsExpr = !!conf.startsExpr;
                this.rightAssociative = !!conf.rightAssociative;
                this.isLoop = !!conf.isLoop;
                this.isAssign = !!conf.isAssign;
                this.prefix = !!conf.prefix;
                this.postfix = !!conf.postfix;
                this.binop = conf.binop != null ? conf.binop : null;
                {
                    this.updateContext = null;
                }
            };
            var keywords$1 = /* @__PURE__ */ new Map();
            function createKeyword(name) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                options.keyword = name;
                var token = createToken(name, options);
                keywords$1.set(name, token);
                return token;
            }
            function createBinop(name, binop) {
                return createToken(name, {
                    beforeExpr: beforeExpr,
                    binop: binop
                });
            }
            var tokenTypeCounter = -1;
            var tokenTypes = [];
            var tokenLabels = [];
            var tokenBinops = [];
            var tokenBeforeExprs = [];
            var tokenStartsExprs = [];
            var tokenPrefixes = [];
            function createToken(name) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
                ++tokenTypeCounter;
                tokenLabels.push(name);
                tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
                tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
                tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
                tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
                tokenTypes.push(new ExportedTokenType(name, options));
                return tokenTypeCounter;
            }
            function createKeywordLike(name) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
                ++tokenTypeCounter;
                keywords$1.set(name, tokenTypeCounter);
                tokenLabels.push(name);
                tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
                tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
                tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
                tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
                tokenTypes.push(new ExportedTokenType("name", options));
                return tokenTypeCounter;
            }
            var tt = {
                bracketL: createToken("[", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                bracketHashL: createToken("#[", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                bracketBarL: createToken("[|", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                bracketR: createToken("]"),
                bracketBarR: createToken("|]"),
                braceL: createToken("{", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                braceBarL: createToken("{|", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                braceHashL: createToken("#{", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                braceR: createToken("}"),
                braceBarR: createToken("|}"),
                parenL: createToken("(", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                parenR: createToken(")"),
                comma: createToken(",", {
                    beforeExpr: beforeExpr
                }),
                semi: createToken(";", {
                    beforeExpr: beforeExpr
                }),
                colon: createToken(":", {
                    beforeExpr: beforeExpr
                }),
                doubleColon: createToken("::", {
                    beforeExpr: beforeExpr
                }),
                dot: createToken("."),
                question: createToken("?", {
                    beforeExpr: beforeExpr
                }),
                questionDot: createToken("?."),
                arrow: createToken("=>", {
                    beforeExpr: beforeExpr
                }),
                template: createToken("template"),
                ellipsis: createToken("...", {
                    beforeExpr: beforeExpr
                }),
                backQuote: createToken("`", {
                    startsExpr: startsExpr
                }),
                dollarBraceL: createToken("${", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                templateTail: createToken("...`", {
                    startsExpr: startsExpr
                }),
                templateNonTail: createToken("...${", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                at: createToken("@"),
                hash: createToken("#", {
                    startsExpr: startsExpr
                }),
                interpreterDirective: createToken("#!..."),
                eq: createToken("=", {
                    beforeExpr: beforeExpr,
                    isAssign: isAssign
                }),
                assign: createToken("_=", {
                    beforeExpr: beforeExpr,
                    isAssign: isAssign
                }),
                slashAssign: createToken("_=", {
                    beforeExpr: beforeExpr,
                    isAssign: isAssign
                }),
                xorAssign: createToken("_=", {
                    beforeExpr: beforeExpr,
                    isAssign: isAssign
                }),
                moduloAssign: createToken("_=", {
                    beforeExpr: beforeExpr,
                    isAssign: isAssign
                }),
                incDec: createToken("++/--", {
                    prefix: prefix,
                    postfix: postfix,
                    startsExpr: startsExpr
                }),
                bang: createToken("!", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                tilde: createToken("~", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                doubleCaret: createToken("^^", {
                    startsExpr: startsExpr
                }),
                doubleAt: createToken("@@", {
                    startsExpr: startsExpr
                }),
                pipeline: createBinop("|>", 0),
                nullishCoalescing: createBinop("??", 1),
                logicalOR: createBinop("||", 1),
                logicalAND: createBinop("&&", 2),
                bitwiseOR: createBinop("|", 3),
                bitwiseXOR: createBinop("^", 4),
                bitwiseAND: createBinop("&", 5),
                equality: createBinop("==/!=/===/!==", 6),
                lt: createBinop("</>/<=/>=", 7),
                gt: createBinop("</>/<=/>=", 7),
                relational: createBinop("</>/<=/>=", 7),
                bitShift: createBinop("<</>>/>>>", 8),
                bitShiftL: createBinop("<</>>/>>>", 8),
                bitShiftR: createBinop("<</>>/>>>", 8),
                plusMin: createToken("+/-", {
                    beforeExpr: beforeExpr,
                    binop: 9,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                modulo: createToken("%", {
                    binop: 10,
                    startsExpr: startsExpr
                }),
                star: createToken("*", {
                    binop: 10
                }),
                slash: createBinop("/", 10),
                exponent: createToken("**", {
                    beforeExpr: beforeExpr,
                    binop: 11,
                    rightAssociative: true
                }),
                _in: createKeyword("in", {
                    beforeExpr: beforeExpr,
                    binop: 7
                }),
                _instanceof: createKeyword("instanceof", {
                    beforeExpr: beforeExpr,
                    binop: 7
                }),
                _break: createKeyword("break"),
                _case: createKeyword("case", {
                    beforeExpr: beforeExpr
                }),
                _catch: createKeyword("catch"),
                _continue: createKeyword("continue"),
                _debugger: createKeyword("debugger"),
                _default: createKeyword("default", {
                    beforeExpr: beforeExpr
                }),
                _else: createKeyword("else", {
                    beforeExpr: beforeExpr
                }),
                _finally: createKeyword("finally"),
                _function: createKeyword("function", {
                    startsExpr: startsExpr
                }),
                _if: createKeyword("if"),
                _return: createKeyword("return", {
                    beforeExpr: beforeExpr
                }),
                _switch: createKeyword("switch"),
                _throw: createKeyword("throw", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                _try: createKeyword("try"),
                _var: createKeyword("var"),
                _const: createKeyword("const"),
                _with: createKeyword("with"),
                _new: createKeyword("new", {
                    beforeExpr: beforeExpr,
                    startsExpr: startsExpr
                }),
                _this: createKeyword("this", {
                    startsExpr: startsExpr
                }),
                _super: createKeyword("super", {
                    startsExpr: startsExpr
                }),
                _class: createKeyword("class", {
                    startsExpr: startsExpr
                }),
                _extends: createKeyword("extends", {
                    beforeExpr: beforeExpr
                }),
                _export: createKeyword("export"),
                _import: createKeyword("import", {
                    startsExpr: startsExpr
                }),
                _null: createKeyword("null", {
                    startsExpr: startsExpr
                }),
                _true: createKeyword("true", {
                    startsExpr: startsExpr
                }),
                _false: createKeyword("false", {
                    startsExpr: startsExpr
                }),
                _typeof: createKeyword("typeof", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                _void: createKeyword("void", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                _delete: createKeyword("delete", {
                    beforeExpr: beforeExpr,
                    prefix: prefix,
                    startsExpr: startsExpr
                }),
                _do: createKeyword("do", {
                    isLoop: isLoop,
                    beforeExpr: beforeExpr
                }),
                _for: createKeyword("for", {
                    isLoop: isLoop
                }),
                _while: createKeyword("while", {
                    isLoop: isLoop
                }),
                _as: createKeywordLike("as", {
                    startsExpr: startsExpr
                }),
                _assert: createKeywordLike("assert", {
                    startsExpr: startsExpr
                }),
                _async: createKeywordLike("async", {
                    startsExpr: startsExpr
                }),
                _await: createKeywordLike("await", {
                    startsExpr: startsExpr
                }),
                _defer: createKeywordLike("defer", {
                    startsExpr: startsExpr
                }),
                _from: createKeywordLike("from", {
                    startsExpr: startsExpr
                }),
                _get: createKeywordLike("get", {
                    startsExpr: startsExpr
                }),
                _let: createKeywordLike("let", {
                    startsExpr: startsExpr
                }),
                _meta: createKeywordLike("meta", {
                    startsExpr: startsExpr
                }),
                _of: createKeywordLike("of", {
                    startsExpr: startsExpr
                }),
                _sent: createKeywordLike("sent", {
                    startsExpr: startsExpr
                }),
                _set: createKeywordLike("set", {
                    startsExpr: startsExpr
                }),
                _source: createKeywordLike("source", {
                    startsExpr: startsExpr
                }),
                _static: createKeywordLike("static", {
                    startsExpr: startsExpr
                }),
                _using: createKeywordLike("using", {
                    startsExpr: startsExpr
                }),
                _yield: createKeywordLike("yield", {
                    startsExpr: startsExpr
                }),
                _asserts: createKeywordLike("asserts", {
                    startsExpr: startsExpr
                }),
                _checks: createKeywordLike("checks", {
                    startsExpr: startsExpr
                }),
                _exports: createKeywordLike("exports", {
                    startsExpr: startsExpr
                }),
                _global: createKeywordLike("global", {
                    startsExpr: startsExpr
                }),
                _implements: createKeywordLike("implements", {
                    startsExpr: startsExpr
                }),
                _intrinsic: createKeywordLike("intrinsic", {
                    startsExpr: startsExpr
                }),
                _infer: createKeywordLike("infer", {
                    startsExpr: startsExpr
                }),
                _is: createKeywordLike("is", {
                    startsExpr: startsExpr
                }),
                _mixins: createKeywordLike("mixins", {
                    startsExpr: startsExpr
                }),
                _proto: createKeywordLike("proto", {
                    startsExpr: startsExpr
                }),
                _require: createKeywordLike("require", {
                    startsExpr: startsExpr
                }),
                _satisfies: createKeywordLike("satisfies", {
                    startsExpr: startsExpr
                }),
                _keyof: createKeywordLike("keyof", {
                    startsExpr: startsExpr
                }),
                _readonly: createKeywordLike("readonly", {
                    startsExpr: startsExpr
                }),
                _unique: createKeywordLike("unique", {
                    startsExpr: startsExpr
                }),
                _abstract: createKeywordLike("abstract", {
                    startsExpr: startsExpr
                }),
                _declare: createKeywordLike("declare", {
                    startsExpr: startsExpr
                }),
                _enum: createKeywordLike("enum", {
                    startsExpr: startsExpr
                }),
                _module: createKeywordLike("module", {
                    startsExpr: startsExpr
                }),
                _namespace: createKeywordLike("namespace", {
                    startsExpr: startsExpr
                }),
                _interface: createKeywordLike("interface", {
                    startsExpr: startsExpr
                }),
                _type: createKeywordLike("type", {
                    startsExpr: startsExpr
                }),
                _opaque: createKeywordLike("opaque", {
                    startsExpr: startsExpr
                }),
                name: createToken("name", {
                    startsExpr: startsExpr
                }),
                string: createToken("string", {
                    startsExpr: startsExpr
                }),
                num: createToken("num", {
                    startsExpr: startsExpr
                }),
                bigint: createToken("bigint", {
                    startsExpr: startsExpr
                }),
                decimal: createToken("decimal", {
                    startsExpr: startsExpr
                }),
                regexp: createToken("regexp", {
                    startsExpr: startsExpr
                }),
                privateName: createToken("#name", {
                    startsExpr: startsExpr
                }),
                eof: createToken("eof"),
                jsxName: createToken("jsxName"),
                jsxText: createToken("jsxText", {
                    beforeExpr: true
                }),
                jsxTagStart: createToken("jsxTagStart", {
                    startsExpr: true
                }),
                jsxTagEnd: createToken("jsxTagEnd"),
                placeholder: createToken("%%", {
                    startsExpr: true
                })
            };
            function tokenIsIdentifier(token) {
                return token >= 93 && token <= 132;
            }
            function tokenKeywordOrIdentifierIsKeyword(token) {
                return token <= 92;
            }
            function tokenIsKeywordOrIdentifier(token) {
                return token >= 58 && token <= 132;
            }
            function tokenIsLiteralPropertyName(token) {
                return token >= 58 && token <= 136;
            }
            function tokenComesBeforeExpression(token) {
                return tokenBeforeExprs[token];
            }
            function tokenCanStartExpression(token) {
                return tokenStartsExprs[token];
            }
            function tokenIsAssignment(token) {
                return token >= 29 && token <= 33;
            }
            function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
                return token >= 129 && token <= 131;
            }
            function tokenIsLoop(token) {
                return token >= 90 && token <= 92;
            }
            function tokenIsKeyword(token) {
                return token >= 58 && token <= 92;
            }
            function tokenIsOperator(token) {
                return token >= 39 && token <= 59;
            }
            function tokenIsPostfix(token) {
                return token === 34;
            }
            function tokenIsPrefix(token) {
                return tokenPrefixes[token];
            }
            function tokenIsTSTypeOperator(token) {
                return token >= 121 && token <= 123;
            }
            function tokenIsTSDeclarationStart(token) {
                return token >= 124 && token <= 130;
            }
            function tokenLabelName(token) {
                return tokenLabels[token];
            }
            function tokenOperatorPrecedence(token) {
                return tokenBinops[token];
            }
            function tokenIsRightAssociative(token) {
                return token === 57;
            }
            function tokenIsTemplate(token) {
                return token >= 24 && token <= 25;
            }
            function getExportedToken(token) {
                return tokenTypes[token];
            }
            {
                tokenTypes[8].updateContext = function(context) {
                    context.pop();
                };
                tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = function(context) {
                    context.push(types.brace);
                };
                tokenTypes[22].updateContext = function(context) {
                    if (context[context.length - 1] === types.template) {
                        context.pop();
                    } else {
                        context.push(types.template);
                    }
                };
                tokenTypes[142].updateContext = function(context) {
                    context.push(types.j_expr, types.j_oTag);
                };
            }
            var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
            var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
            nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
            var astralIdentifierStartCodes = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                4,
                51,
                13,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                39,
                27,
                10,
                22,
                251,
                41,
                7,
                1,
                17,
                2,
                60,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                31,
                9,
                2,
                0,
                3,
                0,
                2,
                37,
                2,
                0,
                26,
                0,
                2,
                0,
                45,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                200,
                32,
                32,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                26,
                3994,
                6,
                582,
                6842,
                29,
                1763,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                433,
                44,
                212,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                42,
                9,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                229,
                29,
                3,
                0,
                496,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                16,
                621,
                2467,
                541,
                1507,
                4938,
                6,
                4191
            ];
            var astralIdentifierCodes = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                7,
                9,
                32,
                4,
                318,
                1,
                80,
                3,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                68,
                8,
                2,
                0,
                3,
                0,
                2,
                3,
                2,
                4,
                2,
                0,
                15,
                1,
                83,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                7,
                19,
                58,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                343,
                9,
                54,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                10,
                5350,
                0,
                7,
                14,
                11465,
                27,
                2343,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                535,
                9,
                470,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4178,
                9,
                519,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                245,
                1,
                2,
                9,
                726,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(code2, set) {
                var pos = 65536;
                for(var i = 0, length = set.length; i < length; i += 2){
                    pos += set[i];
                    if (pos > code2) return false;
                    pos += set[i + 1];
                    if (pos >= code2) return true;
                }
                return false;
            }
            function isIdentifierStart(code2) {
                if (code2 < 65) return code2 === 36;
                if (code2 <= 90) return true;
                if (code2 < 97) return code2 === 95;
                if (code2 <= 122) return true;
                if (code2 <= 65535) {
                    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
                }
                return isInAstralSet(code2, astralIdentifierStartCodes);
            }
            function isIdentifierChar(code2) {
                if (code2 < 48) return code2 === 36;
                if (code2 < 58) return true;
                if (code2 < 65) return false;
                if (code2 <= 90) return true;
                if (code2 < 97) return code2 === 95;
                if (code2 <= 122) return true;
                if (code2 <= 65535) {
                    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
                }
                return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
            }
            var reservedWords = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            var keywords = new Set(reservedWords.keyword);
            var reservedWordsStrictSet = new Set(reservedWords.strict);
            var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
            function isReservedWord(word, inModule) {
                return inModule && word === "await" || word === "enum";
            }
            function isStrictReservedWord(word, inModule) {
                return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
            }
            function isStrictBindOnlyReservedWord(word) {
                return reservedWordsStrictBindSet.has(word);
            }
            function isStrictBindReservedWord(word, inModule) {
                return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
            }
            function isKeyword(word) {
                return keywords.has(word);
            }
            function isIteratorStart(current, next, next2) {
                return current === 64 && next === 64 && isIdentifierStart(next2);
            }
            var reservedWordLikeSet = /* @__PURE__ */ new Set([
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete",
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield",
                "eval",
                "arguments",
                "enum",
                "await"
            ]);
            function canBeReservedWord(word) {
                return reservedWordLikeSet.has(word);
            }
            var Scope = function Scope(flags) {
                _class_call_check(this, Scope);
                this.flags = 0;
                this.names = /* @__PURE__ */ new Map();
                this.firstLexicalName = "";
                this.flags = flags;
            };
            var ScopeHandler = /*#__PURE__*/ function() {
                function ScopeHandler(parser, inModule) {
                    _class_call_check(this, ScopeHandler);
                    this.parser = void 0;
                    this.scopeStack = [];
                    this.inModule = void 0;
                    this.undefinedExports = /* @__PURE__ */ new Map();
                    this.parser = parser;
                    this.inModule = inModule;
                }
                _create_class(ScopeHandler, [
                    {
                        key: "inTopLevel",
                        get: function get() {
                            return (this.currentScope().flags & 1) > 0;
                        }
                    },
                    {
                        key: "inFunction",
                        get: function get() {
                            return (this.currentVarScopeFlags() & 2) > 0;
                        }
                    },
                    {
                        key: "allowSuper",
                        get: function get() {
                            return (this.currentThisScopeFlags() & 16) > 0;
                        }
                    },
                    {
                        key: "allowDirectSuper",
                        get: function get() {
                            return (this.currentThisScopeFlags() & 32) > 0;
                        }
                    },
                    {
                        key: "inClass",
                        get: function get() {
                            return (this.currentThisScopeFlags() & 64) > 0;
                        }
                    },
                    {
                        key: "inClassAndNotInNonArrowFunction",
                        get: function get() {
                            var flags = this.currentThisScopeFlags();
                            return (flags & 64) > 0 && (flags & 2) === 0;
                        }
                    },
                    {
                        key: "inStaticBlock",
                        get: function get() {
                            for(var i = this.scopeStack.length - 1;; i--){
                                var flags = this.scopeStack[i].flags;
                                if (flags & 128) {
                                    return true;
                                }
                                if (flags & (387 | 64)) {
                                    return false;
                                }
                            }
                        }
                    },
                    {
                        key: "inNonArrowFunction",
                        get: function get() {
                            return (this.currentThisScopeFlags() & 2) > 0;
                        }
                    },
                    {
                        key: "treatFunctionsAsVar",
                        get: function get() {
                            return this.treatFunctionsAsVarInScope(this.currentScope());
                        }
                    },
                    {
                        key: "createScope",
                        value: function createScope(flags) {
                            return new Scope(flags);
                        }
                    },
                    {
                        key: "enter",
                        value: function enter(flags) {
                            this.scopeStack.push(this.createScope(flags));
                        }
                    },
                    {
                        key: "exit",
                        value: function exit() {
                            var scope = this.scopeStack.pop();
                            return scope.flags;
                        }
                    },
                    {
                        key: "treatFunctionsAsVarInScope",
                        value: function treatFunctionsAsVarInScope(scope) {
                            return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
                        }
                    },
                    {
                        key: "declareName",
                        value: function declareName(name, bindingType, loc) {
                            var scope = this.currentScope();
                            if (bindingType & 8 || bindingType & 16) {
                                this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                var type = scope.names.get(name) || 0;
                                if (bindingType & 16) {
                                    type = type | 4;
                                } else {
                                    if (!scope.firstLexicalName) {
                                        scope.firstLexicalName = name;
                                    }
                                    type = type | 2;
                                }
                                scope.names.set(name, type);
                                if (bindingType & 8) {
                                    this.maybeExportDefined(scope, name);
                                }
                            } else if (bindingType & 4) {
                                for(var i = this.scopeStack.length - 1; i >= 0; --i){
                                    scope = this.scopeStack[i];
                                    this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                    scope.names.set(name, (scope.names.get(name) || 0) | 1);
                                    this.maybeExportDefined(scope, name);
                                    if (scope.flags & 387) break;
                                }
                            }
                            if (this.parser.inModule && scope.flags & 1) {
                                this.undefinedExports.delete(name);
                            }
                        }
                    },
                    {
                        key: "maybeExportDefined",
                        value: function maybeExportDefined(scope, name) {
                            if (this.parser.inModule && scope.flags & 1) {
                                this.undefinedExports.delete(name);
                            }
                        }
                    },
                    {
                        key: "checkRedeclarationInScope",
                        value: function checkRedeclarationInScope(scope, name, bindingType, loc) {
                            if (this.isRedeclaredInScope(scope, name, bindingType)) {
                                this.parser.raise(Errors.VarRedeclaration, loc, {
                                    identifierName: name
                                });
                            }
                        }
                    },
                    {
                        key: "isRedeclaredInScope",
                        value: function isRedeclaredInScope(scope, name, bindingType) {
                            if (!(bindingType & 1)) return false;
                            if (bindingType & 8) {
                                return scope.names.has(name);
                            }
                            var type = scope.names.get(name);
                            if (bindingType & 16) {
                                return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
                            }
                            return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
                        }
                    },
                    {
                        key: "checkLocalExport",
                        value: function checkLocalExport(id) {
                            var name = id.name;
                            var topLevelScope = this.scopeStack[0];
                            if (!topLevelScope.names.has(name)) {
                                this.undefinedExports.set(name, id.loc.start);
                            }
                        }
                    },
                    {
                        key: "currentScope",
                        value: function currentScope() {
                            return this.scopeStack[this.scopeStack.length - 1];
                        }
                    },
                    {
                        key: "currentVarScopeFlags",
                        value: function currentVarScopeFlags() {
                            for(var i = this.scopeStack.length - 1;; i--){
                                var flags = this.scopeStack[i].flags;
                                if (flags & 387) {
                                    return flags;
                                }
                            }
                        }
                    },
                    {
                        key: "currentThisScopeFlags",
                        value: function currentThisScopeFlags() {
                            for(var i = this.scopeStack.length - 1;; i--){
                                var flags = this.scopeStack[i].flags;
                                if (flags & (387 | 64) && !(flags & 4)) {
                                    return flags;
                                }
                            }
                        }
                    }
                ]);
                return ScopeHandler;
            }();
            var FlowScope = /*#__PURE__*/ function(Scope) {
                _inherits(FlowScope, Scope);
                function FlowScope() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    _class_call_check(this, FlowScope);
                    var _this;
                    _this = _call_super(this, FlowScope, _to_consumable_array(args));
                    _this.declareFunctions = /* @__PURE__ */ new Set();
                    return _this;
                }
                return FlowScope;
            }(Scope);
            var FlowScopeHandler = /*#__PURE__*/ function(ScopeHandler) {
                _inherits(FlowScopeHandler, ScopeHandler);
                function FlowScopeHandler() {
                    _class_call_check(this, FlowScopeHandler);
                    return _call_super(this, FlowScopeHandler, arguments);
                }
                _create_class(FlowScopeHandler, [
                    {
                        key: "createScope",
                        value: function createScope(flags) {
                            return new FlowScope(flags);
                        }
                    },
                    {
                        key: "declareName",
                        value: function declareName(name, bindingType, loc) {
                            var scope = this.currentScope();
                            if (bindingType & 2048) {
                                this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                this.maybeExportDefined(scope, name);
                                scope.declareFunctions.add(name);
                                return;
                            }
                            _get(_get_prototype_of(FlowScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);
                        }
                    },
                    {
                        key: "isRedeclaredInScope",
                        value: function isRedeclaredInScope(scope, name, bindingType) {
                            if (_get(_get_prototype_of(FlowScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType)) return true;
                            if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
                                var type = scope.names.get(name);
                                return (type & 4) > 0 || (type & 2) > 0;
                            }
                            return false;
                        }
                    },
                    {
                        key: "checkLocalExport",
                        value: function checkLocalExport(id) {
                            if (!this.scopeStack[0].declareFunctions.has(id.name)) {
                                _get(_get_prototype_of(FlowScopeHandler.prototype), "checkLocalExport", this).call(this, id);
                            }
                        }
                    }
                ]);
                return FlowScopeHandler;
            }(ScopeHandler);
            var BaseParser = /*#__PURE__*/ function() {
                function BaseParser() {
                    _class_call_check(this, BaseParser);
                    this.sawUnambiguousESM = false;
                    this.ambiguousScriptDifferentAst = false;
                }
                _create_class(BaseParser, [
                    {
                        key: "sourceToOffsetPos",
                        value: function sourceToOffsetPos(sourcePos) {
                            return sourcePos + this.startIndex;
                        }
                    },
                    {
                        key: "offsetToSourcePos",
                        value: function offsetToSourcePos(offsetPos) {
                            return offsetPos - this.startIndex;
                        }
                    },
                    {
                        key: "hasPlugin",
                        value: function hasPlugin(pluginConfig) {
                            if (typeof pluginConfig === "string") {
                                return this.plugins.has(pluginConfig);
                            } else {
                                var _pluginConfig = _sliced_to_array(pluginConfig, 2), pluginName = _pluginConfig[0], pluginOptions = _pluginConfig[1];
                                if (!this.hasPlugin(pluginName)) {
                                    return false;
                                }
                                var actualOptions = this.plugins.get(pluginName);
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = Object.keys(pluginOptions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var key = _step.value;
                                        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                                            return false;
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return true;
                            }
                        }
                    },
                    {
                        key: "getPluginOption",
                        value: function getPluginOption(plugin, name) {
                            var _this$plugins$get;
                            return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
                        }
                    }
                ]);
                return BaseParser;
            }();
            function setTrailingComments(node, comments) {
                if (node.trailingComments === void 0) {
                    node.trailingComments = comments;
                } else {
                    var _node_trailingComments;
                    (_node_trailingComments = node.trailingComments).unshift.apply(_node_trailingComments, _to_consumable_array(comments));
                }
            }
            function setLeadingComments(node, comments) {
                if (node.leadingComments === void 0) {
                    node.leadingComments = comments;
                } else {
                    var _node_leadingComments;
                    (_node_leadingComments = node.leadingComments).unshift.apply(_node_leadingComments, _to_consumable_array(comments));
                }
            }
            function setInnerComments(node, comments) {
                if (node.innerComments === void 0) {
                    node.innerComments = comments;
                } else {
                    var _node_innerComments;
                    (_node_innerComments = node.innerComments).unshift.apply(_node_innerComments, _to_consumable_array(comments));
                }
            }
            function adjustInnerComments(node, elements, commentWS) {
                var lastElement = null;
                var i = elements.length;
                while(lastElement === null && i > 0){
                    lastElement = elements[--i];
                }
                if (lastElement === null || lastElement.start > commentWS.start) {
                    setInnerComments(node, commentWS.comments);
                } else {
                    setTrailingComments(lastElement, commentWS.comments);
                }
            }
            var CommentsParser = /*#__PURE__*/ function(BaseParser) {
                _inherits(CommentsParser, BaseParser);
                function CommentsParser() {
                    _class_call_check(this, CommentsParser);
                    return _call_super(this, CommentsParser, arguments);
                }
                _create_class(CommentsParser, [
                    {
                        key: "addComment",
                        value: function addComment(comment) {
                            if (this.filename) comment.loc.filename = this.filename;
                            var commentsLen = this.state.commentsLen;
                            if (this.comments.length !== commentsLen) {
                                this.comments.length = commentsLen;
                            }
                            this.comments.push(comment);
                            this.state.commentsLen++;
                        }
                    },
                    {
                        key: "processComment",
                        value: function processComment(node) {
                            var commentStack = this.state.commentStack;
                            var commentStackLength = commentStack.length;
                            if (commentStackLength === 0) return;
                            var i = commentStackLength - 1;
                            var lastCommentWS = commentStack[i];
                            if (lastCommentWS.start === node.end) {
                                lastCommentWS.leadingNode = node;
                                i--;
                            }
                            var nodeStart = node.start;
                            for(; i >= 0; i--){
                                var commentWS = commentStack[i];
                                var commentEnd = commentWS.end;
                                if (commentEnd > nodeStart) {
                                    commentWS.containingNode = node;
                                    this.finalizeComment(commentWS);
                                    commentStack.splice(i, 1);
                                } else {
                                    if (commentEnd === nodeStart) {
                                        commentWS.trailingNode = node;
                                    }
                                    break;
                                }
                            }
                        }
                    },
                    {
                        key: "finalizeComment",
                        value: function finalizeComment(commentWS) {
                            var comments = commentWS.comments;
                            if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
                                if (commentWS.leadingNode !== null) {
                                    setTrailingComments(commentWS.leadingNode, comments);
                                }
                                if (commentWS.trailingNode !== null) {
                                    setLeadingComments(commentWS.trailingNode, comments);
                                }
                            } else {
                                var node = commentWS.containingNode, commentStart = commentWS.start;
                                if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
                                    switch(node.type){
                                        case "ObjectExpression":
                                        case "ObjectPattern":
                                        case "RecordExpression":
                                            adjustInnerComments(node, node.properties, commentWS);
                                            break;
                                        case "CallExpression":
                                        case "OptionalCallExpression":
                                            adjustInnerComments(node, node.arguments, commentWS);
                                            break;
                                        case "FunctionDeclaration":
                                        case "FunctionExpression":
                                        case "ArrowFunctionExpression":
                                        case "ObjectMethod":
                                        case "ClassMethod":
                                        case "ClassPrivateMethod":
                                            adjustInnerComments(node, node.params, commentWS);
                                            break;
                                        case "ArrayExpression":
                                        case "ArrayPattern":
                                        case "TupleExpression":
                                            adjustInnerComments(node, node.elements, commentWS);
                                            break;
                                        case "ExportNamedDeclaration":
                                        case "ImportDeclaration":
                                            adjustInnerComments(node, node.specifiers, commentWS);
                                            break;
                                        default:
                                            {
                                                setInnerComments(node, comments);
                                            }
                                    }
                                } else {
                                    setInnerComments(node, comments);
                                }
                            }
                        }
                    },
                    {
                        key: "finalizeRemainingComments",
                        value: function finalizeRemainingComments() {
                            var commentStack = this.state.commentStack;
                            for(var i = commentStack.length - 1; i >= 0; i--){
                                this.finalizeComment(commentStack[i]);
                            }
                            this.state.commentStack = [];
                        }
                    },
                    {
                        key: "resetPreviousNodeTrailingComments",
                        value: function resetPreviousNodeTrailingComments(node) {
                            var commentStack = this.state.commentStack;
                            var length = commentStack.length;
                            if (length === 0) return;
                            var commentWS = commentStack[length - 1];
                            if (commentWS.leadingNode === node) {
                                commentWS.leadingNode = null;
                            }
                        }
                    },
                    {
                        key: "resetPreviousIdentifierLeadingComments",
                        value: function resetPreviousIdentifierLeadingComments(node) {
                            var commentStack = this.state.commentStack;
                            var length = commentStack.length;
                            if (length === 0) return;
                            if (commentStack[length - 1].trailingNode === node) {
                                commentStack[length - 1].trailingNode = null;
                            } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
                                commentStack[length - 2].trailingNode = null;
                            }
                        }
                    },
                    {
                        key: "takeSurroundingComments",
                        value: function takeSurroundingComments(node, start, end) {
                            var commentStack = this.state.commentStack;
                            var commentStackLength = commentStack.length;
                            if (commentStackLength === 0) return;
                            var i = commentStackLength - 1;
                            for(; i >= 0; i--){
                                var commentWS = commentStack[i];
                                var commentEnd = commentWS.end;
                                var commentStart = commentWS.start;
                                if (commentStart === end) {
                                    commentWS.leadingNode = node;
                                } else if (commentEnd === start) {
                                    commentWS.trailingNode = node;
                                } else if (commentEnd < start) {
                                    break;
                                }
                            }
                        }
                    }
                ]);
                return CommentsParser;
            }(BaseParser);
            var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
            var lineBreakG = new RegExp(lineBreak.source, "g");
            function isNewLine(code2) {
                switch(code2){
                    case 10:
                    case 13:
                    case 8232:
                    case 8233:
                        return true;
                    default:
                        return false;
                }
            }
            function hasNewLine(input, start, end) {
                for(var i = start; i < end; i++){
                    if (isNewLine(input.charCodeAt(i))) {
                        return true;
                    }
                }
                return false;
            }
            var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
            var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
            function isWhitespace(code2) {
                switch(code2){
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                    case 160:
                    case 5760:
                    case 8192:
                    case 8193:
                    case 8194:
                    case 8195:
                    case 8196:
                    case 8197:
                    case 8198:
                    case 8199:
                    case 8200:
                    case 8201:
                    case 8202:
                    case 8239:
                    case 8287:
                    case 12288:
                    case 65279:
                        return true;
                    default:
                        return false;
                }
            }
            var State = /*#__PURE__*/ function() {
                function _State() {
                    _class_call_check(this, _State);
                    this.flags = 1024;
                    this.startIndex = void 0;
                    this.curLine = void 0;
                    this.lineStart = void 0;
                    this.startLoc = void 0;
                    this.endLoc = void 0;
                    this.errors = [];
                    this.potentialArrowAt = -1;
                    this.noArrowAt = [];
                    this.noArrowParamsConversionAt = [];
                    this.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null
                    };
                    this.labels = [];
                    this.commentsLen = 0;
                    this.commentStack = [];
                    this.pos = 0;
                    this.type = 139;
                    this.value = null;
                    this.start = 0;
                    this.end = 0;
                    this.lastTokEndLoc = null;
                    this.lastTokStartLoc = null;
                    this.context = [
                        types.brace
                    ];
                    this.firstInvalidTemplateEscapePos = null;
                    this.strictErrors = /* @__PURE__ */ new Map();
                    this.tokensLength = 0;
                }
                _create_class(_State, [
                    {
                        key: "strict",
                        get: function get() {
                            return (this.flags & 1) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 1;
                            else this.flags &= -2;
                        }
                    },
                    {
                        key: "init",
                        value: function init(param) {
                            var strictMode = param.strictMode, sourceType = param.sourceType, startIndex = param.startIndex, startLine = param.startLine, startColumn = param.startColumn;
                            this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
                            this.startIndex = startIndex;
                            this.curLine = startLine;
                            this.lineStart = -startColumn;
                            this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
                        }
                    },
                    {
                        key: "maybeInArrowParameters",
                        get: function get() {
                            return (this.flags & 2) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 2;
                            else this.flags &= -3;
                        }
                    },
                    {
                        key: "inType",
                        get: function get() {
                            return (this.flags & 4) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 4;
                            else this.flags &= -5;
                        }
                    },
                    {
                        key: "noAnonFunctionType",
                        get: function get() {
                            return (this.flags & 8) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 8;
                            else this.flags &= -9;
                        }
                    },
                    {
                        key: "hasFlowComment",
                        get: function get() {
                            return (this.flags & 16) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 16;
                            else this.flags &= -17;
                        }
                    },
                    {
                        key: "isAmbientContext",
                        get: function get() {
                            return (this.flags & 32) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 32;
                            else this.flags &= -33;
                        }
                    },
                    {
                        key: "inAbstractClass",
                        get: function get() {
                            return (this.flags & 64) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 64;
                            else this.flags &= -65;
                        }
                    },
                    {
                        key: "inDisallowConditionalTypesContext",
                        get: function get() {
                            return (this.flags & 128) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 128;
                            else this.flags &= -129;
                        }
                    },
                    {
                        key: "soloAwait",
                        get: function get() {
                            return (this.flags & 256) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 256;
                            else this.flags &= -257;
                        }
                    },
                    {
                        key: "inFSharpPipelineDirectBody",
                        get: function get() {
                            return (this.flags & 512) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 512;
                            else this.flags &= -513;
                        }
                    },
                    {
                        key: "canStartJSXElement",
                        get: function get() {
                            return (this.flags & 1024) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 1024;
                            else this.flags &= -1025;
                        }
                    },
                    {
                        key: "containsEsc",
                        get: function get() {
                            return (this.flags & 2048) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 2048;
                            else this.flags &= -2049;
                        }
                    },
                    {
                        key: "hasTopLevelAwait",
                        get: function get() {
                            return (this.flags & 4096) > 0;
                        },
                        set: function set(v1) {
                            if (v1) this.flags |= 4096;
                            else this.flags &= -4097;
                        }
                    },
                    {
                        key: "curPosition",
                        value: function curPosition() {
                            var index = this.startIndex + this.pos;
                            return new Position(this.curLine, index - this.lineStart, index);
                        }
                    },
                    {
                        key: "clone",
                        value: function clone() {
                            var state = new _State();
                            state.flags = this.flags;
                            state.startIndex = this.startIndex;
                            state.curLine = this.curLine;
                            state.lineStart = this.lineStart;
                            state.startLoc = this.startLoc;
                            state.endLoc = this.endLoc;
                            state.errors = this.errors.slice();
                            state.potentialArrowAt = this.potentialArrowAt;
                            state.noArrowAt = this.noArrowAt.slice();
                            state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
                            state.topicContext = this.topicContext;
                            state.labels = this.labels.slice();
                            state.commentsLen = this.commentsLen;
                            state.commentStack = this.commentStack.slice();
                            state.pos = this.pos;
                            state.type = this.type;
                            state.value = this.value;
                            state.start = this.start;
                            state.end = this.end;
                            state.lastTokEndLoc = this.lastTokEndLoc;
                            state.lastTokStartLoc = this.lastTokStartLoc;
                            state.context = this.context.slice();
                            state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
                            state.strictErrors = this.strictErrors;
                            state.tokensLength = this.tokensLength;
                            return state;
                        }
                    }
                ]);
                return _State;
            }();
            var _isDigit = function isDigit(code2) {
                return code2 >= 48 && code2 <= 57;
            };
            var forbiddenNumericSeparatorSiblings = {
                decBinOct: /* @__PURE__ */ new Set([
                    46,
                    66,
                    69,
                    79,
                    95,
                    98,
                    101,
                    111
                ]),
                hex: /* @__PURE__ */ new Set([
                    46,
                    88,
                    95,
                    120
                ])
            };
            var isAllowedNumericSeparatorSibling = {
                bin: function(ch) {
                    return ch === 48 || ch === 49;
                },
                oct: function(ch) {
                    return ch >= 48 && ch <= 55;
                },
                dec: function(ch) {
                    return ch >= 48 && ch <= 57;
                },
                hex: function(ch) {
                    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
                }
            };
            function readStringContents(type, input, pos, lineStart, curLine, errors) {
                var initialPos = pos;
                var initialLineStart = lineStart;
                var initialCurLine = curLine;
                var out = "";
                var firstInvalidLoc = null;
                var chunkStart = pos;
                var length = input.length;
                for(;;){
                    if (pos >= length) {
                        errors.unterminated(initialPos, initialLineStart, initialCurLine);
                        out += input.slice(chunkStart, pos);
                        break;
                    }
                    var ch = input.charCodeAt(pos);
                    if (isStringEnd(type, ch, input, pos)) {
                        out += input.slice(chunkStart, pos);
                        break;
                    }
                    if (ch === 92) {
                        out += input.slice(chunkStart, pos);
                        var res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
                        if (res.ch === null && !firstInvalidLoc) {
                            firstInvalidLoc = {
                                pos: pos,
                                lineStart: lineStart,
                                curLine: curLine
                            };
                        } else {
                            out += res.ch;
                        }
                        var ref;
                        ref = res, pos = ref.pos, lineStart = ref.lineStart, curLine = ref.curLine, ref;
                        chunkStart = pos;
                    } else if (ch === 8232 || ch === 8233) {
                        ++pos;
                        ++curLine;
                        lineStart = pos;
                    } else if (ch === 10 || ch === 13) {
                        if (type === "template") {
                            out += input.slice(chunkStart, pos) + "\n";
                            ++pos;
                            if (ch === 13 && input.charCodeAt(pos) === 10) {
                                ++pos;
                            }
                            ++curLine;
                            chunkStart = lineStart = pos;
                        } else {
                            errors.unterminated(initialPos, initialLineStart, initialCurLine);
                        }
                    } else {
                        ++pos;
                    }
                }
                return {
                    pos: pos,
                    str: out,
                    firstInvalidLoc: firstInvalidLoc,
                    lineStart: lineStart,
                    curLine: curLine,
                    containsInvalid: !!firstInvalidLoc
                };
            }
            function isStringEnd(type, ch, input, pos) {
                if (type === "template") {
                    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
                }
                return ch === (type === "double" ? 34 : 39);
            }
            function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
                var throwOnInvalid = !inTemplate;
                pos++;
                var res = function(ch2) {
                    return {
                        pos: pos,
                        ch: ch2,
                        lineStart: lineStart,
                        curLine: curLine
                    };
                };
                var ch = input.charCodeAt(pos++);
                switch(ch){
                    case 110:
                        return res("\n");
                    case 114:
                        return res("\r");
                    case 120:
                        {
                            var code2;
                            var ref;
                            ref = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors), code2 = ref.code, pos = ref.pos, ref;
                            return res(code2 === null ? null : String.fromCharCode(code2));
                        }
                    case 117:
                        {
                            var code21;
                            var ref1;
                            ref1 = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors), code21 = ref1.code, pos = ref1.pos, ref1;
                            return res(code21 === null ? null : String.fromCodePoint(code21));
                        }
                    case 116:
                        return res("	");
                    case 98:
                        return res("\b");
                    case 118:
                        return res("\v");
                    case 102:
                        return res("\f");
                    case 13:
                        if (input.charCodeAt(pos) === 10) {
                            ++pos;
                        }
                    case 10:
                        lineStart = pos;
                        ++curLine;
                    case 8232:
                    case 8233:
                        return res("");
                    case 56:
                    case 57:
                        if (inTemplate) {
                            return res(null);
                        } else {
                            errors.strictNumericEscape(pos - 1, lineStart, curLine);
                        }
                    default:
                        if (ch >= 48 && ch <= 55) {
                            var startPos = pos - 1;
                            var match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
                            var octalStr = match[0];
                            var octal = parseInt(octalStr, 8);
                            if (octal > 255) {
                                octalStr = octalStr.slice(0, -1);
                                octal = parseInt(octalStr, 8);
                            }
                            pos += octalStr.length - 1;
                            var next = input.charCodeAt(pos);
                            if (octalStr !== "0" || next === 56 || next === 57) {
                                if (inTemplate) {
                                    return res(null);
                                } else {
                                    errors.strictNumericEscape(startPos, lineStart, curLine);
                                }
                            }
                            return res(String.fromCharCode(octal));
                        }
                        return res(String.fromCharCode(ch));
                }
            }
            function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
                var initialPos = pos;
                var n;
                var ref;
                ref = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid), n = ref.n, pos = ref.pos, ref;
                if (n === null) {
                    if (throwOnInvalid) {
                        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
                    } else {
                        pos = initialPos - 1;
                    }
                }
                return {
                    code: n,
                    pos: pos
                };
            }
            function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
                var start = pos;
                var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
                var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
                var invalid = false;
                var total = 0;
                for(var i = 0, e = len == null ? Infinity : len; i < e; ++i){
                    var code2 = input.charCodeAt(pos);
                    var val = void 0;
                    if (code2 === 95 && allowNumSeparator !== "bail") {
                        var prev = input.charCodeAt(pos - 1);
                        var next = input.charCodeAt(pos + 1);
                        if (!allowNumSeparator) {
                            if (bailOnError) return {
                                n: null,
                                pos: pos
                            };
                            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
                        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                            if (bailOnError) return {
                                n: null,
                                pos: pos
                            };
                            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
                        }
                        ++pos;
                        continue;
                    }
                    if (code2 >= 97) {
                        val = code2 - 97 + 10;
                    } else if (code2 >= 65) {
                        val = code2 - 65 + 10;
                    } else if (_isDigit(code2)) {
                        val = code2 - 48;
                    } else {
                        val = Infinity;
                    }
                    if (val >= radix) {
                        if (val <= 9 && bailOnError) {
                            return {
                                n: null,
                                pos: pos
                            };
                        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                            val = 0;
                        } else if (forceLen) {
                            val = 0;
                            invalid = true;
                        } else {
                            break;
                        }
                    }
                    ++pos;
                    total = total * radix + val;
                }
                if (pos === start || len != null && pos - start !== len || invalid) {
                    return {
                        n: null,
                        pos: pos
                    };
                }
                return {
                    n: total,
                    pos: pos
                };
            }
            function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
                var ch = input.charCodeAt(pos);
                var code2;
                if (ch === 123) {
                    ++pos;
                    var ref;
                    ref = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors), code2 = ref.code, pos = ref.pos, ref;
                    ++pos;
                    if (code2 !== null && code2 > 1114111) {
                        if (throwOnInvalid) {
                            errors.invalidCodePoint(pos, lineStart, curLine);
                        } else {
                            return {
                                code: null,
                                pos: pos
                            };
                        }
                    }
                } else {
                    var ref1;
                    ref1 = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors), code2 = ref1.code, pos = ref1.pos, ref1;
                }
                return {
                    code: code2,
                    pos: pos
                };
            }
            function buildPosition(pos, lineStart, curLine) {
                return new Position(curLine, pos - lineStart, pos);
            }
            var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([
                103,
                109,
                115,
                105,
                121,
                117,
                100,
                118
            ]);
            var Token = function Token(state) {
                _class_call_check(this, Token);
                this.type = state.type;
                this.value = state.value;
                this.start = state.start;
                this.end = state.end;
                this.loc = new SourceLocation(state.startLoc, state.endLoc);
            };
            var Tokenizer = /*#__PURE__*/ function(CommentsParser) {
                _inherits(Tokenizer, CommentsParser);
                function Tokenizer(options, input) {
                    _class_call_check(this, Tokenizer);
                    var _this;
                    _this = _call_super(this, Tokenizer);
                    _this.isLookahead = void 0;
                    _this.tokens = [];
                    _this.errorHandlers_readInt = {
                        invalidDigit: function(pos, lineStart, curLine, radix) {
                            if (!_this.options.errorRecovery) return false;
                            _this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
                                radix: radix
                            });
                            return true;
                        },
                        numericSeparatorInEscapeSequence: _this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
                        unexpectedNumericSeparator: _this.errorBuilder(Errors.UnexpectedNumericSeparator)
                    };
                    _this.errorHandlers_readCodePoint = Object.assign({}, _this.errorHandlers_readInt, {
                        invalidEscapeSequence: _this.errorBuilder(Errors.InvalidEscapeSequence),
                        invalidCodePoint: _this.errorBuilder(Errors.InvalidCodePoint)
                    });
                    _this.errorHandlers_readStringContents_string = Object.assign({}, _this.errorHandlers_readCodePoint, {
                        strictNumericEscape: function(pos, lineStart, curLine) {
                            _this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
                        },
                        unterminated: function(pos, lineStart, curLine) {
                            throw _this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
                        }
                    });
                    _this.errorHandlers_readStringContents_template = Object.assign({}, _this.errorHandlers_readCodePoint, {
                        strictNumericEscape: _this.errorBuilder(Errors.StrictNumericEscape),
                        unterminated: function(pos, lineStart, curLine) {
                            throw _this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
                        }
                    });
                    _this.state = new State();
                    _this.state.init(options);
                    _this.input = input;
                    _this.length = input.length;
                    _this.comments = [];
                    _this.isLookahead = false;
                    return _this;
                }
                _create_class(Tokenizer, [
                    {
                        key: "pushToken",
                        value: function pushToken(token) {
                            this.tokens.length = this.state.tokensLength;
                            this.tokens.push(token);
                            ++this.state.tokensLength;
                        }
                    },
                    {
                        key: "next",
                        value: function next() {
                            this.checkKeywordEscapes();
                            if (this.options.tokens) {
                                this.pushToken(new Token(this.state));
                            }
                            this.state.lastTokEndLoc = this.state.endLoc;
                            this.state.lastTokStartLoc = this.state.startLoc;
                            this.nextToken();
                        }
                    },
                    {
                        key: "eat",
                        value: function eat(type) {
                            if (this.match(type)) {
                                this.next();
                                return true;
                            } else {
                                return false;
                            }
                        }
                    },
                    {
                        key: "match",
                        value: function match(type) {
                            return this.state.type === type;
                        }
                    },
                    {
                        key: "createLookaheadState",
                        value: function createLookaheadState(state) {
                            return {
                                pos: state.pos,
                                value: null,
                                type: state.type,
                                start: state.start,
                                end: state.end,
                                context: [
                                    this.curContext()
                                ],
                                inType: state.inType,
                                startLoc: state.startLoc,
                                lastTokEndLoc: state.lastTokEndLoc,
                                curLine: state.curLine,
                                lineStart: state.lineStart,
                                curPosition: state.curPosition
                            };
                        }
                    },
                    {
                        key: "lookahead",
                        value: function lookahead() {
                            var old = this.state;
                            this.state = this.createLookaheadState(old);
                            this.isLookahead = true;
                            this.nextToken();
                            this.isLookahead = false;
                            var curr = this.state;
                            this.state = old;
                            return curr;
                        }
                    },
                    {
                        key: "nextTokenStart",
                        value: function nextTokenStart() {
                            return this.nextTokenStartSince(this.state.pos);
                        }
                    },
                    {
                        key: "nextTokenStartSince",
                        value: function nextTokenStartSince(pos) {
                            skipWhiteSpace.lastIndex = pos;
                            return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
                        }
                    },
                    {
                        key: "lookaheadCharCode",
                        value: function lookaheadCharCode() {
                            return this.input.charCodeAt(this.nextTokenStart());
                        }
                    },
                    {
                        key: "nextTokenInLineStart",
                        value: function nextTokenInLineStart() {
                            return this.nextTokenInLineStartSince(this.state.pos);
                        }
                    },
                    {
                        key: "nextTokenInLineStartSince",
                        value: function nextTokenInLineStartSince(pos) {
                            skipWhiteSpaceInLine.lastIndex = pos;
                            return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
                        }
                    },
                    {
                        key: "lookaheadInLineCharCode",
                        value: function lookaheadInLineCharCode() {
                            return this.input.charCodeAt(this.nextTokenInLineStart());
                        }
                    },
                    {
                        key: "codePointAtPos",
                        value: function codePointAtPos(pos) {
                            var cp = this.input.charCodeAt(pos);
                            if ((cp & 64512) === 55296 && ++pos < this.input.length) {
                                var trail = this.input.charCodeAt(pos);
                                if ((trail & 64512) === 56320) {
                                    cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
                                }
                            }
                            return cp;
                        }
                    },
                    {
                        key: "setStrict",
                        value: function setStrict(strict) {
                            var _this = this;
                            this.state.strict = strict;
                            if (strict) {
                                this.state.strictErrors.forEach(function(param) {
                                    var _param = _sliced_to_array(param, 2), toParseError = _param[0], at = _param[1];
                                    return _this.raise(toParseError, at);
                                });
                                this.state.strictErrors.clear();
                            }
                        }
                    },
                    {
                        key: "curContext",
                        value: function curContext() {
                            return this.state.context[this.state.context.length - 1];
                        }
                    },
                    {
                        key: "nextToken",
                        value: function nextToken() {
                            this.skipSpace();
                            this.state.start = this.state.pos;
                            if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
                            if (this.state.pos >= this.length) {
                                this.finishToken(139);
                                return;
                            }
                            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
                        }
                    },
                    {
                        key: "skipBlockComment",
                        value: function skipBlockComment(commentEnd) {
                            var startLoc;
                            if (!this.isLookahead) startLoc = this.state.curPosition();
                            var start = this.state.pos;
                            var end = this.input.indexOf(commentEnd, start + 2);
                            if (end === -1) {
                                throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
                            }
                            this.state.pos = end + commentEnd.length;
                            lineBreakG.lastIndex = start + 2;
                            while(lineBreakG.test(this.input) && lineBreakG.lastIndex <= end){
                                ++this.state.curLine;
                                this.state.lineStart = lineBreakG.lastIndex;
                            }
                            if (this.isLookahead) return;
                            var comment = {
                                type: "CommentBlock",
                                value: this.input.slice(start + 2, end),
                                start: start,
                                end: end + commentEnd.length,
                                loc: new SourceLocation(startLoc, this.state.curPosition())
                            };
                            if (this.options.tokens) this.pushToken(comment);
                            return comment;
                        }
                    },
                    {
                        key: "skipLineComment",
                        value: function skipLineComment(startSkip) {
                            var start = this.state.pos;
                            var startLoc;
                            if (!this.isLookahead) startLoc = this.state.curPosition();
                            var ch = this.input.charCodeAt(this.state.pos += startSkip);
                            if (this.state.pos < this.length) {
                                while(!isNewLine(ch) && ++this.state.pos < this.length){
                                    ch = this.input.charCodeAt(this.state.pos);
                                }
                            }
                            if (this.isLookahead) return;
                            var end = this.state.pos;
                            var value = this.input.slice(start + startSkip, end);
                            var comment = {
                                type: "CommentLine",
                                value: value,
                                start: start,
                                end: end,
                                loc: new SourceLocation(startLoc, this.state.curPosition())
                            };
                            if (this.options.tokens) this.pushToken(comment);
                            return comment;
                        }
                    },
                    {
                        key: "skipSpace",
                        value: function skipSpace() {
                            var spaceStart = this.state.pos;
                            var comments = [];
                            loop: while(this.state.pos < this.length){
                                var ch = this.input.charCodeAt(this.state.pos);
                                switch(ch){
                                    case 32:
                                    case 160:
                                    case 9:
                                        ++this.state.pos;
                                        break;
                                    case 13:
                                        if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                                            ++this.state.pos;
                                        }
                                    case 10:
                                    case 8232:
                                    case 8233:
                                        ++this.state.pos;
                                        ++this.state.curLine;
                                        this.state.lineStart = this.state.pos;
                                        break;
                                    case 47:
                                        switch(this.input.charCodeAt(this.state.pos + 1)){
                                            case 42:
                                                {
                                                    var comment = this.skipBlockComment("*/");
                                                    if (comment !== void 0) {
                                                        this.addComment(comment);
                                                        if (this.options.attachComment) comments.push(comment);
                                                    }
                                                    break;
                                                }
                                            case 47:
                                                {
                                                    var comment1 = this.skipLineComment(2);
                                                    if (comment1 !== void 0) {
                                                        this.addComment(comment1);
                                                        if (this.options.attachComment) comments.push(comment1);
                                                    }
                                                    break;
                                                }
                                            default:
                                                break loop;
                                        }
                                        break;
                                    default:
                                        if (isWhitespace(ch)) {
                                            ++this.state.pos;
                                        } else if (ch === 45 && !this.inModule && this.options.annexB) {
                                            var pos = this.state.pos;
                                            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                                                var comment2 = this.skipLineComment(3);
                                                if (comment2 !== void 0) {
                                                    this.addComment(comment2);
                                                    if (this.options.attachComment) comments.push(comment2);
                                                }
                                            } else {
                                                break loop;
                                            }
                                        } else if (ch === 60 && !this.inModule && this.options.annexB) {
                                            var pos1 = this.state.pos;
                                            if (this.input.charCodeAt(pos1 + 1) === 33 && this.input.charCodeAt(pos1 + 2) === 45 && this.input.charCodeAt(pos1 + 3) === 45) {
                                                var comment3 = this.skipLineComment(4);
                                                if (comment3 !== void 0) {
                                                    this.addComment(comment3);
                                                    if (this.options.attachComment) comments.push(comment3);
                                                }
                                            } else {
                                                break loop;
                                            }
                                        } else {
                                            break loop;
                                        }
                                }
                            }
                            if (comments.length > 0) {
                                var end = this.state.pos;
                                var commentWhitespace = {
                                    start: this.sourceToOffsetPos(spaceStart),
                                    end: this.sourceToOffsetPos(end),
                                    comments: comments,
                                    leadingNode: null,
                                    trailingNode: null,
                                    containingNode: null
                                };
                                this.state.commentStack.push(commentWhitespace);
                            }
                        }
                    },
                    {
                        key: "finishToken",
                        value: function finishToken(type, val) {
                            this.state.end = this.state.pos;
                            this.state.endLoc = this.state.curPosition();
                            var prevType = this.state.type;
                            this.state.type = type;
                            this.state.value = val;
                            if (!this.isLookahead) {
                                this.updateContext(prevType);
                            }
                        }
                    },
                    {
                        key: "replaceToken",
                        value: function replaceToken(type) {
                            this.state.type = type;
                            this.updateContext();
                        }
                    },
                    {
                        key: "readToken_numberSign",
                        value: function readToken_numberSign() {
                            if (this.state.pos === 0 && this.readToken_interpreter()) {
                                return;
                            }
                            var nextPos = this.state.pos + 1;
                            var next = this.codePointAtPos(nextPos);
                            if (next >= 48 && next <= 57) {
                                throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
                            }
                            if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
                                this.expectPlugin("recordAndTuple");
                                if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
                                    throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
                                }
                                this.state.pos += 2;
                                if (next === 123) {
                                    this.finishToken(7);
                                } else {
                                    this.finishToken(1);
                                }
                            } else if (isIdentifierStart(next)) {
                                ++this.state.pos;
                                this.finishToken(138, this.readWord1(next));
                            } else if (next === 92) {
                                ++this.state.pos;
                                this.finishToken(138, this.readWord1());
                            } else {
                                this.finishOp(27, 1);
                            }
                        }
                    },
                    {
                        key: "readToken_dot",
                        value: function readToken_dot() {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next >= 48 && next <= 57) {
                                this.readNumber(true);
                                return;
                            }
                            if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
                                this.state.pos += 3;
                                this.finishToken(21);
                            } else {
                                ++this.state.pos;
                                this.finishToken(16);
                            }
                        }
                    },
                    {
                        key: "readToken_slash",
                        value: function readToken_slash() {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === 61) {
                                this.finishOp(31, 2);
                            } else {
                                this.finishOp(56, 1);
                            }
                        }
                    },
                    {
                        key: "readToken_interpreter",
                        value: function readToken_interpreter() {
                            if (this.state.pos !== 0 || this.length < 2) return false;
                            var ch = this.input.charCodeAt(this.state.pos + 1);
                            if (ch !== 33) return false;
                            var start = this.state.pos;
                            this.state.pos += 1;
                            while(!isNewLine(ch) && ++this.state.pos < this.length){
                                ch = this.input.charCodeAt(this.state.pos);
                            }
                            var value = this.input.slice(start + 2, this.state.pos);
                            this.finishToken(28, value);
                            return true;
                        }
                    },
                    {
                        key: "readToken_mult_modulo",
                        value: function readToken_mult_modulo(code2) {
                            var type = code2 === 42 ? 55 : 54;
                            var width = 1;
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (code2 === 42 && next === 42) {
                                width++;
                                next = this.input.charCodeAt(this.state.pos + 2);
                                type = 57;
                            }
                            if (next === 61 && !this.state.inType) {
                                width++;
                                type = code2 === 37 ? 33 : 30;
                            }
                            this.finishOp(type, width);
                        }
                    },
                    {
                        key: "readToken_pipe_amp",
                        value: function readToken_pipe_amp(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === code2) {
                                if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                                    this.finishOp(30, 3);
                                } else {
                                    this.finishOp(code2 === 124 ? 41 : 42, 2);
                                }
                                return;
                            }
                            if (code2 === 124) {
                                if (next === 62) {
                                    this.finishOp(39, 2);
                                    return;
                                }
                                if (this.hasPlugin("recordAndTuple") && next === 125) {
                                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                        throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                                    }
                                    this.state.pos += 2;
                                    this.finishToken(9);
                                    return;
                                }
                                if (this.hasPlugin("recordAndTuple") && next === 93) {
                                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                        throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                                    }
                                    this.state.pos += 2;
                                    this.finishToken(4);
                                    return;
                                }
                            }
                            if (next === 61) {
                                this.finishOp(30, 2);
                                return;
                            }
                            this.finishOp(code2 === 124 ? 43 : 45, 1);
                        }
                    },
                    {
                        key: "readToken_caret",
                        value: function readToken_caret() {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === 61 && !this.state.inType) {
                                this.finishOp(32, 2);
                            } else if (next === 94 && this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "hack",
                                    topicToken: "^^"
                                }
                            ])) {
                                this.finishOp(37, 2);
                                var lookaheadCh = this.input.codePointAt(this.state.pos);
                                if (lookaheadCh === 94) {
                                    this.unexpected();
                                }
                            } else {
                                this.finishOp(44, 1);
                            }
                        }
                    },
                    {
                        key: "readToken_atSign",
                        value: function readToken_atSign() {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === 64 && this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "hack",
                                    topicToken: "@@"
                                }
                            ])) {
                                this.finishOp(38, 2);
                            } else {
                                this.finishOp(26, 1);
                            }
                        }
                    },
                    {
                        key: "readToken_plus_min",
                        value: function readToken_plus_min(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === code2) {
                                this.finishOp(34, 2);
                                return;
                            }
                            if (next === 61) {
                                this.finishOp(30, 2);
                            } else {
                                this.finishOp(53, 1);
                            }
                        }
                    },
                    {
                        key: "readToken_lt",
                        value: function readToken_lt() {
                            var pos = this.state.pos;
                            var next = this.input.charCodeAt(pos + 1);
                            if (next === 60) {
                                if (this.input.charCodeAt(pos + 2) === 61) {
                                    this.finishOp(30, 3);
                                    return;
                                }
                                this.finishOp(51, 2);
                                return;
                            }
                            if (next === 61) {
                                this.finishOp(49, 2);
                                return;
                            }
                            this.finishOp(47, 1);
                        }
                    },
                    {
                        key: "readToken_gt",
                        value: function readToken_gt() {
                            var pos = this.state.pos;
                            var next = this.input.charCodeAt(pos + 1);
                            if (next === 62) {
                                var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
                                if (this.input.charCodeAt(pos + size) === 61) {
                                    this.finishOp(30, size + 1);
                                    return;
                                }
                                this.finishOp(52, size);
                                return;
                            }
                            if (next === 61) {
                                this.finishOp(49, 2);
                                return;
                            }
                            this.finishOp(48, 1);
                        }
                    },
                    {
                        key: "readToken_eq_excl",
                        value: function readToken_eq_excl(code2) {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            if (next === 61) {
                                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                                return;
                            }
                            if (code2 === 61 && next === 62) {
                                this.state.pos += 2;
                                this.finishToken(19);
                                return;
                            }
                            this.finishOp(code2 === 61 ? 29 : 35, 1);
                        }
                    },
                    {
                        key: "readToken_question",
                        value: function readToken_question() {
                            var next = this.input.charCodeAt(this.state.pos + 1);
                            var next2 = this.input.charCodeAt(this.state.pos + 2);
                            if (next === 63) {
                                if (next2 === 61) {
                                    this.finishOp(30, 3);
                                } else {
                                    this.finishOp(40, 2);
                                }
                            } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
                                this.state.pos += 2;
                                this.finishToken(18);
                            } else {
                                ++this.state.pos;
                                this.finishToken(17);
                            }
                        }
                    },
                    {
                        key: "getTokenFromCode",
                        value: function getTokenFromCode(code2) {
                            switch(code2){
                                case 46:
                                    this.readToken_dot();
                                    return;
                                case 40:
                                    ++this.state.pos;
                                    this.finishToken(10);
                                    return;
                                case 41:
                                    ++this.state.pos;
                                    this.finishToken(11);
                                    return;
                                case 59:
                                    ++this.state.pos;
                                    this.finishToken(13);
                                    return;
                                case 44:
                                    ++this.state.pos;
                                    this.finishToken(12);
                                    return;
                                case 91:
                                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                        }
                                        this.state.pos += 2;
                                        this.finishToken(2);
                                    } else {
                                        ++this.state.pos;
                                        this.finishToken(0);
                                    }
                                    return;
                                case 93:
                                    ++this.state.pos;
                                    this.finishToken(3);
                                    return;
                                case 123:
                                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                                        }
                                        this.state.pos += 2;
                                        this.finishToken(6);
                                    } else {
                                        ++this.state.pos;
                                        this.finishToken(5);
                                    }
                                    return;
                                case 125:
                                    ++this.state.pos;
                                    this.finishToken(8);
                                    return;
                                case 58:
                                    if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                                        this.finishOp(15, 2);
                                    } else {
                                        ++this.state.pos;
                                        this.finishToken(14);
                                    }
                                    return;
                                case 63:
                                    this.readToken_question();
                                    return;
                                case 96:
                                    this.readTemplateToken();
                                    return;
                                case 48:
                                    {
                                        var next = this.input.charCodeAt(this.state.pos + 1);
                                        if (next === 120 || next === 88) {
                                            this.readRadixNumber(16);
                                            return;
                                        }
                                        if (next === 111 || next === 79) {
                                            this.readRadixNumber(8);
                                            return;
                                        }
                                        if (next === 98 || next === 66) {
                                            this.readRadixNumber(2);
                                            return;
                                        }
                                    }
                                case 49:
                                case 50:
                                case 51:
                                case 52:
                                case 53:
                                case 54:
                                case 55:
                                case 56:
                                case 57:
                                    this.readNumber(false);
                                    return;
                                case 34:
                                case 39:
                                    this.readString(code2);
                                    return;
                                case 47:
                                    this.readToken_slash();
                                    return;
                                case 37:
                                case 42:
                                    this.readToken_mult_modulo(code2);
                                    return;
                                case 124:
                                case 38:
                                    this.readToken_pipe_amp(code2);
                                    return;
                                case 94:
                                    this.readToken_caret();
                                    return;
                                case 43:
                                case 45:
                                    this.readToken_plus_min(code2);
                                    return;
                                case 60:
                                    this.readToken_lt();
                                    return;
                                case 62:
                                    this.readToken_gt();
                                    return;
                                case 61:
                                case 33:
                                    this.readToken_eq_excl(code2);
                                    return;
                                case 126:
                                    this.finishOp(36, 1);
                                    return;
                                case 64:
                                    this.readToken_atSign();
                                    return;
                                case 35:
                                    this.readToken_numberSign();
                                    return;
                                case 92:
                                    this.readWord();
                                    return;
                                default:
                                    if (isIdentifierStart(code2)) {
                                        this.readWord(code2);
                                        return;
                                    }
                            }
                            throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
                                unexpected: String.fromCodePoint(code2)
                            });
                        }
                    },
                    {
                        key: "finishOp",
                        value: function finishOp(type, size) {
                            var str = this.input.slice(this.state.pos, this.state.pos + size);
                            this.state.pos += size;
                            this.finishToken(type, str);
                        }
                    },
                    {
                        key: "readRegexp",
                        value: function readRegexp() {
                            var startLoc = this.state.startLoc;
                            var start = this.state.start + 1;
                            var escaped, inClass;
                            var pos = this.state.pos;
                            for(;; ++pos){
                                if (pos >= this.length) {
                                    throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
                                }
                                var ch = this.input.charCodeAt(pos);
                                if (isNewLine(ch)) {
                                    throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
                                }
                                if (escaped) {
                                    escaped = false;
                                } else {
                                    if (ch === 91) {
                                        inClass = true;
                                    } else if (ch === 93 && inClass) {
                                        inClass = false;
                                    } else if (ch === 47 && !inClass) {
                                        break;
                                    }
                                    escaped = ch === 92;
                                }
                            }
                            var content = this.input.slice(start, pos);
                            ++pos;
                            var mods = "";
                            var nextPos = function() {
                                return createPositionWithColumnOffset(startLoc, pos + 2 - start);
                            };
                            while(pos < this.length){
                                var cp = this.codePointAtPos(pos);
                                var char = String.fromCharCode(cp);
                                if (VALID_REGEX_FLAGS.has(cp)) {
                                    if (cp === 118) {
                                        if (mods.includes("u")) {
                                            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                                        }
                                    } else if (cp === 117) {
                                        if (mods.includes("v")) {
                                            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
                                        }
                                    }
                                    if (mods.includes(char)) {
                                        this.raise(Errors.DuplicateRegExpFlags, nextPos());
                                    }
                                } else if (isIdentifierChar(cp) || cp === 92) {
                                    this.raise(Errors.MalformedRegExpFlags, nextPos());
                                } else {
                                    break;
                                }
                                ++pos;
                                mods += char;
                            }
                            this.state.pos = pos;
                            this.finishToken(137, {
                                pattern: content,
                                flags: mods
                            });
                        }
                    },
                    {
                        key: "readInt",
                        value: function readInt1(radix, len) {
                            var forceLen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, allowNumSeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                            var _readInt = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false), n = _readInt.n, pos = _readInt.pos;
                            this.state.pos = pos;
                            return n;
                        }
                    },
                    {
                        key: "readRadixNumber",
                        value: function readRadixNumber(radix) {
                            var start = this.state.pos;
                            var startLoc = this.state.curPosition();
                            var isBigInt = false;
                            this.state.pos += 2;
                            var val = this.readInt(radix);
                            if (val == null) {
                                this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
                                    radix: radix
                                });
                            }
                            var next = this.input.charCodeAt(this.state.pos);
                            if (next === 110) {
                                ++this.state.pos;
                                isBigInt = true;
                            } else if (next === 109) {
                                throw this.raise(Errors.InvalidDecimal, startLoc);
                            }
                            if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                                throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
                            }
                            if (isBigInt) {
                                var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
                                this.finishToken(135, str);
                                return;
                            }
                            this.finishToken(134, val);
                        }
                    },
                    {
                        key: "readNumber",
                        value: function readNumber(startsWithDot) {
                            var start = this.state.pos;
                            var startLoc = this.state.curPosition();
                            var isFloat = false;
                            var isBigInt = false;
                            var hasExponent = false;
                            var isOctal = false;
                            if (!startsWithDot && this.readInt(10) === null) {
                                this.raise(Errors.InvalidNumber, this.state.curPosition());
                            }
                            var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
                            if (hasLeadingZero) {
                                var integer = this.input.slice(start, this.state.pos);
                                this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
                                if (!this.state.strict) {
                                    var underscorePos = integer.indexOf("_");
                                    if (underscorePos > 0) {
                                        this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
                                    }
                                }
                                isOctal = hasLeadingZero && !/[89]/.test(integer);
                            }
                            var next = this.input.charCodeAt(this.state.pos);
                            if (next === 46 && !isOctal) {
                                ++this.state.pos;
                                this.readInt(10);
                                isFloat = true;
                                next = this.input.charCodeAt(this.state.pos);
                            }
                            if ((next === 69 || next === 101) && !isOctal) {
                                next = this.input.charCodeAt(++this.state.pos);
                                if (next === 43 || next === 45) {
                                    ++this.state.pos;
                                }
                                if (this.readInt(10) === null) {
                                    this.raise(Errors.InvalidOrMissingExponent, startLoc);
                                }
                                isFloat = true;
                                hasExponent = true;
                                next = this.input.charCodeAt(this.state.pos);
                            }
                            if (next === 110) {
                                if (isFloat || hasLeadingZero) {
                                    this.raise(Errors.InvalidBigIntLiteral, startLoc);
                                }
                                ++this.state.pos;
                                isBigInt = true;
                            }
                            if (next === 109) {
                                this.expectPlugin("decimal", this.state.curPosition());
                                if (hasExponent || hasLeadingZero) {
                                    this.raise(Errors.InvalidDecimal, startLoc);
                                }
                                ++this.state.pos;
                                var isDecimal = true;
                            }
                            if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                                throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
                            }
                            var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
                            if (isBigInt) {
                                this.finishToken(135, str);
                                return;
                            }
                            if (isDecimal) {
                                this.finishToken(136, str);
                                return;
                            }
                            var val = isOctal ? parseInt(str, 8) : parseFloat(str);
                            this.finishToken(134, val);
                        }
                    },
                    {
                        key: "readCodePoint",
                        value: function readCodePoint1(throwOnInvalid) {
                            var _readCodePoint = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint), code2 = _readCodePoint.code, pos = _readCodePoint.pos;
                            this.state.pos = pos;
                            return code2;
                        }
                    },
                    {
                        key: "readString",
                        value: function readString(quote) {
                            var _readStringContents = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string), str = _readStringContents.str, pos = _readStringContents.pos, curLine = _readStringContents.curLine, lineStart = _readStringContents.lineStart;
                            this.state.pos = pos + 1;
                            this.state.lineStart = lineStart;
                            this.state.curLine = curLine;
                            this.finishToken(133, str);
                        }
                    },
                    {
                        key: "readTemplateContinuation",
                        value: function readTemplateContinuation() {
                            if (!this.match(8)) {
                                this.unexpected(null, 8);
                            }
                            this.state.pos--;
                            this.readTemplateToken();
                        }
                    },
                    {
                        key: "readTemplateToken",
                        value: function readTemplateToken() {
                            var opening = this.input[this.state.pos];
                            var _readStringContents = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template), str = _readStringContents.str, firstInvalidLoc = _readStringContents.firstInvalidLoc, pos = _readStringContents.pos, curLine = _readStringContents.curLine, lineStart = _readStringContents.lineStart;
                            this.state.pos = pos + 1;
                            this.state.lineStart = lineStart;
                            this.state.curLine = curLine;
                            if (firstInvalidLoc) {
                                this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
                            }
                            if (this.input.codePointAt(pos) === 96) {
                                this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
                            } else {
                                this.state.pos++;
                                this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
                            }
                        }
                    },
                    {
                        key: "recordStrictModeErrors",
                        value: function recordStrictModeErrors(toParseError, at) {
                            var index = at.index;
                            if (this.state.strict && !this.state.strictErrors.has(index)) {
                                this.raise(toParseError, at);
                            } else {
                                this.state.strictErrors.set(index, [
                                    toParseError,
                                    at
                                ]);
                            }
                        }
                    },
                    {
                        key: "readWord1",
                        value: function readWord1(firstCode) {
                            this.state.containsEsc = false;
                            var word = "";
                            var start = this.state.pos;
                            var chunkStart = this.state.pos;
                            if (firstCode !== void 0) {
                                this.state.pos += firstCode <= 65535 ? 1 : 2;
                            }
                            while(this.state.pos < this.length){
                                var ch = this.codePointAtPos(this.state.pos);
                                if (isIdentifierChar(ch)) {
                                    this.state.pos += ch <= 65535 ? 1 : 2;
                                } else if (ch === 92) {
                                    this.state.containsEsc = true;
                                    word += this.input.slice(chunkStart, this.state.pos);
                                    var escStart = this.state.curPosition();
                                    var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                                    if (this.input.charCodeAt(++this.state.pos) !== 117) {
                                        this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
                                        chunkStart = this.state.pos - 1;
                                        continue;
                                    }
                                    ++this.state.pos;
                                    var esc = this.readCodePoint(true);
                                    if (esc !== null) {
                                        if (!identifierCheck(esc)) {
                                            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
                                        }
                                        word += String.fromCodePoint(esc);
                                    }
                                    chunkStart = this.state.pos;
                                } else {
                                    break;
                                }
                            }
                            return word + this.input.slice(chunkStart, this.state.pos);
                        }
                    },
                    {
                        key: "readWord",
                        value: function readWord(firstCode) {
                            var word = this.readWord1(firstCode);
                            var type = keywords$1.get(word);
                            if (type !== void 0) {
                                this.finishToken(type, tokenLabelName(type));
                            } else {
                                this.finishToken(132, word);
                            }
                        }
                    },
                    {
                        key: "checkKeywordEscapes",
                        value: function checkKeywordEscapes() {
                            var type = this.state.type;
                            if (tokenIsKeyword(type) && this.state.containsEsc) {
                                this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
                                    reservedWord: tokenLabelName(type)
                                });
                            }
                        }
                    },
                    {
                        key: "raise",
                        value: function raise(toParseError, at) {
                            var details = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                            var loc = _instanceof(at, Position) ? at : at.loc.start;
                            var error = toParseError(loc, details);
                            if (!this.options.errorRecovery) throw error;
                            if (!this.isLookahead) this.state.errors.push(error);
                            return error;
                        }
                    },
                    {
                        key: "raiseOverwrite",
                        value: function raiseOverwrite(toParseError, at) {
                            var details = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                            var loc = _instanceof(at, Position) ? at : at.loc.start;
                            var pos = loc.index;
                            var errors = this.state.errors;
                            for(var i = errors.length - 1; i >= 0; i--){
                                var error = errors[i];
                                if (error.loc.index === pos) {
                                    return errors[i] = toParseError(loc, details);
                                }
                                if (error.loc.index < pos) break;
                            }
                            return this.raise(toParseError, at, details);
                        }
                    },
                    {
                        key: "updateContext",
                        value: function updateContext(prevType) {}
                    },
                    {
                        key: "unexpected",
                        value: function unexpected(loc, type) {
                            throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
                                expected: type ? tokenLabelName(type) : null
                            });
                        }
                    },
                    {
                        key: "expectPlugin",
                        value: function expectPlugin(pluginName, loc) {
                            if (this.hasPlugin(pluginName)) {
                                return true;
                            }
                            throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
                                missingPlugin: [
                                    pluginName
                                ]
                            });
                        }
                    },
                    {
                        key: "expectOnePlugin",
                        value: function expectOnePlugin(pluginNames) {
                            var _this = this;
                            if (!pluginNames.some(function(name) {
                                return _this.hasPlugin(name);
                            })) {
                                throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
                                    missingPlugin: pluginNames
                                });
                            }
                        }
                    },
                    {
                        key: "errorBuilder",
                        value: function errorBuilder(error) {
                            var _this = this;
                            return function(pos, lineStart, curLine) {
                                _this.raise(error, buildPosition(pos, lineStart, curLine));
                            };
                        }
                    }
                ]);
                return Tokenizer;
            }(CommentsParser);
            var ClassScope = function ClassScope() {
                _class_call_check(this, ClassScope);
                this.privateNames = /* @__PURE__ */ new Set();
                this.loneAccessors = /* @__PURE__ */ new Map();
                this.undefinedPrivateNames = /* @__PURE__ */ new Map();
            };
            var ClassScopeHandler = /*#__PURE__*/ function() {
                function ClassScopeHandler(parser) {
                    _class_call_check(this, ClassScopeHandler);
                    this.parser = void 0;
                    this.stack = [];
                    this.undefinedPrivateNames = /* @__PURE__ */ new Map();
                    this.parser = parser;
                }
                _create_class(ClassScopeHandler, [
                    {
                        key: "current",
                        value: function current() {
                            return this.stack[this.stack.length - 1];
                        }
                    },
                    {
                        key: "enter",
                        value: function enter() {
                            this.stack.push(new ClassScope());
                        }
                    },
                    {
                        key: "exit",
                        value: function exit() {
                            var oldClassScope = this.stack.pop();
                            var current = this.current();
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = Array.from(oldClassScope.undefinedPrivateNames)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var _step_value = _sliced_to_array(_step.value, 2), name = _step_value[0], loc = _step_value[1];
                                    if (current) {
                                        if (!current.undefinedPrivateNames.has(name)) {
                                            current.undefinedPrivateNames.set(name, loc);
                                        }
                                    } else {
                                        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                                            identifierName: name
                                        });
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "declarePrivateName",
                        value: function declarePrivateName(name, elementType, loc) {
                            var _this_current = this.current(), privateNames = _this_current.privateNames, loneAccessors = _this_current.loneAccessors, undefinedPrivateNames = _this_current.undefinedPrivateNames;
                            var redefined = privateNames.has(name);
                            if (elementType & 3) {
                                var accessor = redefined && loneAccessors.get(name);
                                if (accessor) {
                                    var oldStatic = accessor & 4;
                                    var newStatic = elementType & 4;
                                    var oldKind = accessor & 3;
                                    var newKind = elementType & 3;
                                    redefined = oldKind === newKind || oldStatic !== newStatic;
                                    if (!redefined) loneAccessors.delete(name);
                                } else if (!redefined) {
                                    loneAccessors.set(name, elementType);
                                }
                            }
                            if (redefined) {
                                this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
                                    identifierName: name
                                });
                            }
                            privateNames.add(name);
                            undefinedPrivateNames.delete(name);
                        }
                    },
                    {
                        key: "usePrivateName",
                        value: function usePrivateName(name, loc) {
                            var classScope;
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = this.stack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    classScope = _step.value;
                                    if (classScope.privateNames.has(name)) return;
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            if (classScope) {
                                classScope.undefinedPrivateNames.set(name, loc);
                            } else {
                                this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
                                    identifierName: name
                                });
                            }
                        }
                    }
                ]);
                return ClassScopeHandler;
            }();
            var ExpressionScope = /*#__PURE__*/ function() {
                function ExpressionScope() {
                    var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                    _class_call_check(this, ExpressionScope);
                    this.type = type;
                }
                _create_class(ExpressionScope, [
                    {
                        key: "canBeArrowParameterDeclaration",
                        value: function canBeArrowParameterDeclaration() {
                            return this.type === 2 || this.type === 1;
                        }
                    },
                    {
                        key: "isCertainlyParameterDeclaration",
                        value: function isCertainlyParameterDeclaration() {
                            return this.type === 3;
                        }
                    }
                ]);
                return ExpressionScope;
            }();
            var ArrowHeadParsingScope = /*#__PURE__*/ function(ExpressionScope) {
                _inherits(ArrowHeadParsingScope, ExpressionScope);
                function ArrowHeadParsingScope(type) {
                    _class_call_check(this, ArrowHeadParsingScope);
                    var _this;
                    _this = _call_super(this, ArrowHeadParsingScope, [
                        type
                    ]);
                    _this.declarationErrors = /* @__PURE__ */ new Map();
                    return _this;
                }
                _create_class(ArrowHeadParsingScope, [
                    {
                        key: "recordDeclarationError",
                        value: function recordDeclarationError(ParsingErrorClass, at) {
                            var index = at.index;
                            this.declarationErrors.set(index, [
                                ParsingErrorClass,
                                at
                            ]);
                        }
                    },
                    {
                        key: "clearDeclarationError",
                        value: function clearDeclarationError(index) {
                            this.declarationErrors.delete(index);
                        }
                    },
                    {
                        key: "iterateErrors",
                        value: function iterateErrors(iterator) {
                            this.declarationErrors.forEach(iterator);
                        }
                    }
                ]);
                return ArrowHeadParsingScope;
            }(ExpressionScope);
            var ExpressionScopeHandler = /*#__PURE__*/ function() {
                function ExpressionScopeHandler(parser) {
                    _class_call_check(this, ExpressionScopeHandler);
                    this.parser = void 0;
                    this.stack = [
                        new ExpressionScope()
                    ];
                    this.parser = parser;
                }
                _create_class(ExpressionScopeHandler, [
                    {
                        key: "enter",
                        value: function enter(scope) {
                            this.stack.push(scope);
                        }
                    },
                    {
                        key: "exit",
                        value: function exit() {
                            this.stack.pop();
                        }
                    },
                    {
                        key: "recordParameterInitializerError",
                        value: function recordParameterInitializerError(toParseError, node) {
                            var origin = node.loc.start;
                            var stack = this.stack;
                            var i = stack.length - 1;
                            var scope = stack[i];
                            while(!scope.isCertainlyParameterDeclaration()){
                                if (scope.canBeArrowParameterDeclaration()) {
                                    scope.recordDeclarationError(toParseError, origin);
                                } else {
                                    return;
                                }
                                scope = stack[--i];
                            }
                            this.parser.raise(toParseError, origin);
                        }
                    },
                    {
                        key: "recordArrowParameterBindingError",
                        value: function recordArrowParameterBindingError(error, node) {
                            var stack = this.stack;
                            var scope = stack[stack.length - 1];
                            var origin = node.loc.start;
                            if (scope.isCertainlyParameterDeclaration()) {
                                this.parser.raise(error, origin);
                            } else if (scope.canBeArrowParameterDeclaration()) {
                                scope.recordDeclarationError(error, origin);
                            } else {
                                return;
                            }
                        }
                    },
                    {
                        key: "recordAsyncArrowParametersError",
                        value: function recordAsyncArrowParametersError(at) {
                            var stack = this.stack;
                            var i = stack.length - 1;
                            var scope = stack[i];
                            while(scope.canBeArrowParameterDeclaration()){
                                if (scope.type === 2) {
                                    scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
                                }
                                scope = stack[--i];
                            }
                        }
                    },
                    {
                        key: "validateAsPattern",
                        value: function validateAsPattern() {
                            var _this = this;
                            var stack = this.stack;
                            var currentScope = stack[stack.length - 1];
                            if (!currentScope.canBeArrowParameterDeclaration()) return;
                            currentScope.iterateErrors(function(param) {
                                var _param = _sliced_to_array(param, 2), toParseError = _param[0], loc = _param[1];
                                _this.parser.raise(toParseError, loc);
                                var i = stack.length - 2;
                                var scope = stack[i];
                                while(scope.canBeArrowParameterDeclaration()){
                                    scope.clearDeclarationError(loc.index);
                                    scope = stack[--i];
                                }
                            });
                        }
                    }
                ]);
                return ExpressionScopeHandler;
            }();
            function newParameterDeclarationScope() {
                return new ExpressionScope(3);
            }
            function newArrowHeadScope() {
                return new ArrowHeadParsingScope(1);
            }
            function newAsyncArrowScope() {
                return new ArrowHeadParsingScope(2);
            }
            function newExpressionScope() {
                return new ExpressionScope();
            }
            var ProductionParameterHandler = /*#__PURE__*/ function() {
                function ProductionParameterHandler() {
                    _class_call_check(this, ProductionParameterHandler);
                    this.stacks = [];
                }
                _create_class(ProductionParameterHandler, [
                    {
                        key: "enter",
                        value: function enter(flags) {
                            this.stacks.push(flags);
                        }
                    },
                    {
                        key: "exit",
                        value: function exit() {
                            this.stacks.pop();
                        }
                    },
                    {
                        key: "currentFlags",
                        value: function currentFlags() {
                            return this.stacks[this.stacks.length - 1];
                        }
                    },
                    {
                        key: "hasAwait",
                        get: function get() {
                            return (this.currentFlags() & 2) > 0;
                        }
                    },
                    {
                        key: "hasYield",
                        get: function get() {
                            return (this.currentFlags() & 1) > 0;
                        }
                    },
                    {
                        key: "hasReturn",
                        get: function get() {
                            return (this.currentFlags() & 4) > 0;
                        }
                    },
                    {
                        key: "hasIn",
                        get: function get() {
                            return (this.currentFlags() & 8) > 0;
                        }
                    }
                ]);
                return ProductionParameterHandler;
            }();
            function functionFlags(isAsync, isGenerator) {
                return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
            }
            var UtilParser = /*#__PURE__*/ function(Tokenizer) {
                _inherits(UtilParser, Tokenizer);
                function UtilParser() {
                    _class_call_check(this, UtilParser);
                    return _call_super(this, UtilParser, arguments);
                }
                _create_class(UtilParser, [
                    {
                        key: "addExtra",
                        value: function addExtra(node, key, value) {
                            var enumerable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                            if (!node) return;
                            var extra = node.extra;
                            if (extra == null) {
                                extra = {};
                                node.extra = extra;
                            }
                            if (enumerable) {
                                extra[key] = value;
                            } else {
                                Object.defineProperty(extra, key, {
                                    enumerable: enumerable,
                                    value: value
                                });
                            }
                        }
                    },
                    {
                        key: "isContextual",
                        value: function isContextual(token) {
                            return this.state.type === token && !this.state.containsEsc;
                        }
                    },
                    {
                        key: "isUnparsedContextual",
                        value: function isUnparsedContextual(nameStart, name) {
                            var nameEnd = nameStart + name.length;
                            if (this.input.slice(nameStart, nameEnd) === name) {
                                var nextCh = this.input.charCodeAt(nameEnd);
                                return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
                            }
                            return false;
                        }
                    },
                    {
                        key: "isLookaheadContextual",
                        value: function isLookaheadContextual(name) {
                            var next = this.nextTokenStart();
                            return this.isUnparsedContextual(next, name);
                        }
                    },
                    {
                        key: "eatContextual",
                        value: function eatContextual(token) {
                            if (this.isContextual(token)) {
                                this.next();
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "expectContextual",
                        value: function expectContextual(token, toParseError) {
                            if (!this.eatContextual(token)) {
                                if (toParseError != null) {
                                    throw this.raise(toParseError, this.state.startLoc);
                                }
                                this.unexpected(null, token);
                            }
                        }
                    },
                    {
                        key: "canInsertSemicolon",
                        value: function canInsertSemicolon() {
                            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
                        }
                    },
                    {
                        key: "hasPrecedingLineBreak",
                        value: function hasPrecedingLineBreak() {
                            return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
                        }
                    },
                    {
                        key: "hasFollowingLineBreak",
                        value: function hasFollowingLineBreak() {
                            return hasNewLine(this.input, this.state.end, this.nextTokenStart());
                        }
                    },
                    {
                        key: "isLineTerminator",
                        value: function isLineTerminator() {
                            return this.eat(13) || this.canInsertSemicolon();
                        }
                    },
                    {
                        key: "semicolon",
                        value: function semicolon() {
                            var allowAsi = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                            if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
                            this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
                        }
                    },
                    {
                        key: "expect",
                        value: function expect(type, loc) {
                            if (!this.eat(type)) {
                                this.unexpected(loc, type);
                            }
                        }
                    },
                    {
                        key: "tryParse",
                        value: function tryParse(fn) {
                            var oldState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone();
                            var abortSignal = {
                                node: null
                            };
                            try {
                                var node = fn(function() {
                                    var node2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                                    abortSignal.node = node2;
                                    throw abortSignal;
                                });
                                if (this.state.errors.length > oldState.errors.length) {
                                    var failState = this.state;
                                    this.state = oldState;
                                    this.state.tokensLength = failState.tokensLength;
                                    return {
                                        node: node,
                                        error: failState.errors[oldState.errors.length],
                                        thrown: false,
                                        aborted: false,
                                        failState: failState
                                    };
                                }
                                return {
                                    node: node,
                                    error: null,
                                    thrown: false,
                                    aborted: false,
                                    failState: null
                                };
                            } catch (error) {
                                var failState1 = this.state;
                                this.state = oldState;
                                if (_instanceof(error, SyntaxError)) {
                                    return {
                                        node: null,
                                        error: error,
                                        thrown: true,
                                        aborted: false,
                                        failState: failState1
                                    };
                                }
                                if (error === abortSignal) {
                                    return {
                                        node: abortSignal.node,
                                        error: null,
                                        thrown: false,
                                        aborted: true,
                                        failState: failState1
                                    };
                                }
                                throw error;
                            }
                        }
                    },
                    {
                        key: "checkExpressionErrors",
                        value: function checkExpressionErrors(refExpressionErrors, andThrow) {
                            if (!refExpressionErrors) return false;
                            var shorthandAssignLoc = refExpressionErrors.shorthandAssignLoc, doubleProtoLoc = refExpressionErrors.doubleProtoLoc, privateKeyLoc = refExpressionErrors.privateKeyLoc, optionalParametersLoc = refExpressionErrors.optionalParametersLoc;
                            var hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
                            if (!andThrow) {
                                return hasErrors;
                            }
                            if (shorthandAssignLoc != null) {
                                this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                            }
                            if (doubleProtoLoc != null) {
                                this.raise(Errors.DuplicateProto, doubleProtoLoc);
                            }
                            if (privateKeyLoc != null) {
                                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                            }
                            if (optionalParametersLoc != null) {
                                this.unexpected(optionalParametersLoc);
                            }
                        }
                    },
                    {
                        key: "isLiteralPropertyName",
                        value: function isLiteralPropertyName() {
                            return tokenIsLiteralPropertyName(this.state.type);
                        }
                    },
                    {
                        key: "isPrivateName",
                        value: function isPrivateName(node) {
                            return node.type === "PrivateName";
                        }
                    },
                    {
                        key: "getPrivateNameSV",
                        value: function getPrivateNameSV(node) {
                            return node.id.name;
                        }
                    },
                    {
                        key: "hasPropertyAsPrivateName",
                        value: function hasPropertyAsPrivateName(node) {
                            return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
                        }
                    },
                    {
                        key: "isObjectProperty",
                        value: function isObjectProperty(node) {
                            return node.type === "ObjectProperty";
                        }
                    },
                    {
                        key: "isObjectMethod",
                        value: function isObjectMethod(node) {
                            return node.type === "ObjectMethod";
                        }
                    },
                    {
                        key: "initializeScopes",
                        value: function initializeScopes() {
                            var _this = this;
                            var inModule = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module";
                            var oldLabels = this.state.labels;
                            this.state.labels = [];
                            var oldExportedIdentifiers = this.exportedIdentifiers;
                            this.exportedIdentifiers = /* @__PURE__ */ new Set();
                            var oldInModule = this.inModule;
                            this.inModule = inModule;
                            var oldScope = this.scope;
                            var ScopeHandler2 = this.getScopeHandler();
                            this.scope = new ScopeHandler2(this, inModule);
                            var oldProdParam = this.prodParam;
                            this.prodParam = new ProductionParameterHandler();
                            var oldClassScope = this.classScope;
                            this.classScope = new ClassScopeHandler(this);
                            var oldExpressionScope = this.expressionScope;
                            this.expressionScope = new ExpressionScopeHandler(this);
                            return function() {
                                _this.state.labels = oldLabels;
                                _this.exportedIdentifiers = oldExportedIdentifiers;
                                _this.inModule = oldInModule;
                                _this.scope = oldScope;
                                _this.prodParam = oldProdParam;
                                _this.classScope = oldClassScope;
                                _this.expressionScope = oldExpressionScope;
                            };
                        }
                    },
                    {
                        key: "enterInitialScopes",
                        value: function enterInitialScopes() {
                            var paramFlags = 0;
                            if (this.inModule) {
                                paramFlags |= 2;
                            }
                            this.scope.enter(1);
                            this.prodParam.enter(paramFlags);
                        }
                    },
                    {
                        key: "checkDestructuringPrivate",
                        value: function checkDestructuringPrivate(refExpressionErrors) {
                            var privateKeyLoc = refExpressionErrors.privateKeyLoc;
                            if (privateKeyLoc !== null) {
                                this.expectPlugin("destructuringPrivate", privateKeyLoc);
                            }
                        }
                    }
                ]);
                return UtilParser;
            }(Tokenizer);
            var ExpressionErrors = function ExpressionErrors() {
                _class_call_check(this, ExpressionErrors);
                this.shorthandAssignLoc = null;
                this.doubleProtoLoc = null;
                this.privateKeyLoc = null;
                this.optionalParametersLoc = null;
            };
            var Node = function Node(parser, pos, loc) {
                _class_call_check(this, Node);
                this.type = "";
                this.start = pos;
                this.end = 0;
                this.loc = new SourceLocation(loc);
                if (parser != null && parser.options.ranges) this.range = [
                    pos,
                    0
                ];
                if (parser != null && parser.filename) this.loc.filename = parser.filename;
            };
            var NodePrototype = Node.prototype;
            {
                NodePrototype.__clone = function() {
                    var newNode = new Node(void 0, this.start, this.loc.start);
                    var keys = Object.keys(this);
                    for(var i = 0, length = keys.length; i < length; i++){
                        var key = keys[i];
                        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
                            newNode[key] = this[key];
                        }
                    }
                    return newNode;
                };
            }
            function clonePlaceholder(node) {
                return cloneIdentifier(node);
            }
            function cloneIdentifier(node) {
                var type = node.type, start = node.start, end = node.end, loc = node.loc, range = node.range, extra = node.extra, name = node.name;
                var cloned = Object.create(NodePrototype);
                cloned.type = type;
                cloned.start = start;
                cloned.end = end;
                cloned.loc = loc;
                cloned.range = range;
                cloned.extra = extra;
                cloned.name = name;
                if (type === "Placeholder") {
                    cloned.expectedNode = node.expectedNode;
                }
                return cloned;
            }
            function cloneStringLiteral(node) {
                var type = node.type, start = node.start, end = node.end, loc = node.loc, range = node.range, extra = node.extra;
                if (type === "Placeholder") {
                    return clonePlaceholder(node);
                }
                var cloned = Object.create(NodePrototype);
                cloned.type = type;
                cloned.start = start;
                cloned.end = end;
                cloned.loc = loc;
                cloned.range = range;
                if (node.raw !== void 0) {
                    cloned.raw = node.raw;
                } else {
                    cloned.extra = extra;
                }
                cloned.value = node.value;
                return cloned;
            }
            var NodeUtils = /*#__PURE__*/ function(UtilParser) {
                _inherits(NodeUtils, UtilParser);
                function NodeUtils() {
                    _class_call_check(this, NodeUtils);
                    return _call_super(this, NodeUtils, arguments);
                }
                _create_class(NodeUtils, [
                    {
                        key: "startNode",
                        value: function startNode() {
                            var loc = this.state.startLoc;
                            return new Node(this, loc.index, loc);
                        }
                    },
                    {
                        key: "startNodeAt",
                        value: function startNodeAt(loc) {
                            return new Node(this, loc.index, loc);
                        }
                    },
                    {
                        key: "startNodeAtNode",
                        value: function startNodeAtNode(type) {
                            return this.startNodeAt(type.loc.start);
                        }
                    },
                    {
                        key: "finishNode",
                        value: function finishNode(node, type) {
                            return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
                        }
                    },
                    {
                        key: "finishNodeAt",
                        value: function finishNodeAt(node, type, endLoc) {
                            node.type = type;
                            node.end = endLoc.index;
                            node.loc.end = endLoc;
                            if (this.options.ranges) node.range[1] = endLoc.index;
                            if (this.options.attachComment) this.processComment(node);
                            return node;
                        }
                    },
                    {
                        key: "resetStartLocation",
                        value: function resetStartLocation(node, startLoc) {
                            node.start = startLoc.index;
                            node.loc.start = startLoc;
                            if (this.options.ranges) node.range[0] = startLoc.index;
                        }
                    },
                    {
                        key: "resetEndLocation",
                        value: function resetEndLocation(node) {
                            var endLoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
                            node.end = endLoc.index;
                            node.loc.end = endLoc;
                            if (this.options.ranges) node.range[1] = endLoc.index;
                        }
                    },
                    {
                        key: "resetStartLocationFromNode",
                        value: function resetStartLocationFromNode(node, locationNode) {
                            this.resetStartLocation(node, locationNode.loc.start);
                        }
                    }
                ]);
                return NodeUtils;
            }(UtilParser);
            var reservedTypes = /* @__PURE__ */ new Set([
                "_",
                "any",
                "bool",
                "boolean",
                "empty",
                "extends",
                "false",
                "interface",
                "mixed",
                "null",
                "number",
                "static",
                "string",
                "true",
                "typeof",
                "void"
            ]);
            var FlowErrors = ParseErrorEnum(_templateObject1())({
                AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
                AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
                AssignReservedType: function(param) {
                    var reservedType = param.reservedType;
                    return "Cannot overwrite reserved type ".concat(reservedType, ".");
                },
                DeclareClassElement: "The `declare` modifier can only appear on class fields.",
                DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
                DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
                EnumBooleanMemberNotInitialized: function(param) {
                    var memberName = param.memberName, enumName = param.enumName;
                    return "Boolean enum members need to be initialized. Use either `".concat(memberName, " = true,` or `").concat(memberName, " = false,` in enum `").concat(enumName, "`.");
                },
                EnumDuplicateMemberName: function(param) {
                    var memberName = param.memberName, enumName = param.enumName;
                    return "Enum member names need to be unique, but the name `".concat(memberName, "` has already been used before in enum `").concat(enumName, "`.");
                },
                EnumInconsistentMemberValues: function(param) {
                    var enumName = param.enumName;
                    return "Enum `".concat(enumName, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
                },
                EnumInvalidExplicitType: function(param) {
                    var invalidEnumType = param.invalidEnumType, enumName = param.enumName;
                    return "Enum type `".concat(invalidEnumType, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(enumName, "`.");
                },
                EnumInvalidExplicitTypeUnknownSupplied: function(param) {
                    var enumName = param.enumName;
                    return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(enumName, "`.");
                },
                EnumInvalidMemberInitializerPrimaryType: function(param) {
                    var enumName = param.enumName, memberName = param.memberName, explicitType = param.explicitType;
                    return "Enum `".concat(enumName, "` has type `").concat(explicitType, "`, so the initializer of `").concat(memberName, "` needs to be a ").concat(explicitType, " literal.");
                },
                EnumInvalidMemberInitializerSymbolType: function(param) {
                    var enumName = param.enumName, memberName = param.memberName;
                    return "Symbol enum members cannot be initialized. Use `".concat(memberName, ",` in enum `").concat(enumName, "`.");
                },
                EnumInvalidMemberInitializerUnknownType: function(param) {
                    var enumName = param.enumName, memberName = param.memberName;
                    return "The enum member initializer for `".concat(memberName, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(enumName, "`.");
                },
                EnumInvalidMemberName: function(param) {
                    var enumName = param.enumName, memberName = param.memberName, suggestion = param.suggestion;
                    return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(memberName, "`, consider using `").concat(suggestion, "`, in enum `").concat(enumName, "`.");
                },
                EnumNumberMemberNotInitialized: function(param) {
                    var enumName = param.enumName, memberName = param.memberName;
                    return "Number enum members need to be initialized, e.g. `".concat(memberName, " = 1` in enum `").concat(enumName, "`.");
                },
                EnumStringMemberInconsistentlyInitialized: function(param) {
                    var enumName = param.enumName;
                    return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(enumName, "`.");
                },
                GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
                ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
                InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
                InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
                InexactVariance: "Explicit inexact syntax cannot have variance.",
                InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
                MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
                NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
                NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
                PatternIsOptional: Object.assign({
                    message: "A binding pattern parameter cannot be optional in an implementation signature."
                }, {
                    reasonCode: "OptionalBindingPattern"
                }),
                SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
                SpreadVariance: "Spread properties cannot have variance.",
                ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
                ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
                ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
                ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
                ThisParamNoDefault: "The `this` parameter may not have a default value.",
                TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
                UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
                UnexpectedReservedType: function(param) {
                    var reservedType = param.reservedType;
                    return "Unexpected reserved type ".concat(reservedType, ".");
                },
                UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
                UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
                UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
                UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
                UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
                UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
                UnsupportedDeclareExportKind: function(param) {
                    var unsupportedExportKind = param.unsupportedExportKind, suggestion = param.suggestion;
                    return "`declare export ".concat(unsupportedExportKind, "` is not supported. Use `").concat(suggestion, "` instead.");
                },
                UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
                UnterminatedFlowComment: "Unterminated flow-comment."
            });
            function isEsModuleType(bodyElement) {
                return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
            }
            function hasTypeImportKind(node) {
                return node.importKind === "type" || node.importKind === "typeof";
            }
            var exportSuggestions = {
                const: "declare export var",
                let: "declare export var",
                type: "export type",
                interface: "export interface"
            };
            function partition(list, test) {
                var list1 = [];
                var list2 = [];
                for(var i = 0; i < list.length; i++){
                    (test(list[i], i, list) ? list1 : list2).push(list[i]);
                }
                return [
                    list1,
                    list2
                ];
            }
            var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
            var flow = function(superClass) {
                var FlowParserMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(FlowParserMixin, superClass);
                    function FlowParserMixin() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        _class_call_check(this, FlowParserMixin);
                        var _this;
                        _this = _call_super(this, FlowParserMixin, _to_consumable_array(args));
                        _this.flowPragma = void 0;
                        return _this;
                    }
                    _create_class(FlowParserMixin, [
                        {
                            key: "getScopeHandler",
                            value: function getScopeHandler() {
                                return FlowScopeHandler;
                            }
                        },
                        {
                            key: "shouldParseTypes",
                            value: function shouldParseTypes() {
                                return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
                            }
                        },
                        {
                            key: "finishToken",
                            value: function finishToken(type, val) {
                                if (type !== 133 && type !== 13 && type !== 28) {
                                    if (this.flowPragma === void 0) {
                                        this.flowPragma = null;
                                    }
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "finishToken", this).call(this, type, val);
                            }
                        },
                        {
                            key: "addComment",
                            value: function addComment(comment) {
                                if (this.flowPragma === void 0) {
                                    var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
                                    if (!matches) ;
                                    else if (matches[1] === "flow") {
                                        this.flowPragma = "flow";
                                    } else if (matches[1] === "noflow") {
                                        this.flowPragma = "noflow";
                                    } else {
                                        throw new Error("Unexpected flow pragma");
                                    }
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "addComment", this).call(this, comment);
                            }
                        },
                        {
                            key: "flowParseTypeInitialiser",
                            value: function flowParseTypeInitialiser(tok) {
                                var oldInType = this.state.inType;
                                this.state.inType = true;
                                this.expect(tok || 14);
                                var type = this.flowParseType();
                                this.state.inType = oldInType;
                                return type;
                            }
                        },
                        {
                            key: "flowParsePredicate",
                            value: function flowParsePredicate() {
                                var node = this.startNode();
                                var moduloLoc = this.state.startLoc;
                                this.next();
                                this.expectContextual(110);
                                if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
                                    this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
                                }
                                if (this.eat(10)) {
                                    node.value = _get(_get_prototype_of(FlowParserMixin.prototype), "parseExpression", this).call(this);
                                    this.expect(11);
                                    return this.finishNode(node, "DeclaredPredicate");
                                } else {
                                    return this.finishNode(node, "InferredPredicate");
                                }
                            }
                        },
                        {
                            key: "flowParseTypeAndPredicateInitialiser",
                            value: function flowParseTypeAndPredicateInitialiser() {
                                var oldInType = this.state.inType;
                                this.state.inType = true;
                                this.expect(14);
                                var type = null;
                                var predicate = null;
                                if (this.match(54)) {
                                    this.state.inType = oldInType;
                                    predicate = this.flowParsePredicate();
                                } else {
                                    type = this.flowParseType();
                                    this.state.inType = oldInType;
                                    if (this.match(54)) {
                                        predicate = this.flowParsePredicate();
                                    }
                                }
                                return [
                                    type,
                                    predicate
                                ];
                            }
                        },
                        {
                            key: "flowParseDeclareClass",
                            value: function flowParseDeclareClass(node) {
                                this.next();
                                this.flowParseInterfaceish(node, true);
                                return this.finishNode(node, "DeclareClass");
                            }
                        },
                        {
                            key: "flowParseDeclareFunction",
                            value: function flowParseDeclareFunction(node) {
                                this.next();
                                var id = node.id = this.parseIdentifier();
                                var typeNode = this.startNode();
                                var typeContainer = this.startNode();
                                if (this.match(47)) {
                                    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
                                } else {
                                    typeNode.typeParameters = null;
                                }
                                this.expect(10);
                                var tmp = this.flowParseFunctionTypeParams();
                                typeNode.params = tmp.params;
                                typeNode.rest = tmp.rest;
                                typeNode.this = tmp._this;
                                this.expect(11);
                                var ref;
                                ref = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.returnType = ref[0], node.predicate = ref[1], ref;
                                typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
                                id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
                                this.resetEndLocation(id);
                                this.semicolon();
                                this.scope.declareName(node.id.name, 2048, node.id.loc.start);
                                return this.finishNode(node, "DeclareFunction");
                            }
                        },
                        {
                            key: "flowParseDeclare",
                            value: function flowParseDeclare(node, insideModule) {
                                if (this.match(80)) {
                                    return this.flowParseDeclareClass(node);
                                } else if (this.match(68)) {
                                    return this.flowParseDeclareFunction(node);
                                } else if (this.match(74)) {
                                    return this.flowParseDeclareVariable(node);
                                } else if (this.eatContextual(127)) {
                                    if (this.match(16)) {
                                        return this.flowParseDeclareModuleExports(node);
                                    } else {
                                        if (insideModule) {
                                            this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
                                        }
                                        return this.flowParseDeclareModule(node);
                                    }
                                } else if (this.isContextual(130)) {
                                    return this.flowParseDeclareTypeAlias(node);
                                } else if (this.isContextual(131)) {
                                    return this.flowParseDeclareOpaqueType(node);
                                } else if (this.isContextual(129)) {
                                    return this.flowParseDeclareInterface(node);
                                } else if (this.match(82)) {
                                    return this.flowParseDeclareExportDeclaration(node, insideModule);
                                } else {
                                    this.unexpected();
                                }
                            }
                        },
                        {
                            key: "flowParseDeclareVariable",
                            value: function flowParseDeclareVariable(node) {
                                this.next();
                                node.id = this.flowParseTypeAnnotatableIdentifier(true);
                                this.scope.declareName(node.id.name, 5, node.id.loc.start);
                                this.semicolon();
                                return this.finishNode(node, "DeclareVariable");
                            }
                        },
                        {
                            key: "flowParseDeclareModule",
                            value: function flowParseDeclareModule(node) {
                                var _this = this;
                                this.scope.enter(0);
                                if (this.match(133)) {
                                    node.id = _get(_get_prototype_of(FlowParserMixin.prototype), "parseExprAtom", this).call(this);
                                } else {
                                    node.id = this.parseIdentifier();
                                }
                                var bodyNode = node.body = this.startNode();
                                var body = bodyNode.body = [];
                                this.expect(5);
                                while(!this.match(8)){
                                    var bodyNode2 = this.startNode();
                                    if (this.match(83)) {
                                        this.next();
                                        if (!this.isContextual(130) && !this.match(87)) {
                                            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
                                        }
                                        _get(_get_prototype_of(FlowParserMixin.prototype), "parseImport", this).call(this, bodyNode2);
                                    } else {
                                        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
                                        bodyNode2 = this.flowParseDeclare(bodyNode2, true);
                                    }
                                    body.push(bodyNode2);
                                }
                                this.scope.exit();
                                this.expect(8);
                                this.finishNode(bodyNode, "BlockStatement");
                                var kind = null;
                                var hasModuleExport = false;
                                body.forEach(function(bodyElement) {
                                    if (isEsModuleType(bodyElement)) {
                                        if (kind === "CommonJS") {
                                            _this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
                                        }
                                        kind = "ES";
                                    } else if (bodyElement.type === "DeclareModuleExports") {
                                        if (hasModuleExport) {
                                            _this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
                                        }
                                        if (kind === "ES") {
                                            _this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
                                        }
                                        kind = "CommonJS";
                                        hasModuleExport = true;
                                    }
                                });
                                node.kind = kind || "CommonJS";
                                return this.finishNode(node, "DeclareModule");
                            }
                        },
                        {
                            key: "flowParseDeclareExportDeclaration",
                            value: function flowParseDeclareExportDeclaration(node, insideModule) {
                                this.expect(82);
                                if (this.eat(65)) {
                                    if (this.match(68) || this.match(80)) {
                                        node.declaration = this.flowParseDeclare(this.startNode());
                                    } else {
                                        node.declaration = this.flowParseType();
                                        this.semicolon();
                                    }
                                    node.default = true;
                                    return this.finishNode(node, "DeclareExportDeclaration");
                                } else {
                                    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
                                        var label = this.state.value;
                                        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
                                            unsupportedExportKind: label,
                                            suggestion: exportSuggestions[label]
                                        });
                                    }
                                    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
                                        node.declaration = this.flowParseDeclare(this.startNode());
                                        node.default = false;
                                        return this.finishNode(node, "DeclareExportDeclaration");
                                    } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
                                        node = this.parseExport(node, null);
                                        if (node.type === "ExportNamedDeclaration") {
                                            node.type = "ExportDeclaration";
                                            node.default = false;
                                            delete node.exportKind;
                                        }
                                        node.type = "Declare" + node.type;
                                        return node;
                                    }
                                }
                                this.unexpected();
                            }
                        },
                        {
                            key: "flowParseDeclareModuleExports",
                            value: function flowParseDeclareModuleExports(node) {
                                this.next();
                                this.expectContextual(111);
                                node.typeAnnotation = this.flowParseTypeAnnotation();
                                this.semicolon();
                                return this.finishNode(node, "DeclareModuleExports");
                            }
                        },
                        {
                            key: "flowParseDeclareTypeAlias",
                            value: function flowParseDeclareTypeAlias(node) {
                                this.next();
                                var finished = this.flowParseTypeAlias(node);
                                finished.type = "DeclareTypeAlias";
                                return finished;
                            }
                        },
                        {
                            key: "flowParseDeclareOpaqueType",
                            value: function flowParseDeclareOpaqueType(node) {
                                this.next();
                                var finished = this.flowParseOpaqueType(node, true);
                                finished.type = "DeclareOpaqueType";
                                return finished;
                            }
                        },
                        {
                            key: "flowParseDeclareInterface",
                            value: function flowParseDeclareInterface(node) {
                                this.next();
                                this.flowParseInterfaceish(node, false);
                                return this.finishNode(node, "DeclareInterface");
                            }
                        },
                        {
                            key: "flowParseInterfaceish",
                            value: function flowParseInterfaceish(node, isClass) {
                                node.id = this.flowParseRestrictedIdentifier(!isClass, true);
                                this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                } else {
                                    node.typeParameters = null;
                                }
                                node.extends = [];
                                if (this.eat(81)) {
                                    do {
                                        node.extends.push(this.flowParseInterfaceExtends());
                                    }while (!isClass && this.eat(12));
                                }
                                if (isClass) {
                                    node.implements = [];
                                    node.mixins = [];
                                    if (this.eatContextual(117)) {
                                        do {
                                            node.mixins.push(this.flowParseInterfaceExtends());
                                        }while (this.eat(12));
                                    }
                                    if (this.eatContextual(113)) {
                                        do {
                                            node.implements.push(this.flowParseInterfaceExtends());
                                        }while (this.eat(12));
                                    }
                                }
                                node.body = this.flowParseObjectType({
                                    allowStatic: isClass,
                                    allowExact: false,
                                    allowSpread: false,
                                    allowProto: isClass,
                                    allowInexact: false
                                });
                            }
                        },
                        {
                            key: "flowParseInterfaceExtends",
                            value: function flowParseInterfaceExtends() {
                                var node = this.startNode();
                                node.id = this.flowParseQualifiedTypeIdentifier();
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterInstantiation();
                                } else {
                                    node.typeParameters = null;
                                }
                                return this.finishNode(node, "InterfaceExtends");
                            }
                        },
                        {
                            key: "flowParseInterface",
                            value: function flowParseInterface(node) {
                                this.flowParseInterfaceish(node, false);
                                return this.finishNode(node, "InterfaceDeclaration");
                            }
                        },
                        {
                            key: "checkNotUnderscore",
                            value: function checkNotUnderscore(word) {
                                if (word === "_") {
                                    this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
                                }
                            }
                        },
                        {
                            key: "checkReservedType",
                            value: function checkReservedType(word, startLoc, declaration) {
                                if (!reservedTypes.has(word)) return;
                                this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
                                    reservedType: word
                                });
                            }
                        },
                        {
                            key: "flowParseRestrictedIdentifier",
                            value: function flowParseRestrictedIdentifier(liberal, declaration) {
                                this.checkReservedType(this.state.value, this.state.startLoc, declaration);
                                return this.parseIdentifier(liberal);
                            }
                        },
                        {
                            key: "flowParseTypeAlias",
                            value: function flowParseTypeAlias(node) {
                                node.id = this.flowParseRestrictedIdentifier(false, true);
                                this.scope.declareName(node.id.name, 8201, node.id.loc.start);
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                } else {
                                    node.typeParameters = null;
                                }
                                node.right = this.flowParseTypeInitialiser(29);
                                this.semicolon();
                                return this.finishNode(node, "TypeAlias");
                            }
                        },
                        {
                            key: "flowParseOpaqueType",
                            value: function flowParseOpaqueType(node, declare) {
                                this.expectContextual(130);
                                node.id = this.flowParseRestrictedIdentifier(true, true);
                                this.scope.declareName(node.id.name, 8201, node.id.loc.start);
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                } else {
                                    node.typeParameters = null;
                                }
                                node.supertype = null;
                                if (this.match(14)) {
                                    node.supertype = this.flowParseTypeInitialiser(14);
                                }
                                node.impltype = null;
                                if (!declare) {
                                    node.impltype = this.flowParseTypeInitialiser(29);
                                }
                                this.semicolon();
                                return this.finishNode(node, "OpaqueType");
                            }
                        },
                        {
                            key: "flowParseTypeParameter",
                            value: function flowParseTypeParameter() {
                                var requireDefault = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                                var nodeStartLoc = this.state.startLoc;
                                var node = this.startNode();
                                var variance = this.flowParseVariance();
                                var ident = this.flowParseTypeAnnotatableIdentifier();
                                node.name = ident.name;
                                node.variance = variance;
                                node.bound = ident.typeAnnotation;
                                if (this.match(29)) {
                                    this.eat(29);
                                    node.default = this.flowParseType();
                                } else {
                                    if (requireDefault) {
                                        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
                                    }
                                }
                                return this.finishNode(node, "TypeParameter");
                            }
                        },
                        {
                            key: "flowParseTypeParameterDeclaration",
                            value: function flowParseTypeParameterDeclaration() {
                                var oldInType = this.state.inType;
                                var node = this.startNode();
                                node.params = [];
                                this.state.inType = true;
                                if (this.match(47) || this.match(142)) {
                                    this.next();
                                } else {
                                    this.unexpected();
                                }
                                var defaultRequired = false;
                                do {
                                    var typeParameter = this.flowParseTypeParameter(defaultRequired);
                                    node.params.push(typeParameter);
                                    if (typeParameter.default) {
                                        defaultRequired = true;
                                    }
                                    if (!this.match(48)) {
                                        this.expect(12);
                                    }
                                }while (!this.match(48));
                                this.expect(48);
                                this.state.inType = oldInType;
                                return this.finishNode(node, "TypeParameterDeclaration");
                            }
                        },
                        {
                            key: "flowParseTypeParameterInstantiation",
                            value: function flowParseTypeParameterInstantiation() {
                                var node = this.startNode();
                                var oldInType = this.state.inType;
                                node.params = [];
                                this.state.inType = true;
                                this.expect(47);
                                var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                                this.state.noAnonFunctionType = false;
                                while(!this.match(48)){
                                    node.params.push(this.flowParseType());
                                    if (!this.match(48)) {
                                        this.expect(12);
                                    }
                                }
                                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                this.expect(48);
                                this.state.inType = oldInType;
                                return this.finishNode(node, "TypeParameterInstantiation");
                            }
                        },
                        {
                            key: "flowParseTypeParameterInstantiationCallOrNew",
                            value: function flowParseTypeParameterInstantiationCallOrNew() {
                                var node = this.startNode();
                                var oldInType = this.state.inType;
                                node.params = [];
                                this.state.inType = true;
                                this.expect(47);
                                while(!this.match(48)){
                                    node.params.push(this.flowParseTypeOrImplicitInstantiation());
                                    if (!this.match(48)) {
                                        this.expect(12);
                                    }
                                }
                                this.expect(48);
                                this.state.inType = oldInType;
                                return this.finishNode(node, "TypeParameterInstantiation");
                            }
                        },
                        {
                            key: "flowParseInterfaceType",
                            value: function flowParseInterfaceType() {
                                var node = this.startNode();
                                this.expectContextual(129);
                                node.extends = [];
                                if (this.eat(81)) {
                                    do {
                                        node.extends.push(this.flowParseInterfaceExtends());
                                    }while (this.eat(12));
                                }
                                node.body = this.flowParseObjectType({
                                    allowStatic: false,
                                    allowExact: false,
                                    allowSpread: false,
                                    allowProto: false,
                                    allowInexact: false
                                });
                                return this.finishNode(node, "InterfaceTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseObjectPropertyKey",
                            value: function flowParseObjectPropertyKey() {
                                return this.match(134) || this.match(133) ? _get(_get_prototype_of(FlowParserMixin.prototype), "parseExprAtom", this).call(this) : this.parseIdentifier(true);
                            }
                        },
                        {
                            key: "flowParseObjectTypeIndexer",
                            value: function flowParseObjectTypeIndexer(node, isStatic, variance) {
                                node.static = isStatic;
                                if (this.lookahead().type === 14) {
                                    node.id = this.flowParseObjectPropertyKey();
                                    node.key = this.flowParseTypeInitialiser();
                                } else {
                                    node.id = null;
                                    node.key = this.flowParseType();
                                }
                                this.expect(3);
                                node.value = this.flowParseTypeInitialiser();
                                node.variance = variance;
                                return this.finishNode(node, "ObjectTypeIndexer");
                            }
                        },
                        {
                            key: "flowParseObjectTypeInternalSlot",
                            value: function flowParseObjectTypeInternalSlot(node, isStatic) {
                                node.static = isStatic;
                                node.id = this.flowParseObjectPropertyKey();
                                this.expect(3);
                                this.expect(3);
                                if (this.match(47) || this.match(10)) {
                                    node.method = true;
                                    node.optional = false;
                                    node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
                                } else {
                                    node.method = false;
                                    if (this.eat(17)) {
                                        node.optional = true;
                                    }
                                    node.value = this.flowParseTypeInitialiser();
                                }
                                return this.finishNode(node, "ObjectTypeInternalSlot");
                            }
                        },
                        {
                            key: "flowParseObjectTypeMethodish",
                            value: function flowParseObjectTypeMethodish(node) {
                                node.params = [];
                                node.rest = null;
                                node.typeParameters = null;
                                node.this = null;
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                }
                                this.expect(10);
                                if (this.match(78)) {
                                    node.this = this.flowParseFunctionTypeParam(true);
                                    node.this.name = null;
                                    if (!this.match(11)) {
                                        this.expect(12);
                                    }
                                }
                                while(!this.match(11) && !this.match(21)){
                                    node.params.push(this.flowParseFunctionTypeParam(false));
                                    if (!this.match(11)) {
                                        this.expect(12);
                                    }
                                }
                                if (this.eat(21)) {
                                    node.rest = this.flowParseFunctionTypeParam(false);
                                }
                                this.expect(11);
                                node.returnType = this.flowParseTypeInitialiser();
                                return this.finishNode(node, "FunctionTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseObjectTypeCallProperty",
                            value: function flowParseObjectTypeCallProperty(node, isStatic) {
                                var valueNode = this.startNode();
                                node.static = isStatic;
                                node.value = this.flowParseObjectTypeMethodish(valueNode);
                                return this.finishNode(node, "ObjectTypeCallProperty");
                            }
                        },
                        {
                            key: "flowParseObjectType",
                            value: function flowParseObjectType(param) {
                                var allowStatic = param.allowStatic, allowExact = param.allowExact, allowSpread = param.allowSpread, allowProto = param.allowProto, allowInexact = param.allowInexact;
                                var oldInType = this.state.inType;
                                this.state.inType = true;
                                var nodeStart = this.startNode();
                                nodeStart.callProperties = [];
                                nodeStart.properties = [];
                                nodeStart.indexers = [];
                                nodeStart.internalSlots = [];
                                var endDelim;
                                var exact;
                                var inexact = false;
                                if (allowExact && this.match(6)) {
                                    this.expect(6);
                                    endDelim = 9;
                                    exact = true;
                                } else {
                                    this.expect(5);
                                    endDelim = 8;
                                    exact = false;
                                }
                                nodeStart.exact = exact;
                                while(!this.match(endDelim)){
                                    var isStatic = false;
                                    var protoStartLoc = null;
                                    var inexactStartLoc = null;
                                    var node = this.startNode();
                                    if (allowProto && this.isContextual(118)) {
                                        var lookahead = this.lookahead();
                                        if (lookahead.type !== 14 && lookahead.type !== 17) {
                                            this.next();
                                            protoStartLoc = this.state.startLoc;
                                            allowStatic = false;
                                        }
                                    }
                                    if (allowStatic && this.isContextual(106)) {
                                        var lookahead1 = this.lookahead();
                                        if (lookahead1.type !== 14 && lookahead1.type !== 17) {
                                            this.next();
                                            isStatic = true;
                                        }
                                    }
                                    var variance = this.flowParseVariance();
                                    if (this.eat(0)) {
                                        if (protoStartLoc != null) {
                                            this.unexpected(protoStartLoc);
                                        }
                                        if (this.eat(0)) {
                                            if (variance) {
                                                this.unexpected(variance.loc.start);
                                            }
                                            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
                                        } else {
                                            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
                                        }
                                    } else if (this.match(10) || this.match(47)) {
                                        if (protoStartLoc != null) {
                                            this.unexpected(protoStartLoc);
                                        }
                                        if (variance) {
                                            this.unexpected(variance.loc.start);
                                        }
                                        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
                                    } else {
                                        var kind = "init";
                                        if (this.isContextual(99) || this.isContextual(104)) {
                                            var lookahead2 = this.lookahead();
                                            if (tokenIsLiteralPropertyName(lookahead2.type)) {
                                                kind = this.state.value;
                                                this.next();
                                            }
                                        }
                                        var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                                        if (propOrInexact === null) {
                                            inexact = true;
                                            inexactStartLoc = this.state.lastTokStartLoc;
                                        } else {
                                            nodeStart.properties.push(propOrInexact);
                                        }
                                    }
                                    this.flowObjectTypeSemicolon();
                                    if (inexactStartLoc && !this.match(8) && !this.match(9)) {
                                        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
                                    }
                                }
                                this.expect(endDelim);
                                if (allowSpread) {
                                    nodeStart.inexact = inexact;
                                }
                                var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
                                this.state.inType = oldInType;
                                return out;
                            }
                        },
                        {
                            key: "flowParseObjectTypeProperty",
                            value: function flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
                                if (this.eat(21)) {
                                    var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                                    if (isInexactToken) {
                                        if (!allowSpread) {
                                            this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
                                        } else if (!allowInexact) {
                                            this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
                                        }
                                        if (variance) {
                                            this.raise(FlowErrors.InexactVariance, variance);
                                        }
                                        return null;
                                    }
                                    if (!allowSpread) {
                                        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
                                    }
                                    if (protoStartLoc != null) {
                                        this.unexpected(protoStartLoc);
                                    }
                                    if (variance) {
                                        this.raise(FlowErrors.SpreadVariance, variance);
                                    }
                                    node.argument = this.flowParseType();
                                    return this.finishNode(node, "ObjectTypeSpreadProperty");
                                } else {
                                    node.key = this.flowParseObjectPropertyKey();
                                    node.static = isStatic;
                                    node.proto = protoStartLoc != null;
                                    node.kind = kind;
                                    var optional = false;
                                    if (this.match(47) || this.match(10)) {
                                        node.method = true;
                                        if (protoStartLoc != null) {
                                            this.unexpected(protoStartLoc);
                                        }
                                        if (variance) {
                                            this.unexpected(variance.loc.start);
                                        }
                                        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
                                        if (kind === "get" || kind === "set") {
                                            this.flowCheckGetterSetterParams(node);
                                        }
                                        if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                                            this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
                                        }
                                    } else {
                                        if (kind !== "init") this.unexpected();
                                        node.method = false;
                                        if (this.eat(17)) {
                                            optional = true;
                                        }
                                        node.value = this.flowParseTypeInitialiser();
                                        node.variance = variance;
                                    }
                                    node.optional = optional;
                                    return this.finishNode(node, "ObjectTypeProperty");
                                }
                            }
                        },
                        {
                            key: "flowCheckGetterSetterParams",
                            value: function flowCheckGetterSetterParams(property) {
                                var paramCount = property.kind === "get" ? 0 : 1;
                                var length = property.value.params.length + (property.value.rest ? 1 : 0);
                                if (property.value.this) {
                                    this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
                                }
                                if (length !== paramCount) {
                                    this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
                                }
                                if (property.kind === "set" && property.value.rest) {
                                    this.raise(Errors.BadSetterRestParameter, property);
                                }
                            }
                        },
                        {
                            key: "flowObjectTypeSemicolon",
                            value: function flowObjectTypeSemicolon() {
                                if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
                                    this.unexpected();
                                }
                            }
                        },
                        {
                            key: "flowParseQualifiedTypeIdentifier",
                            value: function flowParseQualifiedTypeIdentifier(startLoc, id) {
                                var _startLoc;
                                (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
                                var node = id || this.flowParseRestrictedIdentifier(true);
                                while(this.eat(16)){
                                    var node2 = this.startNodeAt(startLoc);
                                    node2.qualification = node;
                                    node2.id = this.flowParseRestrictedIdentifier(true);
                                    node = this.finishNode(node2, "QualifiedTypeIdentifier");
                                }
                                return node;
                            }
                        },
                        {
                            key: "flowParseGenericType",
                            value: function flowParseGenericType(startLoc, id) {
                                var node = this.startNodeAt(startLoc);
                                node.typeParameters = null;
                                node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterInstantiation();
                                }
                                return this.finishNode(node, "GenericTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseTypeofType",
                            value: function flowParseTypeofType() {
                                var node = this.startNode();
                                this.expect(87);
                                node.argument = this.flowParsePrimaryType();
                                return this.finishNode(node, "TypeofTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseTupleType",
                            value: function flowParseTupleType() {
                                var node = this.startNode();
                                node.types = [];
                                this.expect(0);
                                while(this.state.pos < this.length && !this.match(3)){
                                    node.types.push(this.flowParseType());
                                    if (this.match(3)) break;
                                    this.expect(12);
                                }
                                this.expect(3);
                                return this.finishNode(node, "TupleTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseFunctionTypeParam",
                            value: function flowParseFunctionTypeParam(first) {
                                var name = null;
                                var optional = false;
                                var typeAnnotation = null;
                                var node = this.startNode();
                                var lh = this.lookahead();
                                var isThis = this.state.type === 78;
                                if (lh.type === 14 || lh.type === 17) {
                                    if (isThis && !first) {
                                        this.raise(FlowErrors.ThisParamMustBeFirst, node);
                                    }
                                    name = this.parseIdentifier(isThis);
                                    if (this.eat(17)) {
                                        optional = true;
                                        if (isThis) {
                                            this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
                                        }
                                    }
                                    typeAnnotation = this.flowParseTypeInitialiser();
                                } else {
                                    typeAnnotation = this.flowParseType();
                                }
                                node.name = name;
                                node.optional = optional;
                                node.typeAnnotation = typeAnnotation;
                                return this.finishNode(node, "FunctionTypeParam");
                            }
                        },
                        {
                            key: "reinterpretTypeAsFunctionTypeParam",
                            value: function reinterpretTypeAsFunctionTypeParam(type) {
                                var node = this.startNodeAt(type.loc.start);
                                node.name = null;
                                node.optional = false;
                                node.typeAnnotation = type;
                                return this.finishNode(node, "FunctionTypeParam");
                            }
                        },
                        {
                            key: "flowParseFunctionTypeParams",
                            value: function flowParseFunctionTypeParams() {
                                var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                                var rest = null;
                                var _this = null;
                                if (this.match(78)) {
                                    _this = this.flowParseFunctionTypeParam(true);
                                    _this.name = null;
                                    if (!this.match(11)) {
                                        this.expect(12);
                                    }
                                }
                                while(!this.match(11) && !this.match(21)){
                                    params.push(this.flowParseFunctionTypeParam(false));
                                    if (!this.match(11)) {
                                        this.expect(12);
                                    }
                                }
                                if (this.eat(21)) {
                                    rest = this.flowParseFunctionTypeParam(false);
                                }
                                return {
                                    params: params,
                                    rest: rest,
                                    _this: _this
                                };
                            }
                        },
                        {
                            key: "flowIdentToTypeAnnotation",
                            value: function flowIdentToTypeAnnotation(startLoc, node, id) {
                                switch(id.name){
                                    case "any":
                                        return this.finishNode(node, "AnyTypeAnnotation");
                                    case "bool":
                                    case "boolean":
                                        return this.finishNode(node, "BooleanTypeAnnotation");
                                    case "mixed":
                                        return this.finishNode(node, "MixedTypeAnnotation");
                                    case "empty":
                                        return this.finishNode(node, "EmptyTypeAnnotation");
                                    case "number":
                                        return this.finishNode(node, "NumberTypeAnnotation");
                                    case "string":
                                        return this.finishNode(node, "StringTypeAnnotation");
                                    case "symbol":
                                        return this.finishNode(node, "SymbolTypeAnnotation");
                                    default:
                                        this.checkNotUnderscore(id.name);
                                        return this.flowParseGenericType(startLoc, id);
                                }
                            }
                        },
                        {
                            key: "flowParsePrimaryType",
                            value: function flowParsePrimaryType() {
                                var startLoc = this.state.startLoc;
                                var node = this.startNode();
                                var tmp;
                                var type;
                                var isGroupedType = false;
                                var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                                switch(this.state.type){
                                    case 5:
                                        return this.flowParseObjectType({
                                            allowStatic: false,
                                            allowExact: false,
                                            allowSpread: true,
                                            allowProto: false,
                                            allowInexact: true
                                        });
                                    case 6:
                                        return this.flowParseObjectType({
                                            allowStatic: false,
                                            allowExact: true,
                                            allowSpread: true,
                                            allowProto: false,
                                            allowInexact: false
                                        });
                                    case 0:
                                        this.state.noAnonFunctionType = false;
                                        type = this.flowParseTupleType();
                                        this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                        return type;
                                    case 47:
                                        {
                                            var node2 = this.startNode();
                                            node2.typeParameters = this.flowParseTypeParameterDeclaration();
                                            this.expect(10);
                                            tmp = this.flowParseFunctionTypeParams();
                                            node2.params = tmp.params;
                                            node2.rest = tmp.rest;
                                            node2.this = tmp._this;
                                            this.expect(11);
                                            this.expect(19);
                                            node2.returnType = this.flowParseType();
                                            return this.finishNode(node2, "FunctionTypeAnnotation");
                                        }
                                    case 10:
                                        {
                                            var node21 = this.startNode();
                                            this.next();
                                            if (!this.match(11) && !this.match(21)) {
                                                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                                    var token = this.lookahead().type;
                                                    isGroupedType = token !== 17 && token !== 14;
                                                } else {
                                                    isGroupedType = true;
                                                }
                                            }
                                            if (isGroupedType) {
                                                this.state.noAnonFunctionType = false;
                                                type = this.flowParseType();
                                                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                                                    this.expect(11);
                                                    return type;
                                                } else {
                                                    this.eat(12);
                                                }
                                            }
                                            if (type) {
                                                tmp = this.flowParseFunctionTypeParams([
                                                    this.reinterpretTypeAsFunctionTypeParam(type)
                                                ]);
                                            } else {
                                                tmp = this.flowParseFunctionTypeParams();
                                            }
                                            node21.params = tmp.params;
                                            node21.rest = tmp.rest;
                                            node21.this = tmp._this;
                                            this.expect(11);
                                            this.expect(19);
                                            node21.returnType = this.flowParseType();
                                            node21.typeParameters = null;
                                            return this.finishNode(node21, "FunctionTypeAnnotation");
                                        }
                                    case 133:
                                        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                                    case 85:
                                    case 86:
                                        node.value = this.match(85);
                                        this.next();
                                        return this.finishNode(node, "BooleanLiteralTypeAnnotation");
                                    case 53:
                                        if (this.state.value === "-") {
                                            this.next();
                                            if (this.match(134)) {
                                                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                                            }
                                            if (this.match(135)) {
                                                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                                            }
                                            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
                                        }
                                        this.unexpected();
                                        return;
                                    case 134:
                                        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                                    case 135:
                                        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                                    case 88:
                                        this.next();
                                        return this.finishNode(node, "VoidTypeAnnotation");
                                    case 84:
                                        this.next();
                                        return this.finishNode(node, "NullLiteralTypeAnnotation");
                                    case 78:
                                        this.next();
                                        return this.finishNode(node, "ThisTypeAnnotation");
                                    case 55:
                                        this.next();
                                        return this.finishNode(node, "ExistsTypeAnnotation");
                                    case 87:
                                        return this.flowParseTypeofType();
                                    default:
                                        if (tokenIsKeyword(this.state.type)) {
                                            var label = tokenLabelName(this.state.type);
                                            this.next();
                                            return _get(_get_prototype_of(FlowParserMixin.prototype), "createIdentifier", this).call(this, node, label);
                                        } else if (tokenIsIdentifier(this.state.type)) {
                                            if (this.isContextual(129)) {
                                                return this.flowParseInterfaceType();
                                            }
                                            return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
                                        }
                                }
                                this.unexpected();
                            }
                        },
                        {
                            key: "flowParsePostfixType",
                            value: function flowParsePostfixType() {
                                var startLoc = this.state.startLoc;
                                var type = this.flowParsePrimaryType();
                                var seenOptionalIndexedAccess = false;
                                while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                                    var node = this.startNodeAt(startLoc);
                                    var optional = this.eat(18);
                                    seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
                                    this.expect(0);
                                    if (!optional && this.match(3)) {
                                        node.elementType = type;
                                        this.next();
                                        type = this.finishNode(node, "ArrayTypeAnnotation");
                                    } else {
                                        node.objectType = type;
                                        node.indexType = this.flowParseType();
                                        this.expect(3);
                                        if (seenOptionalIndexedAccess) {
                                            node.optional = optional;
                                            type = this.finishNode(node, "OptionalIndexedAccessType");
                                        } else {
                                            type = this.finishNode(node, "IndexedAccessType");
                                        }
                                    }
                                }
                                return type;
                            }
                        },
                        {
                            key: "flowParsePrefixType",
                            value: function flowParsePrefixType() {
                                var node = this.startNode();
                                if (this.eat(17)) {
                                    node.typeAnnotation = this.flowParsePrefixType();
                                    return this.finishNode(node, "NullableTypeAnnotation");
                                } else {
                                    return this.flowParsePostfixType();
                                }
                            }
                        },
                        {
                            key: "flowParseAnonFunctionWithoutParens",
                            value: function flowParseAnonFunctionWithoutParens() {
                                var param = this.flowParsePrefixType();
                                if (!this.state.noAnonFunctionType && this.eat(19)) {
                                    var node = this.startNodeAt(param.loc.start);
                                    node.params = [
                                        this.reinterpretTypeAsFunctionTypeParam(param)
                                    ];
                                    node.rest = null;
                                    node.this = null;
                                    node.returnType = this.flowParseType();
                                    node.typeParameters = null;
                                    return this.finishNode(node, "FunctionTypeAnnotation");
                                }
                                return param;
                            }
                        },
                        {
                            key: "flowParseIntersectionType",
                            value: function flowParseIntersectionType() {
                                var node = this.startNode();
                                this.eat(45);
                                var type = this.flowParseAnonFunctionWithoutParens();
                                node.types = [
                                    type
                                ];
                                while(this.eat(45)){
                                    node.types.push(this.flowParseAnonFunctionWithoutParens());
                                }
                                return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseUnionType",
                            value: function flowParseUnionType() {
                                var node = this.startNode();
                                this.eat(43);
                                var type = this.flowParseIntersectionType();
                                node.types = [
                                    type
                                ];
                                while(this.eat(43)){
                                    node.types.push(this.flowParseIntersectionType());
                                }
                                return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseType",
                            value: function flowParseType() {
                                var oldInType = this.state.inType;
                                this.state.inType = true;
                                var type = this.flowParseUnionType();
                                this.state.inType = oldInType;
                                return type;
                            }
                        },
                        {
                            key: "flowParseTypeOrImplicitInstantiation",
                            value: function flowParseTypeOrImplicitInstantiation() {
                                if (this.state.type === 132 && this.state.value === "_") {
                                    var startLoc = this.state.startLoc;
                                    var node = this.parseIdentifier();
                                    return this.flowParseGenericType(startLoc, node);
                                } else {
                                    return this.flowParseType();
                                }
                            }
                        },
                        {
                            key: "flowParseTypeAnnotation",
                            value: function flowParseTypeAnnotation() {
                                var node = this.startNode();
                                node.typeAnnotation = this.flowParseTypeInitialiser();
                                return this.finishNode(node, "TypeAnnotation");
                            }
                        },
                        {
                            key: "flowParseTypeAnnotatableIdentifier",
                            value: function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
                                var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                                if (this.match(14)) {
                                    ident.typeAnnotation = this.flowParseTypeAnnotation();
                                    this.resetEndLocation(ident);
                                }
                                return ident;
                            }
                        },
                        {
                            key: "typeCastToParameter",
                            value: function typeCastToParameter(node) {
                                node.expression.typeAnnotation = node.typeAnnotation;
                                this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
                                return node.expression;
                            }
                        },
                        {
                            key: "flowParseVariance",
                            value: function flowParseVariance() {
                                var variance = null;
                                if (this.match(53)) {
                                    variance = this.startNode();
                                    if (this.state.value === "+") {
                                        variance.kind = "plus";
                                    } else {
                                        variance.kind = "minus";
                                    }
                                    this.next();
                                    return this.finishNode(variance, "Variance");
                                }
                                return variance;
                            }
                        },
                        {
                            key: "parseFunctionBody",
                            value: function parseFunctionBody(node, allowExpressionBody) {
                                var _this = this;
                                var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                                if (allowExpressionBody) {
                                    this.forwardNoArrowParamsConversionAt(node, function() {
                                        return _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBody", _this).call(_this, node, true, isMethod);
                                    });
                                    return;
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBody", this).call(this, node, false, isMethod);
                            }
                        },
                        {
                            key: "parseFunctionBodyAndFinish",
                            value: function parseFunctionBodyAndFinish(node, type) {
                                var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                                if (this.match(14)) {
                                    var typeNode = this.startNode();
                                    var ref;
                                    ref = _sliced_to_array(this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref[0], node.predicate = ref[1], ref;
                                    node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
                            }
                        },
                        {
                            key: "parseStatementLike",
                            value: function parseStatementLike(flags) {
                                if (this.state.strict && this.isContextual(129)) {
                                    var lookahead = this.lookahead();
                                    if (tokenIsKeywordOrIdentifier(lookahead.type)) {
                                        var node = this.startNode();
                                        this.next();
                                        return this.flowParseInterface(node);
                                    }
                                } else if (this.isContextual(126)) {
                                    var node1 = this.startNode();
                                    this.next();
                                    return this.flowParseEnumDeclaration(node1);
                                }
                                var stmt = _get(_get_prototype_of(FlowParserMixin.prototype), "parseStatementLike", this).call(this, flags);
                                if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
                                    this.flowPragma = null;
                                }
                                return stmt;
                            }
                        },
                        {
                            key: "parseExpressionStatement",
                            value: function parseExpressionStatement(node, expr, decorators) {
                                if (expr.type === "Identifier") {
                                    if (expr.name === "declare") {
                                        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                                            return this.flowParseDeclare(node);
                                        }
                                    } else if (tokenIsIdentifier(this.state.type)) {
                                        if (expr.name === "interface") {
                                            return this.flowParseInterface(node);
                                        } else if (expr.name === "type") {
                                            return this.flowParseTypeAlias(node);
                                        } else if (expr.name === "opaque") {
                                            return this.flowParseOpaqueType(node, false);
                                        }
                                    }
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr, decorators);
                            }
                        },
                        {
                            key: "shouldParseExportDeclaration",
                            value: function shouldParseExportDeclaration() {
                                var type = this.state.type;
                                if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
                                    return !this.state.containsEsc;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
                            }
                        },
                        {
                            key: "isExportDefaultSpecifier",
                            value: function isExportDefaultSpecifier() {
                                var type = this.state.type;
                                if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
                                    return this.state.containsEsc;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                            }
                        },
                        {
                            key: "parseExportDefaultExpression",
                            value: function parseExportDefaultExpression() {
                                if (this.isContextual(126)) {
                                    var node = this.startNode();
                                    this.next();
                                    return this.flowParseEnumDeclaration(node);
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
                            }
                        },
                        {
                            key: "parseConditional",
                            value: function parseConditional(expr, startLoc, refExpressionErrors) {
                                var _this = this;
                                if (!this.match(17)) return expr;
                                if (this.state.maybeInArrowParameters) {
                                    var nextCh = this.lookaheadCharCode();
                                    if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
                                        this.setOptionalParametersError(refExpressionErrors);
                                        return expr;
                                    }
                                }
                                this.expect(17);
                                var state = this.state.clone();
                                var originalNoArrowAt = this.state.noArrowAt;
                                var node = this.startNodeAt(startLoc);
                                var _this_tryParseConditionalConsequent = this.tryParseConditionalConsequent(), consequent = _this_tryParseConditionalConsequent.consequent, failed = _this_tryParseConditionalConsequent.failed;
                                var _this_getArrowLikeExpressions = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid = _this_getArrowLikeExpressions[0], invalid = _this_getArrowLikeExpressions[1];
                                if (failed || invalid.length > 0) {
                                    var noArrowAt = _to_consumable_array(originalNoArrowAt);
                                    if (invalid.length > 0) {
                                        this.state = state;
                                        this.state.noArrowAt = noArrowAt;
                                        for(var i = 0; i < invalid.length; i++){
                                            noArrowAt.push(invalid[i].start);
                                        }
                                        var ref;
                                        ref = this.tryParseConditionalConsequent(), consequent = ref.consequent, failed = ref.failed, ref;
                                        var ref1;
                                        ref1 = _sliced_to_array(this.getArrowLikeExpressions(consequent), 2), valid = ref1[0], invalid = ref1[1], ref1;
                                    }
                                    if (failed && valid.length > 1) {
                                        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
                                    }
                                    if (failed && valid.length === 1) {
                                        this.state = state;
                                        noArrowAt.push(valid[0].start);
                                        this.state.noArrowAt = noArrowAt;
                                        var ref2;
                                        ref2 = this.tryParseConditionalConsequent(), consequent = ref2.consequent, failed = ref2.failed, ref2;
                                    }
                                }
                                this.getArrowLikeExpressions(consequent, true);
                                this.state.noArrowAt = originalNoArrowAt;
                                this.expect(14);
                                node.test = expr;
                                node.consequent = consequent;
                                node.alternate = this.forwardNoArrowParamsConversionAt(node, function() {
                                    return _this.parseMaybeAssign(void 0, void 0);
                                });
                                return this.finishNode(node, "ConditionalExpression");
                            }
                        },
                        {
                            key: "tryParseConditionalConsequent",
                            value: function tryParseConditionalConsequent() {
                                this.state.noArrowParamsConversionAt.push(this.state.start);
                                var consequent = this.parseMaybeAssignAllowIn();
                                var failed = !this.match(14);
                                this.state.noArrowParamsConversionAt.pop();
                                return {
                                    consequent: consequent,
                                    failed: failed
                                };
                            }
                        },
                        {
                            key: "getArrowLikeExpressions",
                            value: function getArrowLikeExpressions(node, disallowInvalid) {
                                var _this = this;
                                var stack = [
                                    node
                                ];
                                var arrows = [];
                                while(stack.length !== 0){
                                    var node2 = stack.pop();
                                    if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
                                        if (node2.typeParameters || !node2.returnType) {
                                            this.finishArrowValidation(node2);
                                        } else {
                                            arrows.push(node2);
                                        }
                                        stack.push(node2.body);
                                    } else if (node2.type === "ConditionalExpression") {
                                        stack.push(node2.consequent);
                                        stack.push(node2.alternate);
                                    }
                                }
                                if (disallowInvalid) {
                                    arrows.forEach(function(node2) {
                                        return _this.finishArrowValidation(node2);
                                    });
                                    return [
                                        arrows,
                                        []
                                    ];
                                }
                                return partition(arrows, function(node2) {
                                    return node2.params.every(function(param) {
                                        return _this.isAssignable(param, true);
                                    });
                                });
                            }
                        },
                        {
                            key: "finishArrowValidation",
                            value: function finishArrowValidation(node) {
                                var _node$extra;
                                this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
                                this.scope.enter(2 | 4);
                                _get(_get_prototype_of(FlowParserMixin.prototype), "checkParams", this).call(this, node, false, true);
                                this.scope.exit();
                            }
                        },
                        {
                            key: "forwardNoArrowParamsConversionAt",
                            value: function forwardNoArrowParamsConversionAt(node, parse2) {
                                var result;
                                if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                    this.state.noArrowParamsConversionAt.push(this.state.start);
                                    result = parse2();
                                    this.state.noArrowParamsConversionAt.pop();
                                } else {
                                    result = parse2();
                                }
                                return result;
                            }
                        },
                        {
                            key: "parseParenItem",
                            value: function parseParenItem(node, startLoc) {
                                var newNode = _get(_get_prototype_of(FlowParserMixin.prototype), "parseParenItem", this).call(this, node, startLoc);
                                if (this.eat(17)) {
                                    newNode.optional = true;
                                    this.resetEndLocation(node);
                                }
                                if (this.match(14)) {
                                    var typeCastNode = this.startNodeAt(startLoc);
                                    typeCastNode.expression = newNode;
                                    typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
                                    return this.finishNode(typeCastNode, "TypeCastExpression");
                                }
                                return newNode;
                            }
                        },
                        {
                            key: "assertModuleNodeAllowed",
                            value: function assertModuleNodeAllowed(node) {
                                if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
                                    return;
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "assertModuleNodeAllowed", this).call(this, node);
                            }
                        },
                        {
                            key: "parseExportDeclaration",
                            value: function parseExportDeclaration(node) {
                                if (this.isContextual(130)) {
                                    node.exportKind = "type";
                                    var declarationNode = this.startNode();
                                    this.next();
                                    if (this.match(5)) {
                                        node.specifiers = this.parseExportSpecifiers(true);
                                        _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportFrom", this).call(this, node);
                                        return null;
                                    } else {
                                        return this.flowParseTypeAlias(declarationNode);
                                    }
                                } else if (this.isContextual(131)) {
                                    node.exportKind = "type";
                                    var declarationNode1 = this.startNode();
                                    this.next();
                                    return this.flowParseOpaqueType(declarationNode1, false);
                                } else if (this.isContextual(129)) {
                                    node.exportKind = "type";
                                    var declarationNode2 = this.startNode();
                                    this.next();
                                    return this.flowParseInterface(declarationNode2);
                                } else if (this.isContextual(126)) {
                                    node.exportKind = "value";
                                    var declarationNode3 = this.startNode();
                                    this.next();
                                    return this.flowParseEnumDeclaration(declarationNode3);
                                } else {
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "parseExportDeclaration", this).call(this, node);
                                }
                            }
                        },
                        {
                            key: "eatExportStar",
                            value: function eatExportStar(node) {
                                if (_get(_get_prototype_of(FlowParserMixin.prototype), "eatExportStar", this).call(this, node)) return true;
                                if (this.isContextual(130) && this.lookahead().type === 55) {
                                    node.exportKind = "type";
                                    this.next();
                                    this.next();
                                    return true;
                                }
                                return false;
                            }
                        },
                        {
                            key: "maybeParseExportNamespaceSpecifier",
                            value: function maybeParseExportNamespaceSpecifier(node) {
                                var startLoc = this.state.startLoc;
                                var hasNamespace = _get(_get_prototype_of(FlowParserMixin.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, node);
                                if (hasNamespace && node.exportKind === "type") {
                                    this.unexpected(startLoc);
                                }
                                return hasNamespace;
                            }
                        },
                        {
                            key: "parseClassId",
                            value: function parseClassId(node, isStatement, optionalId) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId);
                                if (this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                }
                            }
                        },
                        {
                            key: "parseClassMember",
                            value: function parseClassMember(classBody, member, state) {
                                var startLoc = this.state.startLoc;
                                if (this.isContextual(125)) {
                                    if (_get(_get_prototype_of(FlowParserMixin.prototype), "parseClassMemberFromModifier", this).call(this, classBody, member)) {
                                        return;
                                    }
                                    member.declare = true;
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassMember", this).call(this, classBody, member, state);
                                if (member.declare) {
                                    if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
                                        this.raise(FlowErrors.DeclareClassElement, startLoc);
                                    } else if (member.value) {
                                        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
                                    }
                                }
                            }
                        },
                        {
                            key: "isIterator",
                            value: function isIterator(word) {
                                return word === "iterator" || word === "asyncIterator";
                            }
                        },
                        {
                            key: "readIterator",
                            value: function readIterator() {
                                var word = _get(_get_prototype_of(FlowParserMixin.prototype), "readWord1", this).call(this);
                                var fullWord = "@@" + word;
                                if (!this.isIterator(word) || !this.state.inType) {
                                    this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
                                        identifierName: fullWord
                                    });
                                }
                                this.finishToken(132, fullWord);
                            }
                        },
                        {
                            key: "getTokenFromCode",
                            value: function getTokenFromCode(code2) {
                                var next = this.input.charCodeAt(this.state.pos + 1);
                                if (code2 === 123 && next === 124) {
                                    this.finishOp(6, 2);
                                } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
                                    this.finishOp(code2 === 62 ? 48 : 47, 1);
                                } else if (this.state.inType && code2 === 63) {
                                    if (next === 46) {
                                        this.finishOp(18, 2);
                                    } else {
                                        this.finishOp(17, 1);
                                    }
                                } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
                                    this.state.pos += 2;
                                    this.readIterator();
                                } else {
                                    _get(_get_prototype_of(FlowParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                                }
                            }
                        },
                        {
                            key: "isAssignable",
                            value: function isAssignable(node, isBinding) {
                                if (node.type === "TypeCastExpression") {
                                    return this.isAssignable(node.expression, isBinding);
                                } else {
                                    return _get(_get_prototype_of(FlowParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                                }
                            }
                        },
                        {
                            key: "toAssignable",
                            value: function toAssignable(node) {
                                var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                                if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
                                    node.left = this.typeCastToParameter(node.left);
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                            }
                        },
                        {
                            key: "toAssignableList",
                            value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                                for(var i = 0; i < exprList.length; i++){
                                    var expr = exprList[i];
                                    if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
                                        exprList[i] = this.typeCastToParameter(expr);
                                    }
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
                            }
                        },
                        {
                            key: "toReferencedList",
                            value: function toReferencedList(exprList, isParenthesizedExpr) {
                                for(var i = 0; i < exprList.length; i++){
                                    var _expr$extra;
                                    var expr = exprList[i];
                                    if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
                                        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
                                    }
                                }
                                return exprList;
                            }
                        },
                        {
                            key: "parseArrayLike",
                            value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                                var node = _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
                                if (canBePattern && !this.state.maybeInArrowParameters) {
                                    this.toReferencedList(node.elements);
                                }
                                return node;
                            }
                        },
                        {
                            key: "isValidLVal",
                            value: function isValidLVal(type, isParenthesized, binding) {
                                return type === "TypeCastExpression" || _get(_get_prototype_of(FlowParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
                            }
                        },
                        {
                            key: "parseClassProperty",
                            value: function parseClassProperty(node) {
                                if (this.match(14)) {
                                    node.typeAnnotation = this.flowParseTypeAnnotation();
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassProperty", this).call(this, node);
                            }
                        },
                        {
                            key: "parseClassPrivateProperty",
                            value: function parseClassPrivateProperty(node) {
                                if (this.match(14)) {
                                    node.typeAnnotation = this.flowParseTypeAnnotation();
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
                            }
                        },
                        {
                            key: "isClassMethod",
                            value: function isClassMethod() {
                                return this.match(47) || _get(_get_prototype_of(FlowParserMixin.prototype), "isClassMethod", this).call(this);
                            }
                        },
                        {
                            key: "isClassProperty",
                            value: function isClassProperty() {
                                return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "isClassProperty", this).call(this);
                            }
                        },
                        {
                            key: "isNonstaticConstructor",
                            value: function isNonstaticConstructor(method) {
                                return !this.match(14) && _get(_get_prototype_of(FlowParserMixin.prototype), "isNonstaticConstructor", this).call(this, method);
                            }
                        },
                        {
                            key: "pushClassMethod",
                            value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                                if (method.variance) {
                                    this.unexpected(method.variance.loc.start);
                                }
                                delete method.variance;
                                if (this.match(47)) {
                                    method.typeParameters = this.flowParseTypeParameterDeclaration();
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
                                if (method.params && isConstructor) {
                                    var params = method.params;
                                    if (params.length > 0 && this.isThisParam(params[0])) {
                                        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
                                    }
                                } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
                                    var params1 = method.value.params;
                                    if (params1.length > 0 && this.isThisParam(params1[0])) {
                                        this.raise(FlowErrors.ThisParamBannedInConstructor, method);
                                    }
                                }
                            }
                        },
                        {
                            key: "pushClassPrivateMethod",
                            value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                                if (method.variance) {
                                    this.unexpected(method.variance.loc.start);
                                }
                                delete method.variance;
                                if (this.match(47)) {
                                    method.typeParameters = this.flowParseTypeParameterDeclaration();
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
                            }
                        },
                        {
                            key: "parseClassSuper",
                            value: function parseClassSuper(node) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseClassSuper", this).call(this, node);
                                if (node.superClass && this.match(47)) {
                                    node.superTypeParameters = this.flowParseTypeParameterInstantiation();
                                }
                                if (this.isContextual(113)) {
                                    this.next();
                                    var implemented = node.implements = [];
                                    do {
                                        var node2 = this.startNode();
                                        node2.id = this.flowParseRestrictedIdentifier(true);
                                        if (this.match(47)) {
                                            node2.typeParameters = this.flowParseTypeParameterInstantiation();
                                        } else {
                                            node2.typeParameters = null;
                                        }
                                        implemented.push(this.finishNode(node2, "ClassImplements"));
                                    }while (this.eat(12));
                                }
                            }
                        },
                        {
                            key: "checkGetterSetterParams",
                            value: function checkGetterSetterParams(method) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "checkGetterSetterParams", this).call(this, method);
                                var params = this.getObjectOrClassMethodParams(method);
                                if (params.length > 0) {
                                    var param = params[0];
                                    if (this.isThisParam(param) && method.kind === "get") {
                                        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
                                    } else if (this.isThisParam(param)) {
                                        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
                                    }
                                }
                            }
                        },
                        {
                            key: "parsePropertyNamePrefixOperator",
                            value: function parsePropertyNamePrefixOperator(node) {
                                node.variance = this.flowParseVariance();
                            }
                        },
                        {
                            key: "parseObjPropValue",
                            value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                                if (prop.variance) {
                                    this.unexpected(prop.variance.loc.start);
                                }
                                delete prop.variance;
                                var typeParameters;
                                if (this.match(47) && !isAccessor) {
                                    typeParameters = this.flowParseTypeParameterDeclaration();
                                    if (!this.match(10)) this.unexpected();
                                }
                                var result = _get(_get_prototype_of(FlowParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
                                if (typeParameters) {
                                    (result.value || result).typeParameters = typeParameters;
                                }
                                return result;
                            }
                        },
                        {
                            key: "parseFunctionParamType",
                            value: function parseFunctionParamType(param) {
                                if (this.eat(17)) {
                                    if (param.type !== "Identifier") {
                                        this.raise(FlowErrors.PatternIsOptional, param);
                                    }
                                    if (this.isThisParam(param)) {
                                        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
                                    }
                                    param.optional = true;
                                }
                                if (this.match(14)) {
                                    param.typeAnnotation = this.flowParseTypeAnnotation();
                                } else if (this.isThisParam(param)) {
                                    this.raise(FlowErrors.ThisParamAnnotationRequired, param);
                                }
                                if (this.match(29) && this.isThisParam(param)) {
                                    this.raise(FlowErrors.ThisParamNoDefault, param);
                                }
                                this.resetEndLocation(param);
                                return param;
                            }
                        },
                        {
                            key: "parseMaybeDefault",
                            value: function parseMaybeDefault(startLoc, left) {
                                var node = _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
                                if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
                                    this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
                                }
                                return node;
                            }
                        },
                        {
                            key: "checkImportReflection",
                            value: function checkImportReflection(node) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "checkImportReflection", this).call(this, node);
                                if (node.module && node.importKind !== "value") {
                                    this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
                                }
                            }
                        },
                        {
                            key: "parseImportSpecifierLocal",
                            value: function parseImportSpecifierLocal(node, specifier, type) {
                                specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
                                node.specifiers.push(this.finishImportSpecifier(specifier, type));
                            }
                        },
                        {
                            key: "isPotentialImportPhase",
                            value: function isPotentialImportPhase(isExport) {
                                if (_get(_get_prototype_of(FlowParserMixin.prototype), "isPotentialImportPhase", this).call(this, isExport)) return true;
                                if (this.isContextual(130)) {
                                    if (!isExport) return true;
                                    var ch = this.lookaheadCharCode();
                                    return ch === 123 || ch === 42;
                                }
                                return !isExport && this.isContextual(87);
                            }
                        },
                        {
                            key: "applyImportPhase",
                            value: function applyImportPhase(node, isExport, phase, loc) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "applyImportPhase", this).call(this, node, isExport, phase, loc);
                                if (isExport) {
                                    if (!phase && this.match(65)) {
                                        return;
                                    }
                                    node.exportKind = phase === "type" ? phase : "value";
                                } else {
                                    if (phase === "type" && this.match(55)) this.unexpected();
                                    node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
                                }
                            }
                        },
                        {
                            key: "parseImportSpecifier",
                            value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                                var firstIdent = specifier.imported;
                                var specifierTypeKind = null;
                                if (firstIdent.type === "Identifier") {
                                    if (firstIdent.name === "type") {
                                        specifierTypeKind = "type";
                                    } else if (firstIdent.name === "typeof") {
                                        specifierTypeKind = "typeof";
                                    }
                                }
                                var isBinding = false;
                                if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                                    var as_ident = this.parseIdentifier(true);
                                    if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                                        specifier.imported = as_ident;
                                        specifier.importKind = specifierTypeKind;
                                        specifier.local = cloneIdentifier(as_ident);
                                    } else {
                                        specifier.imported = firstIdent;
                                        specifier.importKind = null;
                                        specifier.local = this.parseIdentifier();
                                    }
                                } else {
                                    if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                                        specifier.imported = this.parseIdentifier(true);
                                        specifier.importKind = specifierTypeKind;
                                    } else {
                                        if (importedIsString) {
                                            throw this.raise(Errors.ImportBindingIsString, specifier, {
                                                importName: firstIdent.value
                                            });
                                        }
                                        specifier.imported = firstIdent;
                                        specifier.importKind = null;
                                    }
                                    if (this.eatContextual(93)) {
                                        specifier.local = this.parseIdentifier();
                                    } else {
                                        isBinding = true;
                                        specifier.local = cloneIdentifier(specifier.imported);
                                    }
                                }
                                var specifierIsTypeImport = hasTypeImportKind(specifier);
                                if (isInTypeOnlyImport && specifierIsTypeImport) {
                                    this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
                                }
                                if (isInTypeOnlyImport || specifierIsTypeImport) {
                                    this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
                                }
                                if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
                                    this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
                                }
                                return this.finishImportSpecifier(specifier, "ImportSpecifier");
                            }
                        },
                        {
                            key: "parseBindingAtom",
                            value: function parseBindingAtom() {
                                switch(this.state.type){
                                    case 78:
                                        return this.parseIdentifier(true);
                                    default:
                                        return _get(_get_prototype_of(FlowParserMixin.prototype), "parseBindingAtom", this).call(this);
                                }
                            }
                        },
                        {
                            key: "parseFunctionParams",
                            value: function parseFunctionParams(node, isConstructor) {
                                var kind = node.kind;
                                if (kind !== "get" && kind !== "set" && this.match(47)) {
                                    node.typeParameters = this.flowParseTypeParameterDeclaration();
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseFunctionParams", this).call(this, node, isConstructor);
                            }
                        },
                        {
                            key: "parseVarId",
                            value: function parseVarId(decl, kind) {
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseVarId", this).call(this, decl, kind);
                                if (this.match(14)) {
                                    decl.id.typeAnnotation = this.flowParseTypeAnnotation();
                                    this.resetEndLocation(decl.id);
                                }
                            }
                        },
                        {
                            key: "parseAsyncArrowFromCallExpression",
                            value: function parseAsyncArrowFromCallExpression(node, call) {
                                if (this.match(14)) {
                                    var oldNoAnonFunctionType = this.state.noAnonFunctionType;
                                    this.state.noAnonFunctionType = true;
                                    node.returnType = this.flowParseTypeAnnotation();
                                    this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
                            }
                        },
                        {
                            key: "shouldParseAsyncArrow",
                            value: function shouldParseAsyncArrow() {
                                return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
                            }
                        },
                        {
                            key: "parseMaybeAssign",
                            value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                                var _this = this;
                                var _jsx;
                                var state = null;
                                var jsx2;
                                if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
                                    state = this.state.clone();
                                    jsx2 = this.tryParse(function() {
                                        return _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                    }, state);
                                    if (!jsx2.error) return jsx2.node;
                                    var context = this.state.context;
                                    var currentContext = context[context.length - 1];
                                    if (currentContext === types.j_oTag || currentContext === types.j_expr) {
                                        context.pop();
                                    }
                                }
                                if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
                                    var _jsx2, _jsx3;
                                    state = state || this.state.clone();
                                    var typeParameters;
                                    var arrow = this.tryParse(function(abort) {
                                        var _arrowExpression$extr;
                                        typeParameters = _this.flowParseTypeParameterDeclaration();
                                        var arrowExpression2 = _this.forwardNoArrowParamsConversionAt(typeParameters, function() {
                                            var result = _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                            _this.resetStartLocationFromNode(result, typeParameters);
                                            return result;
                                        });
                                        if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
                                        var expr = _this.maybeUnwrapTypeCastExpression(arrowExpression2);
                                        if (expr.type !== "ArrowFunctionExpression") abort();
                                        expr.typeParameters = typeParameters;
                                        _this.resetStartLocationFromNode(expr, typeParameters);
                                        return arrowExpression2;
                                    }, state);
                                    var arrowExpression = null;
                                    if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                                        if (!arrow.error && !arrow.aborted) {
                                            if (arrow.node.async) {
                                                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
                                            }
                                            return arrow.node;
                                        }
                                        arrowExpression = arrow.node;
                                    }
                                    if ((_jsx2 = jsx2) != null && _jsx2.node) {
                                        this.state = jsx2.failState;
                                        return jsx2.node;
                                    }
                                    if (arrowExpression) {
                                        this.state = arrow.failState;
                                        return arrowExpression;
                                    }
                                    if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
                                    if (arrow.thrown) throw arrow.error;
                                    throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
                            }
                        },
                        {
                            key: "parseArrow",
                            value: function parseArrow(node) {
                                var _this = this;
                                if (this.match(14)) {
                                    var result = this.tryParse(function() {
                                        var oldNoAnonFunctionType = _this.state.noAnonFunctionType;
                                        _this.state.noAnonFunctionType = true;
                                        var typeNode = _this.startNode();
                                        var ref;
                                        ref = _sliced_to_array(_this.flowParseTypeAndPredicateInitialiser(), 2), typeNode.typeAnnotation = ref[0], node.predicate = ref[1], ref;
                                        _this.state.noAnonFunctionType = oldNoAnonFunctionType;
                                        if (_this.canInsertSemicolon()) _this.unexpected();
                                        if (!_this.match(19)) _this.unexpected();
                                        return typeNode;
                                    });
                                    if (result.thrown) return null;
                                    if (result.error) this.state = result.failState;
                                    node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrow", this).call(this, node);
                            }
                        },
                        {
                            key: "shouldParseArrow",
                            value: function shouldParseArrow(params) {
                                return this.match(14) || _get(_get_prototype_of(FlowParserMixin.prototype), "shouldParseArrow", this).call(this, params);
                            }
                        },
                        {
                            key: "setArrowFunctionParameters",
                            value: function setArrowFunctionParameters(node, params) {
                                if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                    node.params = params;
                                } else {
                                    _get(_get_prototype_of(FlowParserMixin.prototype), "setArrowFunctionParameters", this).call(this, node, params);
                                }
                            }
                        },
                        {
                            key: "checkParams",
                            value: function checkParams(node, allowDuplicates, isArrowFunction) {
                                var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                                if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
                                    return;
                                }
                                for(var i = 0; i < node.params.length; i++){
                                    if (this.isThisParam(node.params[i]) && i > 0) {
                                        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
                                    }
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "checkParams", this).call(this, node, allowDuplicates, isArrowFunction, strictModeChanged);
                            }
                        },
                        {
                            key: "parseParenAndDistinguishExpression",
                            value: function parseParenAndDistinguishExpression(canBeArrow) {
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseParenAndDistinguishExpression", this).call(this, canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
                            }
                        },
                        {
                            key: "parseSubscripts",
                            value: function parseSubscripts(base, startLoc, noCalls) {
                                var _this = this;
                                if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
                                    this.next();
                                    var node = this.startNodeAt(startLoc);
                                    node.callee = base;
                                    node.arguments = _get(_get_prototype_of(FlowParserMixin.prototype), "parseCallExpressionArguments", this).call(this, 11);
                                    base = this.finishNode(node, "CallExpression");
                                } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
                                    var state = this.state.clone();
                                    var arrow = this.tryParse(function(abort) {
                                        return _this.parseAsyncArrowWithTypeParameters(startLoc) || abort();
                                    }, state);
                                    if (!arrow.error && !arrow.aborted) return arrow.node;
                                    var result = this.tryParse(function() {
                                        return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscripts", _this).call(_this, base, startLoc, noCalls);
                                    }, state);
                                    if (result.node && !result.error) return result.node;
                                    if (arrow.node) {
                                        this.state = arrow.failState;
                                        return arrow.node;
                                    }
                                    if (result.node) {
                                        this.state = result.failState;
                                        return result.node;
                                    }
                                    throw arrow.error || result.error;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscripts", this).call(this, base, startLoc, noCalls);
                            }
                        },
                        {
                            key: "parseSubscript",
                            value: function parseSubscript(base, startLoc, noCalls, subscriptState) {
                                var _this = this;
                                if (this.match(18) && this.isLookaheadToken_lt()) {
                                    subscriptState.optionalChainMember = true;
                                    if (noCalls) {
                                        subscriptState.stop = true;
                                        return base;
                                    }
                                    this.next();
                                    var node = this.startNodeAt(startLoc);
                                    node.callee = base;
                                    node.typeArguments = this.flowParseTypeParameterInstantiation();
                                    this.expect(10);
                                    node.arguments = this.parseCallExpressionArguments(11);
                                    node.optional = true;
                                    return this.finishCallExpression(node, true);
                                } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
                                    var node1 = this.startNodeAt(startLoc);
                                    node1.callee = base;
                                    var result = this.tryParse(function() {
                                        node1.typeArguments = _this.flowParseTypeParameterInstantiationCallOrNew();
                                        _this.expect(10);
                                        node1.arguments = _get(_get_prototype_of(FlowParserMixin.prototype), "parseCallExpressionArguments", _this).call(_this, 11);
                                        if (subscriptState.optionalChainMember) {
                                            node1.optional = false;
                                        }
                                        return _this.finishCallExpression(node1, subscriptState.optionalChainMember);
                                    });
                                    if (result.node) {
                                        if (result.error) this.state = result.failState;
                                        return result.node;
                                    }
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, subscriptState);
                            }
                        },
                        {
                            key: "parseNewCallee",
                            value: function parseNewCallee(node) {
                                var _this = this;
                                _get(_get_prototype_of(FlowParserMixin.prototype), "parseNewCallee", this).call(this, node);
                                var targs = null;
                                if (this.shouldParseTypes() && this.match(47)) {
                                    targs = this.tryParse(function() {
                                        return _this.flowParseTypeParameterInstantiationCallOrNew();
                                    }).node;
                                }
                                node.typeArguments = targs;
                            }
                        },
                        {
                            key: "parseAsyncArrowWithTypeParameters",
                            value: function parseAsyncArrowWithTypeParameters(startLoc) {
                                var node = this.startNodeAt(startLoc);
                                this.parseFunctionParams(node, false);
                                if (!this.parseArrow(node)) return;
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "parseArrowExpression", this).call(this, node, void 0, true);
                            }
                        },
                        {
                            key: "readToken_mult_modulo",
                            value: function readToken_mult_modulo(code2) {
                                var next = this.input.charCodeAt(this.state.pos + 1);
                                if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
                                    this.state.hasFlowComment = false;
                                    this.state.pos += 2;
                                    this.nextToken();
                                    return;
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "readToken_mult_modulo", this).call(this, code2);
                            }
                        },
                        {
                            key: "readToken_pipe_amp",
                            value: function readToken_pipe_amp(code2) {
                                var next = this.input.charCodeAt(this.state.pos + 1);
                                if (code2 === 124 && next === 125) {
                                    this.finishOp(9, 2);
                                    return;
                                }
                                _get(_get_prototype_of(FlowParserMixin.prototype), "readToken_pipe_amp", this).call(this, code2);
                            }
                        },
                        {
                            key: "parseTopLevel",
                            value: function parseTopLevel(file, program) {
                                var fileNode = _get(_get_prototype_of(FlowParserMixin.prototype), "parseTopLevel", this).call(this, file, program);
                                if (this.state.hasFlowComment) {
                                    this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
                                }
                                return fileNode;
                            }
                        },
                        {
                            key: "skipBlockComment",
                            value: function skipBlockComment() {
                                if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                                    if (this.state.hasFlowComment) {
                                        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
                                    }
                                    this.hasFlowCommentCompletion();
                                    var commentSkip = this.skipFlowComment();
                                    if (commentSkip) {
                                        this.state.pos += commentSkip;
                                        this.state.hasFlowComment = true;
                                    }
                                    return;
                                }
                                return _get(_get_prototype_of(FlowParserMixin.prototype), "skipBlockComment", this).call(this, this.state.hasFlowComment ? "*-/" : "*/");
                            }
                        },
                        {
                            key: "skipFlowComment",
                            value: function skipFlowComment() {
                                var pos = this.state.pos;
                                var shiftToFirstNonWhiteSpace = 2;
                                while([
                                    32,
                                    9
                                ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))){
                                    shiftToFirstNonWhiteSpace++;
                                }
                                var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
                                var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
                                if (ch2 === 58 && ch3 === 58) {
                                    return shiftToFirstNonWhiteSpace + 2;
                                }
                                if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
                                    return shiftToFirstNonWhiteSpace + 12;
                                }
                                if (ch2 === 58 && ch3 !== 58) {
                                    return shiftToFirstNonWhiteSpace;
                                }
                                return false;
                            }
                        },
                        {
                            key: "hasFlowCommentCompletion",
                            value: function hasFlowCommentCompletion() {
                                var end = this.input.indexOf("*/", this.state.pos);
                                if (end === -1) {
                                    throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
                                }
                            }
                        },
                        {
                            key: "flowEnumErrorBooleanMemberNotInitialized",
                            value: function flowEnumErrorBooleanMemberNotInitialized(loc, param) {
                                var enumName = param.enumName, memberName = param.memberName;
                                this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
                                    memberName: memberName,
                                    enumName: enumName
                                });
                            }
                        },
                        {
                            key: "flowEnumErrorInvalidMemberInitializer",
                            value: function flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
                                return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
                            }
                        },
                        {
                            key: "flowEnumErrorNumberMemberNotInitialized",
                            value: function flowEnumErrorNumberMemberNotInitialized(loc, details) {
                                this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
                            }
                        },
                        {
                            key: "flowEnumErrorStringMemberInconsistentlyInitialized",
                            value: function flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
                                this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
                            }
                        },
                        {
                            key: "flowEnumMemberInit",
                            value: function flowEnumMemberInit() {
                                var _this = this;
                                var startLoc = this.state.startLoc;
                                var endOfInit = function() {
                                    return _this.match(12) || _this.match(8);
                                };
                                switch(this.state.type){
                                    case 134:
                                        {
                                            var literal = this.parseNumericLiteral(this.state.value);
                                            if (endOfInit()) {
                                                return {
                                                    type: "number",
                                                    loc: literal.loc.start,
                                                    value: literal
                                                };
                                            }
                                            return {
                                                type: "invalid",
                                                loc: startLoc
                                            };
                                        }
                                    case 133:
                                        {
                                            var literal1 = this.parseStringLiteral(this.state.value);
                                            if (endOfInit()) {
                                                return {
                                                    type: "string",
                                                    loc: literal1.loc.start,
                                                    value: literal1
                                                };
                                            }
                                            return {
                                                type: "invalid",
                                                loc: startLoc
                                            };
                                        }
                                    case 85:
                                    case 86:
                                        {
                                            var literal2 = this.parseBooleanLiteral(this.match(85));
                                            if (endOfInit()) {
                                                return {
                                                    type: "boolean",
                                                    loc: literal2.loc.start,
                                                    value: literal2
                                                };
                                            }
                                            return {
                                                type: "invalid",
                                                loc: startLoc
                                            };
                                        }
                                    default:
                                        return {
                                            type: "invalid",
                                            loc: startLoc
                                        };
                                }
                            }
                        },
                        {
                            key: "flowEnumMemberRaw",
                            value: function flowEnumMemberRaw() {
                                var loc = this.state.startLoc;
                                var id = this.parseIdentifier(true);
                                var init = this.eat(29) ? this.flowEnumMemberInit() : {
                                    type: "none",
                                    loc: loc
                                };
                                return {
                                    id: id,
                                    init: init
                                };
                            }
                        },
                        {
                            key: "flowEnumCheckExplicitTypeMismatch",
                            value: function flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
                                var explicitType = context.explicitType;
                                if (explicitType === null) {
                                    return;
                                }
                                if (explicitType !== expectedType) {
                                    this.flowEnumErrorInvalidMemberInitializer(loc, context);
                                }
                            }
                        },
                        {
                            key: "flowEnumMembers",
                            value: function flowEnumMembers(param) {
                                var enumName = param.enumName, explicitType = param.explicitType;
                                var seenNames = /* @__PURE__ */ new Set();
                                var members = {
                                    booleanMembers: [],
                                    numberMembers: [],
                                    stringMembers: [],
                                    defaultedMembers: []
                                };
                                var hasUnknownMembers = false;
                                while(!this.match(8)){
                                    if (this.eat(21)) {
                                        hasUnknownMembers = true;
                                        break;
                                    }
                                    var memberNode = this.startNode();
                                    var _this_flowEnumMemberRaw = this.flowEnumMemberRaw(), id = _this_flowEnumMemberRaw.id, init = _this_flowEnumMemberRaw.init;
                                    var memberName = id.name;
                                    if (memberName === "") {
                                        continue;
                                    }
                                    if (/^[a-z]/.test(memberName)) {
                                        this.raise(FlowErrors.EnumInvalidMemberName, id, {
                                            memberName: memberName,
                                            suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                                            enumName: enumName
                                        });
                                    }
                                    if (seenNames.has(memberName)) {
                                        this.raise(FlowErrors.EnumDuplicateMemberName, id, {
                                            memberName: memberName,
                                            enumName: enumName
                                        });
                                    }
                                    seenNames.add(memberName);
                                    var context = {
                                        enumName: enumName,
                                        explicitType: explicitType,
                                        memberName: memberName
                                    };
                                    memberNode.id = id;
                                    switch(init.type){
                                        case "boolean":
                                            {
                                                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                                                memberNode.init = init.value;
                                                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                                                break;
                                            }
                                        case "number":
                                            {
                                                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                                                memberNode.init = init.value;
                                                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                                                break;
                                            }
                                        case "string":
                                            {
                                                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                                                memberNode.init = init.value;
                                                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                                                break;
                                            }
                                        case "invalid":
                                            {
                                                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                                            }
                                        case "none":
                                            {
                                                switch(explicitType){
                                                    case "boolean":
                                                        this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                                                        break;
                                                    case "number":
                                                        this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                                                        break;
                                                    default:
                                                        members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                                                }
                                            }
                                    }
                                    if (!this.match(8)) {
                                        this.expect(12);
                                    }
                                }
                                return {
                                    members: members,
                                    hasUnknownMembers: hasUnknownMembers
                                };
                            }
                        },
                        {
                            key: "flowEnumStringMembers",
                            value: function flowEnumStringMembers(initializedMembers, defaultedMembers, param) {
                                var enumName = param.enumName;
                                if (initializedMembers.length === 0) {
                                    return defaultedMembers;
                                } else if (defaultedMembers.length === 0) {
                                    return initializedMembers;
                                } else if (defaultedMembers.length > initializedMembers.length) {
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = initializedMembers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var member = _step.value;
                                            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
                                                enumName: enumName
                                            });
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                    return defaultedMembers;
                                } else {
                                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                    try {
                                        for(var _iterator1 = defaultedMembers[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                            var member1 = _step1.value;
                                            this.flowEnumErrorStringMemberInconsistentlyInitialized(member1, {
                                                enumName: enumName
                                            });
                                        }
                                    } catch (err) {
                                        _didIteratorError1 = true;
                                        _iteratorError1 = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                _iterator1.return();
                                            }
                                        } finally{
                                            if (_didIteratorError1) {
                                                throw _iteratorError1;
                                            }
                                        }
                                    }
                                    return initializedMembers;
                                }
                            }
                        },
                        {
                            key: "flowEnumParseExplicitType",
                            value: function flowEnumParseExplicitType(param) {
                                var enumName = param.enumName;
                                if (!this.eatContextual(102)) return null;
                                if (!tokenIsIdentifier(this.state.type)) {
                                    throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
                                        enumName: enumName
                                    });
                                }
                                var value = this.state.value;
                                this.next();
                                if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
                                    this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
                                        enumName: enumName,
                                        invalidEnumType: value
                                    });
                                }
                                return value;
                            }
                        },
                        {
                            key: "flowEnumBody",
                            value: function flowEnumBody(node, id) {
                                var _this = this;
                                var enumName = id.name;
                                var nameLoc = id.loc.start;
                                var explicitType = this.flowEnumParseExplicitType({
                                    enumName: enumName
                                });
                                this.expect(5);
                                var _this_flowEnumMembers = this.flowEnumMembers({
                                    enumName: enumName,
                                    explicitType: explicitType
                                }), members = _this_flowEnumMembers.members, hasUnknownMembers = _this_flowEnumMembers.hasUnknownMembers;
                                node.hasUnknownMembers = hasUnknownMembers;
                                switch(explicitType){
                                    case "boolean":
                                        node.explicitType = true;
                                        node.members = members.booleanMembers;
                                        this.expect(8);
                                        return this.finishNode(node, "EnumBooleanBody");
                                    case "number":
                                        node.explicitType = true;
                                        node.members = members.numberMembers;
                                        this.expect(8);
                                        return this.finishNode(node, "EnumNumberBody");
                                    case "string":
                                        node.explicitType = true;
                                        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                            enumName: enumName
                                        });
                                        this.expect(8);
                                        return this.finishNode(node, "EnumStringBody");
                                    case "symbol":
                                        node.members = members.defaultedMembers;
                                        this.expect(8);
                                        return this.finishNode(node, "EnumSymbolBody");
                                    default:
                                        {
                                            var empty = function() {
                                                node.members = [];
                                                _this.expect(8);
                                                return _this.finishNode(node, "EnumStringBody");
                                            };
                                            node.explicitType = false;
                                            var boolsLen = members.booleanMembers.length;
                                            var numsLen = members.numberMembers.length;
                                            var strsLen = members.stringMembers.length;
                                            var defaultedLen = members.defaultedMembers.length;
                                            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                                                return empty();
                                            } else if (!boolsLen && !numsLen) {
                                                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                                                    enumName: enumName
                                                });
                                                this.expect(8);
                                                return this.finishNode(node, "EnumStringBody");
                                            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                                try {
                                                    for(var _iterator = members.defaultedMembers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                                        var member = _step.value;
                                                        this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                                                            enumName: enumName,
                                                            memberName: member.id.name
                                                        });
                                                    }
                                                } catch (err) {
                                                    _didIteratorError = true;
                                                    _iteratorError = err;
                                                } finally{
                                                    try {
                                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                            _iterator.return();
                                                        }
                                                    } finally{
                                                        if (_didIteratorError) {
                                                            throw _iteratorError;
                                                        }
                                                    }
                                                }
                                                node.members = members.booleanMembers;
                                                this.expect(8);
                                                return this.finishNode(node, "EnumBooleanBody");
                                            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                                try {
                                                    for(var _iterator1 = members.defaultedMembers[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                                        var member1 = _step1.value;
                                                        this.flowEnumErrorNumberMemberNotInitialized(member1.loc.start, {
                                                            enumName: enumName,
                                                            memberName: member1.id.name
                                                        });
                                                    }
                                                } catch (err) {
                                                    _didIteratorError1 = true;
                                                    _iteratorError1 = err;
                                                } finally{
                                                    try {
                                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                            _iterator1.return();
                                                        }
                                                    } finally{
                                                        if (_didIteratorError1) {
                                                            throw _iteratorError1;
                                                        }
                                                    }
                                                }
                                                node.members = members.numberMembers;
                                                this.expect(8);
                                                return this.finishNode(node, "EnumNumberBody");
                                            } else {
                                                this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                                                    enumName: enumName
                                                });
                                                return empty();
                                            }
                                        }
                                }
                            }
                        },
                        {
                            key: "flowParseEnumDeclaration",
                            value: function flowParseEnumDeclaration(node) {
                                var id = this.parseIdentifier();
                                node.id = id;
                                node.body = this.flowEnumBody(this.startNode(), id);
                                return this.finishNode(node, "EnumDeclaration");
                            }
                        },
                        {
                            key: "isLookaheadToken_lt",
                            value: function isLookaheadToken_lt() {
                                var next = this.nextTokenStart();
                                if (this.input.charCodeAt(next) === 60) {
                                    var afterNext = this.input.charCodeAt(next + 1);
                                    return afterNext !== 60 && afterNext !== 61;
                                }
                                return false;
                            }
                        },
                        {
                            key: "maybeUnwrapTypeCastExpression",
                            value: function maybeUnwrapTypeCastExpression(node) {
                                return node.type === "TypeCastExpression" ? node.expression : node;
                            }
                        }
                    ]);
                    return FlowParserMixin;
                }(superClass);
                return FlowParserMixin;
            };
            var entities = {
                __proto__: null,
                quot: '"',
                amp: "&",
                apos: "'",
                lt: "<",
                gt: ">",
                nbsp: "\xA0",
                iexcl: "\xA1",
                cent: "\xA2",
                pound: "\xA3",
                curren: "\xA4",
                yen: "\xA5",
                brvbar: "\xA6",
                sect: "\xA7",
                uml: "\xA8",
                copy: "\xA9",
                ordf: "\xAA",
                laquo: "\xAB",
                not: "\xAC",
                shy: "\xAD",
                reg: "\xAE",
                macr: "\xAF",
                deg: "\xB0",
                plusmn: "\xB1",
                sup2: "\xB2",
                sup3: "\xB3",
                acute: "\xB4",
                micro: "\xB5",
                para: "\xB6",
                middot: "\xB7",
                cedil: "\xB8",
                sup1: "\xB9",
                ordm: "\xBA",
                raquo: "\xBB",
                frac14: "\xBC",
                frac12: "\xBD",
                frac34: "\xBE",
                iquest: "\xBF",
                Agrave: "\xC0",
                Aacute: "\xC1",
                Acirc: "\xC2",
                Atilde: "\xC3",
                Auml: "\xC4",
                Aring: "\xC5",
                AElig: "\xC6",
                Ccedil: "\xC7",
                Egrave: "\xC8",
                Eacute: "\xC9",
                Ecirc: "\xCA",
                Euml: "\xCB",
                Igrave: "\xCC",
                Iacute: "\xCD",
                Icirc: "\xCE",
                Iuml: "\xCF",
                ETH: "\xD0",
                Ntilde: "\xD1",
                Ograve: "\xD2",
                Oacute: "\xD3",
                Ocirc: "\xD4",
                Otilde: "\xD5",
                Ouml: "\xD6",
                times: "\xD7",
                Oslash: "\xD8",
                Ugrave: "\xD9",
                Uacute: "\xDA",
                Ucirc: "\xDB",
                Uuml: "\xDC",
                Yacute: "\xDD",
                THORN: "\xDE",
                szlig: "\xDF",
                agrave: "\xE0",
                aacute: "\xE1",
                acirc: "\xE2",
                atilde: "\xE3",
                auml: "\xE4",
                aring: "\xE5",
                aelig: "\xE6",
                ccedil: "\xE7",
                egrave: "\xE8",
                eacute: "\xE9",
                ecirc: "\xEA",
                euml: "\xEB",
                igrave: "\xEC",
                iacute: "\xED",
                icirc: "\xEE",
                iuml: "\xEF",
                eth: "\xF0",
                ntilde: "\xF1",
                ograve: "\xF2",
                oacute: "\xF3",
                ocirc: "\xF4",
                otilde: "\xF5",
                ouml: "\xF6",
                divide: "\xF7",
                oslash: "\xF8",
                ugrave: "\xF9",
                uacute: "\xFA",
                ucirc: "\xFB",
                uuml: "\xFC",
                yacute: "\xFD",
                thorn: "\xFE",
                yuml: "\xFF",
                OElig: "\u0152",
                oelig: "\u0153",
                Scaron: "\u0160",
                scaron: "\u0161",
                Yuml: "\u0178",
                fnof: "\u0192",
                circ: "\u02C6",
                tilde: "\u02DC",
                Alpha: "\u0391",
                Beta: "\u0392",
                Gamma: "\u0393",
                Delta: "\u0394",
                Epsilon: "\u0395",
                Zeta: "\u0396",
                Eta: "\u0397",
                Theta: "\u0398",
                Iota: "\u0399",
                Kappa: "\u039A",
                Lambda: "\u039B",
                Mu: "\u039C",
                Nu: "\u039D",
                Xi: "\u039E",
                Omicron: "\u039F",
                Pi: "\u03A0",
                Rho: "\u03A1",
                Sigma: "\u03A3",
                Tau: "\u03A4",
                Upsilon: "\u03A5",
                Phi: "\u03A6",
                Chi: "\u03A7",
                Psi: "\u03A8",
                Omega: "\u03A9",
                alpha: "\u03B1",
                beta: "\u03B2",
                gamma: "\u03B3",
                delta: "\u03B4",
                epsilon: "\u03B5",
                zeta: "\u03B6",
                eta: "\u03B7",
                theta: "\u03B8",
                iota: "\u03B9",
                kappa: "\u03BA",
                lambda: "\u03BB",
                mu: "\u03BC",
                nu: "\u03BD",
                xi: "\u03BE",
                omicron: "\u03BF",
                pi: "\u03C0",
                rho: "\u03C1",
                sigmaf: "\u03C2",
                sigma: "\u03C3",
                tau: "\u03C4",
                upsilon: "\u03C5",
                phi: "\u03C6",
                chi: "\u03C7",
                psi: "\u03C8",
                omega: "\u03C9",
                thetasym: "\u03D1",
                upsih: "\u03D2",
                piv: "\u03D6",
                ensp: "\u2002",
                emsp: "\u2003",
                thinsp: "\u2009",
                zwnj: "\u200C",
                zwj: "\u200D",
                lrm: "\u200E",
                rlm: "\u200F",
                ndash: "\u2013",
                mdash: "\u2014",
                lsquo: "\u2018",
                rsquo: "\u2019",
                sbquo: "\u201A",
                ldquo: "\u201C",
                rdquo: "\u201D",
                bdquo: "\u201E",
                dagger: "\u2020",
                Dagger: "\u2021",
                bull: "\u2022",
                hellip: "\u2026",
                permil: "\u2030",
                prime: "\u2032",
                Prime: "\u2033",
                lsaquo: "\u2039",
                rsaquo: "\u203A",
                oline: "\u203E",
                frasl: "\u2044",
                euro: "\u20AC",
                image: "\u2111",
                weierp: "\u2118",
                real: "\u211C",
                trade: "\u2122",
                alefsym: "\u2135",
                larr: "\u2190",
                uarr: "\u2191",
                rarr: "\u2192",
                darr: "\u2193",
                harr: "\u2194",
                crarr: "\u21B5",
                lArr: "\u21D0",
                uArr: "\u21D1",
                rArr: "\u21D2",
                dArr: "\u21D3",
                hArr: "\u21D4",
                forall: "\u2200",
                part: "\u2202",
                exist: "\u2203",
                empty: "\u2205",
                nabla: "\u2207",
                isin: "\u2208",
                notin: "\u2209",
                ni: "\u220B",
                prod: "\u220F",
                sum: "\u2211",
                minus: "\u2212",
                lowast: "\u2217",
                radic: "\u221A",
                prop: "\u221D",
                infin: "\u221E",
                ang: "\u2220",
                and: "\u2227",
                or: "\u2228",
                cap: "\u2229",
                cup: "\u222A",
                int: "\u222B",
                there4: "\u2234",
                sim: "\u223C",
                cong: "\u2245",
                asymp: "\u2248",
                ne: "\u2260",
                equiv: "\u2261",
                le: "\u2264",
                ge: "\u2265",
                sub: "\u2282",
                sup: "\u2283",
                nsub: "\u2284",
                sube: "\u2286",
                supe: "\u2287",
                oplus: "\u2295",
                otimes: "\u2297",
                perp: "\u22A5",
                sdot: "\u22C5",
                lceil: "\u2308",
                rceil: "\u2309",
                lfloor: "\u230A",
                rfloor: "\u230B",
                lang: "\u2329",
                rang: "\u232A",
                loz: "\u25CA",
                spades: "\u2660",
                clubs: "\u2663",
                hearts: "\u2665",
                diams: "\u2666"
            };
            var JsxErrors = ParseErrorEnum(_templateObject2())({
                AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
                MissingClosingTagElement: function(param) {
                    var openingTagName = param.openingTagName;
                    return "Expected corresponding JSX closing tag for <".concat(openingTagName, ">.");
                },
                MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
                UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
                UnexpectedToken: function(param) {
                    var unexpected = param.unexpected, HTMLEntity = param.HTMLEntity;
                    return "Unexpected token `".concat(unexpected, "`. Did you mean `").concat(HTMLEntity, "` or `{'").concat(unexpected, "'}`?");
                },
                UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
                UnterminatedJsxContent: "Unterminated JSX contents.",
                UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
            });
            function isFragment(object) {
                return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
            }
            function getQualifiedJSXName(object) {
                if (object.type === "JSXIdentifier") {
                    return object.name;
                }
                if (object.type === "JSXNamespacedName") {
                    return object.namespace.name + ":" + object.name.name;
                }
                if (object.type === "JSXMemberExpression") {
                    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
                }
                throw new Error("Node had unexpected type: " + object.type);
            }
            var jsx = function(superClass) {
                var JSXParserMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(JSXParserMixin, superClass);
                    function JSXParserMixin() {
                        _class_call_check(this, JSXParserMixin);
                        return _call_super(this, JSXParserMixin, arguments);
                    }
                    _create_class(JSXParserMixin, [
                        {
                            key: "jsxReadToken",
                            value: function jsxReadToken() {
                                var out = "";
                                var chunkStart = this.state.pos;
                                for(;;){
                                    if (this.state.pos >= this.length) {
                                        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
                                    }
                                    var ch = this.input.charCodeAt(this.state.pos);
                                    switch(ch){
                                        case 60:
                                        case 123:
                                            if (this.state.pos === this.state.start) {
                                                if (ch === 60 && this.state.canStartJSXElement) {
                                                    ++this.state.pos;
                                                    this.finishToken(142);
                                                } else {
                                                    _get(_get_prototype_of(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, ch);
                                                }
                                                return;
                                            }
                                            out += this.input.slice(chunkStart, this.state.pos);
                                            this.finishToken(141, out);
                                            return;
                                        case 38:
                                            out += this.input.slice(chunkStart, this.state.pos);
                                            out += this.jsxReadEntity();
                                            chunkStart = this.state.pos;
                                            break;
                                        case 62:
                                        case 125:
                                        default:
                                            if (isNewLine(ch)) {
                                                out += this.input.slice(chunkStart, this.state.pos);
                                                out += this.jsxReadNewLine(true);
                                                chunkStart = this.state.pos;
                                            } else {
                                                ++this.state.pos;
                                            }
                                    }
                                }
                            }
                        },
                        {
                            key: "jsxReadNewLine",
                            value: function jsxReadNewLine(normalizeCRLF) {
                                var ch = this.input.charCodeAt(this.state.pos);
                                var out;
                                ++this.state.pos;
                                if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                                    ++this.state.pos;
                                    out = normalizeCRLF ? "\n" : "\r\n";
                                } else {
                                    out = String.fromCharCode(ch);
                                }
                                ++this.state.curLine;
                                this.state.lineStart = this.state.pos;
                                return out;
                            }
                        },
                        {
                            key: "jsxReadString",
                            value: function jsxReadString(quote) {
                                var out = "";
                                var chunkStart = ++this.state.pos;
                                for(;;){
                                    if (this.state.pos >= this.length) {
                                        throw this.raise(Errors.UnterminatedString, this.state.startLoc);
                                    }
                                    var ch = this.input.charCodeAt(this.state.pos);
                                    if (ch === quote) break;
                                    if (ch === 38) {
                                        out += this.input.slice(chunkStart, this.state.pos);
                                        out += this.jsxReadEntity();
                                        chunkStart = this.state.pos;
                                    } else if (isNewLine(ch)) {
                                        out += this.input.slice(chunkStart, this.state.pos);
                                        out += this.jsxReadNewLine(false);
                                        chunkStart = this.state.pos;
                                    } else {
                                        ++this.state.pos;
                                    }
                                }
                                out += this.input.slice(chunkStart, this.state.pos++);
                                this.finishToken(133, out);
                            }
                        },
                        {
                            key: "jsxReadEntity",
                            value: function jsxReadEntity() {
                                var startPos = ++this.state.pos;
                                if (this.codePointAtPos(this.state.pos) === 35) {
                                    ++this.state.pos;
                                    var radix = 10;
                                    if (this.codePointAtPos(this.state.pos) === 120) {
                                        radix = 16;
                                        ++this.state.pos;
                                    }
                                    var codePoint = this.readInt(radix, void 0, false, "bail");
                                    if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
                                        ++this.state.pos;
                                        return String.fromCodePoint(codePoint);
                                    }
                                } else {
                                    var count = 0;
                                    var semi = false;
                                    while(count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)){
                                        ++this.state.pos;
                                    }
                                    if (semi) {
                                        var desc = this.input.slice(startPos, this.state.pos);
                                        var entity = entities[desc];
                                        ++this.state.pos;
                                        if (entity) {
                                            return entity;
                                        }
                                    }
                                }
                                this.state.pos = startPos;
                                return "&";
                            }
                        },
                        {
                            key: "jsxReadWord",
                            value: function jsxReadWord() {
                                var ch;
                                var start = this.state.pos;
                                do {
                                    ch = this.input.charCodeAt(++this.state.pos);
                                }while (isIdentifierChar(ch) || ch === 45);
                                this.finishToken(140, this.input.slice(start, this.state.pos));
                            }
                        },
                        {
                            key: "jsxParseIdentifier",
                            value: function jsxParseIdentifier() {
                                var node = this.startNode();
                                if (this.match(140)) {
                                    node.name = this.state.value;
                                } else if (tokenIsKeyword(this.state.type)) {
                                    node.name = tokenLabelName(this.state.type);
                                } else {
                                    this.unexpected();
                                }
                                this.next();
                                return this.finishNode(node, "JSXIdentifier");
                            }
                        },
                        {
                            key: "jsxParseNamespacedName",
                            value: function jsxParseNamespacedName() {
                                var startLoc = this.state.startLoc;
                                var name = this.jsxParseIdentifier();
                                if (!this.eat(14)) return name;
                                var node = this.startNodeAt(startLoc);
                                node.namespace = name;
                                node.name = this.jsxParseIdentifier();
                                return this.finishNode(node, "JSXNamespacedName");
                            }
                        },
                        {
                            key: "jsxParseElementName",
                            value: function jsxParseElementName() {
                                var startLoc = this.state.startLoc;
                                var node = this.jsxParseNamespacedName();
                                if (node.type === "JSXNamespacedName") {
                                    return node;
                                }
                                while(this.eat(16)){
                                    var newNode = this.startNodeAt(startLoc);
                                    newNode.object = node;
                                    newNode.property = this.jsxParseIdentifier();
                                    node = this.finishNode(newNode, "JSXMemberExpression");
                                }
                                return node;
                            }
                        },
                        {
                            key: "jsxParseAttributeValue",
                            value: function jsxParseAttributeValue() {
                                var node;
                                switch(this.state.type){
                                    case 5:
                                        node = this.startNode();
                                        this.setContext(types.brace);
                                        this.next();
                                        node = this.jsxParseExpressionContainer(node, types.j_oTag);
                                        if (node.expression.type === "JSXEmptyExpression") {
                                            this.raise(JsxErrors.AttributeIsEmpty, node);
                                        }
                                        return node;
                                    case 142:
                                    case 133:
                                        return this.parseExprAtom();
                                    default:
                                        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
                                }
                            }
                        },
                        {
                            key: "jsxParseEmptyExpression",
                            value: function jsxParseEmptyExpression() {
                                var node = this.startNodeAt(this.state.lastTokEndLoc);
                                return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
                            }
                        },
                        {
                            key: "jsxParseSpreadChild",
                            value: function jsxParseSpreadChild(node) {
                                this.next();
                                node.expression = this.parseExpression();
                                this.setContext(types.j_expr);
                                this.state.canStartJSXElement = true;
                                this.expect(8);
                                return this.finishNode(node, "JSXSpreadChild");
                            }
                        },
                        {
                            key: "jsxParseExpressionContainer",
                            value: function jsxParseExpressionContainer(node, previousContext) {
                                if (this.match(8)) {
                                    node.expression = this.jsxParseEmptyExpression();
                                } else {
                                    var expression = this.parseExpression();
                                    node.expression = expression;
                                }
                                this.setContext(previousContext);
                                this.state.canStartJSXElement = true;
                                this.expect(8);
                                return this.finishNode(node, "JSXExpressionContainer");
                            }
                        },
                        {
                            key: "jsxParseAttribute",
                            value: function jsxParseAttribute() {
                                var node = this.startNode();
                                if (this.match(5)) {
                                    this.setContext(types.brace);
                                    this.next();
                                    this.expect(21);
                                    node.argument = this.parseMaybeAssignAllowIn();
                                    this.setContext(types.j_oTag);
                                    this.state.canStartJSXElement = true;
                                    this.expect(8);
                                    return this.finishNode(node, "JSXSpreadAttribute");
                                }
                                node.name = this.jsxParseNamespacedName();
                                node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
                                return this.finishNode(node, "JSXAttribute");
                            }
                        },
                        {
                            key: "jsxParseOpeningElementAt",
                            value: function jsxParseOpeningElementAt(startLoc) {
                                var node = this.startNodeAt(startLoc);
                                if (this.eat(143)) {
                                    return this.finishNode(node, "JSXOpeningFragment");
                                }
                                node.name = this.jsxParseElementName();
                                return this.jsxParseOpeningElementAfterName(node);
                            }
                        },
                        {
                            key: "jsxParseOpeningElementAfterName",
                            value: function jsxParseOpeningElementAfterName(node) {
                                var attributes = [];
                                while(!this.match(56) && !this.match(143)){
                                    attributes.push(this.jsxParseAttribute());
                                }
                                node.attributes = attributes;
                                node.selfClosing = this.eat(56);
                                this.expect(143);
                                return this.finishNode(node, "JSXOpeningElement");
                            }
                        },
                        {
                            key: "jsxParseClosingElementAt",
                            value: function jsxParseClosingElementAt(startLoc) {
                                var node = this.startNodeAt(startLoc);
                                if (this.eat(143)) {
                                    return this.finishNode(node, "JSXClosingFragment");
                                }
                                node.name = this.jsxParseElementName();
                                this.expect(143);
                                return this.finishNode(node, "JSXClosingElement");
                            }
                        },
                        {
                            key: "jsxParseElementAt",
                            value: function jsxParseElementAt(startLoc) {
                                var node = this.startNodeAt(startLoc);
                                var children = [];
                                var openingElement = this.jsxParseOpeningElementAt(startLoc);
                                var closingElement = null;
                                if (!openingElement.selfClosing) {
                                    contents: for(;;){
                                        switch(this.state.type){
                                            case 142:
                                                startLoc = this.state.startLoc;
                                                this.next();
                                                if (this.eat(56)) {
                                                    closingElement = this.jsxParseClosingElementAt(startLoc);
                                                    break contents;
                                                }
                                                children.push(this.jsxParseElementAt(startLoc));
                                                break;
                                            case 141:
                                                children.push(this.parseLiteral(this.state.value, "JSXText"));
                                                break;
                                            case 5:
                                                {
                                                    var node2 = this.startNode();
                                                    this.setContext(types.brace);
                                                    this.next();
                                                    if (this.match(21)) {
                                                        children.push(this.jsxParseSpreadChild(node2));
                                                    } else {
                                                        children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                                                    }
                                                    break;
                                                }
                                            default:
                                                this.unexpected();
                                        }
                                    }
                                    if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
                                        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
                                    } else if (!isFragment(openingElement) && isFragment(closingElement)) {
                                        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                                            openingTagName: getQualifiedJSXName(openingElement.name)
                                        });
                                    } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
                                        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                                            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                                                openingTagName: getQualifiedJSXName(openingElement.name)
                                            });
                                        }
                                    }
                                }
                                if (isFragment(openingElement)) {
                                    node.openingFragment = openingElement;
                                    node.closingFragment = closingElement;
                                } else {
                                    node.openingElement = openingElement;
                                    node.closingElement = closingElement;
                                }
                                node.children = children;
                                if (this.match(47)) {
                                    throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
                                }
                                return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
                            }
                        },
                        {
                            key: "jsxParseElement",
                            value: function jsxParseElement() {
                                var startLoc = this.state.startLoc;
                                this.next();
                                return this.jsxParseElementAt(startLoc);
                            }
                        },
                        {
                            key: "setContext",
                            value: function setContext(newContext) {
                                var context = this.state.context;
                                context[context.length - 1] = newContext;
                            }
                        },
                        {
                            key: "parseExprAtom",
                            value: function parseExprAtom(refExpressionErrors) {
                                if (this.match(142)) {
                                    return this.jsxParseElement();
                                } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                                    this.replaceToken(142);
                                    return this.jsxParseElement();
                                } else {
                                    return _get(_get_prototype_of(JSXParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                                }
                            }
                        },
                        {
                            key: "skipSpace",
                            value: function skipSpace() {
                                var curContext = this.curContext();
                                if (!curContext.preserveSpace) _get(_get_prototype_of(JSXParserMixin.prototype), "skipSpace", this).call(this);
                            }
                        },
                        {
                            key: "getTokenFromCode",
                            value: function getTokenFromCode(code2) {
                                var context = this.curContext();
                                if (context === types.j_expr) {
                                    this.jsxReadToken();
                                    return;
                                }
                                if (context === types.j_oTag || context === types.j_cTag) {
                                    if (isIdentifierStart(code2)) {
                                        this.jsxReadWord();
                                        return;
                                    }
                                    if (code2 === 62) {
                                        ++this.state.pos;
                                        this.finishToken(143);
                                        return;
                                    }
                                    if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
                                        this.jsxReadString(code2);
                                        return;
                                    }
                                }
                                if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                                    ++this.state.pos;
                                    this.finishToken(142);
                                    return;
                                }
                                _get(_get_prototype_of(JSXParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                            }
                        },
                        {
                            key: "updateContext",
                            value: function updateContext(prevType) {
                                var _this_state = this.state, context = _this_state.context, type = _this_state.type;
                                if (type === 56 && prevType === 142) {
                                    context.splice(-2, 2, types.j_cTag);
                                    this.state.canStartJSXElement = false;
                                } else if (type === 142) {
                                    context.push(types.j_oTag);
                                } else if (type === 143) {
                                    var out = context[context.length - 1];
                                    if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
                                        context.pop();
                                        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
                                    } else {
                                        this.setContext(types.j_expr);
                                        this.state.canStartJSXElement = true;
                                    }
                                } else {
                                    this.state.canStartJSXElement = tokenComesBeforeExpression(type);
                                }
                            }
                        }
                    ]);
                    return JSXParserMixin;
                }(superClass);
                return JSXParserMixin;
            };
            var TypeScriptScope = /*#__PURE__*/ function(Scope) {
                _inherits(TypeScriptScope, Scope);
                function TypeScriptScope() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    _class_call_check(this, TypeScriptScope);
                    var _this;
                    _this = _call_super(this, TypeScriptScope, _to_consumable_array(args));
                    _this.tsNames = /* @__PURE__ */ new Map();
                    return _this;
                }
                return TypeScriptScope;
            }(Scope);
            var TypeScriptScopeHandler = /*#__PURE__*/ function(ScopeHandler) {
                _inherits(TypeScriptScopeHandler, ScopeHandler);
                function TypeScriptScopeHandler() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    _class_call_check(this, TypeScriptScopeHandler);
                    var _this;
                    _this = _call_super(this, TypeScriptScopeHandler, _to_consumable_array(args));
                    _this.importsStack = [];
                    return _this;
                }
                _create_class(TypeScriptScopeHandler, [
                    {
                        key: "createScope",
                        value: function createScope(flags) {
                            this.importsStack.push(/* @__PURE__ */ new Set());
                            return new TypeScriptScope(flags);
                        }
                    },
                    {
                        key: "enter",
                        value: function enter(flags) {
                            if (flags === 256) {
                                this.importsStack.push(/* @__PURE__ */ new Set());
                            }
                            _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "enter", this).call(this, flags);
                        }
                    },
                    {
                        key: "exit",
                        value: function exit() {
                            var flags = _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "exit", this).call(this);
                            if (flags === 256) {
                                this.importsStack.pop();
                            }
                            return flags;
                        }
                    },
                    {
                        key: "hasImport",
                        value: function hasImport(name, allowShadow) {
                            var len = this.importsStack.length;
                            if (this.importsStack[len - 1].has(name)) {
                                return true;
                            }
                            if (!allowShadow && len > 1) {
                                for(var i = 0; i < len - 1; i++){
                                    if (this.importsStack[i].has(name)) return true;
                                }
                            }
                            return false;
                        }
                    },
                    {
                        key: "declareName",
                        value: function declareName(name, bindingType, loc) {
                            if (bindingType & 4096) {
                                if (this.hasImport(name, true)) {
                                    this.parser.raise(Errors.VarRedeclaration, loc, {
                                        identifierName: name
                                    });
                                }
                                this.importsStack[this.importsStack.length - 1].add(name);
                                return;
                            }
                            var scope = this.currentScope();
                            var type = scope.tsNames.get(name) || 0;
                            if (bindingType & 1024) {
                                this.maybeExportDefined(scope, name);
                                scope.tsNames.set(name, type | 16);
                                return;
                            }
                            _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "declareName", this).call(this, name, bindingType, loc);
                            if (bindingType & 2) {
                                if (!(bindingType & 1)) {
                                    this.checkRedeclarationInScope(scope, name, bindingType, loc);
                                    this.maybeExportDefined(scope, name);
                                }
                                type = type | 1;
                            }
                            if (bindingType & 256) {
                                type = type | 2;
                            }
                            if (bindingType & 512) {
                                type = type | 4;
                            }
                            if (bindingType & 128) {
                                type = type | 8;
                            }
                            if (type) scope.tsNames.set(name, type);
                        }
                    },
                    {
                        key: "isRedeclaredInScope",
                        value: function isRedeclaredInScope(scope, name, bindingType) {
                            var type = scope.tsNames.get(name);
                            if ((type & 2) > 0) {
                                if (bindingType & 256) {
                                    var isConst = !!(bindingType & 512);
                                    var wasConst = (type & 4) > 0;
                                    return isConst !== wasConst;
                                }
                                return true;
                            }
                            if (bindingType & 128 && (type & 8) > 0) {
                                if (scope.names.get(name) & 2) {
                                    return !!(bindingType & 1);
                                } else {
                                    return false;
                                }
                            }
                            if (bindingType & 2 && (type & 1) > 0) {
                                return true;
                            }
                            return _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "isRedeclaredInScope", this).call(this, scope, name, bindingType);
                        }
                    },
                    {
                        key: "checkLocalExport",
                        value: function checkLocalExport(id) {
                            var name = id.name;
                            if (this.hasImport(name)) return;
                            var len = this.scopeStack.length;
                            for(var i = len - 1; i >= 0; i--){
                                var scope = this.scopeStack[i];
                                var type = scope.tsNames.get(name);
                                if ((type & 1) > 0 || (type & 16) > 0) {
                                    return;
                                }
                            }
                            _get(_get_prototype_of(TypeScriptScopeHandler.prototype), "checkLocalExport", this).call(this, id);
                        }
                    }
                ]);
                return TypeScriptScopeHandler;
            }(ScopeHandler);
            var unwrapParenthesizedExpression = function(node) {
                return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
            };
            var LValParser = /*#__PURE__*/ function(NodeUtils) {
                _inherits(LValParser, NodeUtils);
                function LValParser() {
                    _class_call_check(this, LValParser);
                    return _call_super(this, LValParser, arguments);
                }
                _create_class(LValParser, [
                    {
                        key: "toAssignable",
                        value: function toAssignable(node) {
                            var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                            var _node$extra, _node$extra3;
                            var parenthesized = void 0;
                            if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
                                parenthesized = unwrapParenthesizedExpression(node);
                                if (isLHS) {
                                    if (parenthesized.type === "Identifier") {
                                        this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
                                    } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
                                        this.raise(Errors.InvalidParenthesizedAssignment, node);
                                    }
                                } else {
                                    this.raise(Errors.InvalidParenthesizedAssignment, node);
                                }
                            }
                            switch(node.type){
                                case "Identifier":
                                case "ObjectPattern":
                                case "ArrayPattern":
                                case "AssignmentPattern":
                                case "RestElement":
                                    break;
                                case "ObjectExpression":
                                    node.type = "ObjectPattern";
                                    for(var i = 0, length = node.properties.length, last = length - 1; i < length; i++){
                                        var _node$extra2;
                                        var prop = node.properties[i];
                                        var isLast = i === last;
                                        this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                                        if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                                            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
                                        }
                                    }
                                    break;
                                case "ObjectProperty":
                                    {
                                        var key = node.key, value = node.value;
                                        if (this.isPrivateName(key)) {
                                            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
                                        }
                                        this.toAssignable(value, isLHS);
                                        break;
                                    }
                                case "SpreadElement":
                                    {
                                        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                                    }
                                case "ArrayExpression":
                                    node.type = "ArrayPattern";
                                    this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
                                    break;
                                case "AssignmentExpression":
                                    if (node.operator !== "=") {
                                        this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
                                    }
                                    node.type = "AssignmentPattern";
                                    delete node.operator;
                                    this.toAssignable(node.left, isLHS);
                                    break;
                                case "ParenthesizedExpression":
                                    this.toAssignable(parenthesized, isLHS);
                                    break;
                            }
                        }
                    },
                    {
                        key: "toAssignableObjectExpressionProp",
                        value: function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
                            if (prop.type === "ObjectMethod") {
                                this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
                            } else if (prop.type === "SpreadElement") {
                                prop.type = "RestElement";
                                var arg = prop.argument;
                                this.checkToRestConversion(arg, false);
                                this.toAssignable(arg, isLHS);
                                if (!isLast) {
                                    this.raise(Errors.RestTrailingComma, prop);
                                }
                            } else {
                                this.toAssignable(prop, isLHS);
                            }
                        }
                    },
                    {
                        key: "toAssignableList",
                        value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                            var end = exprList.length - 1;
                            for(var i = 0; i <= end; i++){
                                var elt = exprList[i];
                                if (!elt) continue;
                                if (elt.type === "SpreadElement") {
                                    elt.type = "RestElement";
                                    var arg = elt.argument;
                                    this.checkToRestConversion(arg, true);
                                    this.toAssignable(arg, isLHS);
                                } else {
                                    this.toAssignable(elt, isLHS);
                                }
                                if (elt.type === "RestElement") {
                                    if (i < end) {
                                        this.raise(Errors.RestTrailingComma, elt);
                                    } else if (trailingCommaLoc) {
                                        this.raise(Errors.RestTrailingComma, trailingCommaLoc);
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "isAssignable",
                        value: function isAssignable(node, isBinding) {
                            var _this = this;
                            switch(node.type){
                                case "Identifier":
                                case "ObjectPattern":
                                case "ArrayPattern":
                                case "AssignmentPattern":
                                case "RestElement":
                                    return true;
                                case "ObjectExpression":
                                    {
                                        var last = node.properties.length - 1;
                                        return node.properties.every(function(prop, i) {
                                            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && _this.isAssignable(prop);
                                        });
                                    }
                                case "ObjectProperty":
                                    return this.isAssignable(node.value);
                                case "SpreadElement":
                                    return this.isAssignable(node.argument);
                                case "ArrayExpression":
                                    return node.elements.every(function(element) {
                                        return element === null || _this.isAssignable(element);
                                    });
                                case "AssignmentExpression":
                                    return node.operator === "=";
                                case "ParenthesizedExpression":
                                    return this.isAssignable(node.expression);
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return !isBinding;
                                default:
                                    return false;
                            }
                        }
                    },
                    {
                        key: "toReferencedList",
                        value: function toReferencedList(exprList, isParenthesizedExpr) {
                            return exprList;
                        }
                    },
                    {
                        key: "toReferencedListDeep",
                        value: function toReferencedListDeep(exprList, isParenthesizedExpr) {
                            this.toReferencedList(exprList, isParenthesizedExpr);
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = exprList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var expr = _step.value;
                                    if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
                                        this.toReferencedListDeep(expr.elements);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "parseSpread",
                        value: function parseSpread(refExpressionErrors) {
                            var node = this.startNode();
                            this.next();
                            node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
                            return this.finishNode(node, "SpreadElement");
                        }
                    },
                    {
                        key: "parseRestBinding",
                        value: function parseRestBinding() {
                            var node = this.startNode();
                            this.next();
                            node.argument = this.parseBindingAtom();
                            return this.finishNode(node, "RestElement");
                        }
                    },
                    {
                        key: "parseBindingAtom",
                        value: function parseBindingAtom() {
                            switch(this.state.type){
                                case 0:
                                    {
                                        var node = this.startNode();
                                        this.next();
                                        node.elements = this.parseBindingList(3, 93, 1);
                                        return this.finishNode(node, "ArrayPattern");
                                    }
                                case 5:
                                    return this.parseObjectLike(8, true);
                            }
                            return this.parseIdentifier();
                        }
                    },
                    {
                        key: "parseBindingList",
                        value: function parseBindingList(close, closeCharCode, flags) {
                            var allowEmpty = flags & 1;
                            var elts = [];
                            var first = true;
                            while(!this.eat(close)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12);
                                }
                                if (allowEmpty && this.match(12)) {
                                    elts.push(null);
                                } else if (this.eat(close)) {
                                    break;
                                } else if (this.match(21)) {
                                    var rest = this.parseRestBinding();
                                    if (this.hasPlugin("flow") || flags & 2) {
                                        rest = this.parseFunctionParamType(rest);
                                    }
                                    elts.push(rest);
                                    if (!this.checkCommaAfterRest(closeCharCode)) {
                                        this.expect(close);
                                        break;
                                    }
                                } else {
                                    var decorators = [];
                                    if (this.match(26) && this.hasPlugin("decorators")) {
                                        this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
                                    }
                                    while(this.match(26)){
                                        decorators.push(this.parseDecorator());
                                    }
                                    elts.push(this.parseAssignableListItem(flags, decorators));
                                }
                            }
                            return elts;
                        }
                    },
                    {
                        key: "parseBindingRestProperty",
                        value: function parseBindingRestProperty(prop) {
                            this.next();
                            prop.argument = this.parseIdentifier();
                            this.checkCommaAfterRest(125);
                            return this.finishNode(prop, "RestElement");
                        }
                    },
                    {
                        key: "parseBindingProperty",
                        value: function parseBindingProperty() {
                            var _this_state = this.state, type = _this_state.type, startLoc = _this_state.startLoc;
                            if (type === 21) {
                                return this.parseBindingRestProperty(this.startNode());
                            }
                            var prop = this.startNode();
                            if (type === 138) {
                                this.expectPlugin("destructuringPrivate", startLoc);
                                this.classScope.usePrivateName(this.state.value, startLoc);
                                prop.key = this.parsePrivateName();
                            } else {
                                this.parsePropertyName(prop);
                            }
                            prop.method = false;
                            return this.parseObjPropValue(prop, startLoc, false, false, true, false);
                        }
                    },
                    {
                        key: "parseAssignableListItem",
                        value: function parseAssignableListItem(flags, decorators) {
                            var left = this.parseMaybeDefault();
                            if (this.hasPlugin("flow") || flags & 2) {
                                this.parseFunctionParamType(left);
                            }
                            var elt = this.parseMaybeDefault(left.loc.start, left);
                            if (decorators.length) {
                                left.decorators = decorators;
                            }
                            return elt;
                        }
                    },
                    {
                        key: "parseFunctionParamType",
                        value: function parseFunctionParamType(param) {
                            return param;
                        }
                    },
                    {
                        key: "parseMaybeDefault",
                        value: function parseMaybeDefault(startLoc, left) {
                            var _startLoc, _left;
                            (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
                            left = (_left = left) != null ? _left : this.parseBindingAtom();
                            if (!this.eat(29)) return left;
                            var node = this.startNodeAt(startLoc);
                            node.left = left;
                            node.right = this.parseMaybeAssignAllowIn();
                            return this.finishNode(node, "AssignmentPattern");
                        }
                    },
                    {
                        key: "isValidLVal",
                        value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                            switch(type){
                                case "AssignmentPattern":
                                    return "left";
                                case "RestElement":
                                    return "argument";
                                case "ObjectProperty":
                                    return "value";
                                case "ParenthesizedExpression":
                                    return "expression";
                                case "ArrayPattern":
                                    return "elements";
                                case "ObjectPattern":
                                    return "properties";
                            }
                            return false;
                        }
                    },
                    {
                        key: "isOptionalMemberExpression",
                        value: function isOptionalMemberExpression(expression) {
                            return expression.type === "OptionalMemberExpression";
                        }
                    },
                    {
                        key: "checkLVal",
                        value: function checkLVal(expression, ancestor) {
                            var binding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 64, checkClashes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, strictModeChanged = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, hasParenthesizedAncestor = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                            var _expression$extra;
                            var type = expression.type;
                            if (this.isObjectMethod(expression)) return;
                            var isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
                            if (isOptionalMemberExpression || type === "MemberExpression") {
                                if (isOptionalMemberExpression) {
                                    this.expectPlugin("optionalChainingAssign", expression.loc.start);
                                    if (ancestor.type !== "AssignmentExpression") {
                                        this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                                            ancestor: ancestor
                                        });
                                    }
                                }
                                if (binding !== 64) {
                                    this.raise(Errors.InvalidPropertyBindingPattern, expression);
                                }
                                return;
                            }
                            if (type === "Identifier") {
                                this.checkIdentifier(expression, binding, strictModeChanged);
                                var name = expression.name;
                                if (checkClashes) {
                                    if (checkClashes.has(name)) {
                                        this.raise(Errors.ParamDupe, expression);
                                    } else {
                                        checkClashes.add(name);
                                    }
                                }
                                return;
                            }
                            var validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
                            if (validity === true) return;
                            if (validity === false) {
                                var ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
                                this.raise(ParseErrorClass, expression, {
                                    ancestor: ancestor
                                });
                                return;
                            }
                            var key, isParenthesizedExpression;
                            if (typeof validity === "string") {
                                key = validity;
                                isParenthesizedExpression = type === "ParenthesizedExpression";
                            } else {
                                var ref;
                                ref = _sliced_to_array(validity, 2), key = ref[0], isParenthesizedExpression = ref[1], ref;
                            }
                            var nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
                                type: type
                            } : ancestor;
                            var val = expression[key];
                            if (Array.isArray(val)) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var child = _step.value;
                                        if (child) {
                                            this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            } else if (val) {
                                this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
                            }
                        }
                    },
                    {
                        key: "checkIdentifier",
                        value: function checkIdentifier(at, bindingType) {
                            var strictModeChanged = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
                                if (bindingType === 64) {
                                    this.raise(Errors.StrictEvalArguments, at, {
                                        referenceName: at.name
                                    });
                                } else {
                                    this.raise(Errors.StrictEvalArgumentsBinding, at, {
                                        bindingName: at.name
                                    });
                                }
                            }
                            if (bindingType & 8192 && at.name === "let") {
                                this.raise(Errors.LetInLexicalBinding, at);
                            }
                            if (!(bindingType & 64)) {
                                this.declareNameFromIdentifier(at, bindingType);
                            }
                        }
                    },
                    {
                        key: "declareNameFromIdentifier",
                        value: function declareNameFromIdentifier(identifier, binding) {
                            this.scope.declareName(identifier.name, binding, identifier.loc.start);
                        }
                    },
                    {
                        key: "checkToRestConversion",
                        value: function checkToRestConversion(node, allowPattern) {
                            switch(node.type){
                                case "ParenthesizedExpression":
                                    this.checkToRestConversion(node.expression, allowPattern);
                                    break;
                                case "Identifier":
                                case "MemberExpression":
                                    break;
                                case "ArrayExpression":
                                case "ObjectExpression":
                                    if (allowPattern) break;
                                default:
                                    this.raise(Errors.InvalidRestAssignmentPattern, node);
                            }
                        }
                    },
                    {
                        key: "checkCommaAfterRest",
                        value: function checkCommaAfterRest(close) {
                            if (!this.match(12)) {
                                return false;
                            }
                            this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
                            return true;
                        }
                    }
                ]);
                return LValParser;
            }(NodeUtils);
            function nonNull(x) {
                if (x == null) {
                    throw new Error("Unexpected ".concat(x, " value."));
                }
                return x;
            }
            function assert(x) {
                if (!x) {
                    throw new Error("Assert fail");
                }
            }
            var TSErrors = ParseErrorEnum(_templateObject3())({
                AbstractMethodHasImplementation: function(param) {
                    var methodName = param.methodName;
                    return "Method '".concat(methodName, "' cannot have an implementation because it is marked abstract.");
                },
                AbstractPropertyHasInitializer: function(param) {
                    var propertyName = param.propertyName;
                    return "Property '".concat(propertyName, "' cannot have an initializer because it is marked abstract.");
                },
                AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
                AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
                AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
                ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
                ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
                ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
                ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
                DeclareAccessor: function(param) {
                    var kind = param.kind;
                    return "'declare' is not allowed in ".concat(kind, "ters.");
                },
                DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
                DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
                DuplicateAccessibilityModifier: function(param) {
                    var modifier = param.modifier;
                    return "Accessibility modifier already seen.";
                },
                DuplicateModifier: function(param) {
                    var modifier = param.modifier;
                    return "Duplicate modifier: '".concat(modifier, "'.");
                },
                EmptyHeritageClauseType: function(param) {
                    var token = param.token;
                    return "'".concat(token, "' list cannot be empty.");
                },
                EmptyTypeArguments: "Type argument list cannot be empty.",
                EmptyTypeParameters: "Type parameter list cannot be empty.",
                ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
                ImportAliasHasImportType: "An import alias can not use 'import type'.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
                IncompatibleModifiers: function(param) {
                    var modifiers = param.modifiers;
                    return "'".concat(modifiers[0], "' modifier cannot be used with '").concat(modifiers[1], "' modifier.");
                },
                IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
                IndexSignatureHasAccessibility: function(param) {
                    var modifier = param.modifier;
                    return "Index signatures cannot have an accessibility modifier ('".concat(modifier, "').");
                },
                IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
                IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
                IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
                InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
                InvalidModifierOnTypeMember: function(param) {
                    var modifier = param.modifier;
                    return "'".concat(modifier, "' modifier cannot appear on a type member.");
                },
                InvalidModifierOnTypeParameter: function(param) {
                    var modifier = param.modifier;
                    return "'".concat(modifier, "' modifier cannot appear on a type parameter.");
                },
                InvalidModifierOnTypeParameterPositions: function(param) {
                    var modifier = param.modifier;
                    return "'".concat(modifier, "' modifier can only appear on a type parameter of a class, interface or type alias.");
                },
                InvalidModifiersOrder: function(param) {
                    var orderedModifiers = param.orderedModifiers;
                    return "'".concat(orderedModifiers[0], "' modifier must precede '").concat(orderedModifiers[1], "' modifier.");
                },
                InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
                InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
                MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
                NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
                NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
                OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
                OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
                PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
                PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
                PrivateElementHasAccessibility: function(param) {
                    var modifier = param.modifier;
                    return "Private elements cannot have an accessibility modifier ('".concat(modifier, "').");
                },
                ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
                ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
                ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
                SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
                SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
                SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
                SingleTypeParameterWithoutTrailingComma: function(param) {
                    var typeParameterName = param.typeParameterName;
                    return "Single type parameter ".concat(typeParameterName, " should have a trailing comma. Example usage: <").concat(typeParameterName, ",>.");
                },
                StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
                TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
                TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
                TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
                TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
                UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
                UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
                UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
                UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
                UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
                UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
                UnsupportedSignatureParameterKind: function(param) {
                    var type = param.type;
                    return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(type, ".");
                }
            });
            function keywordTypeFromName(value) {
                switch(value){
                    case "any":
                        return "TSAnyKeyword";
                    case "boolean":
                        return "TSBooleanKeyword";
                    case "bigint":
                        return "TSBigIntKeyword";
                    case "never":
                        return "TSNeverKeyword";
                    case "number":
                        return "TSNumberKeyword";
                    case "object":
                        return "TSObjectKeyword";
                    case "string":
                        return "TSStringKeyword";
                    case "symbol":
                        return "TSSymbolKeyword";
                    case "undefined":
                        return "TSUndefinedKeyword";
                    case "unknown":
                        return "TSUnknownKeyword";
                    default:
                        return void 0;
                }
            }
            function tsIsAccessModifier(modifier) {
                return modifier === "private" || modifier === "public" || modifier === "protected";
            }
            function tsIsVarianceAnnotations(modifier) {
                return modifier === "in" || modifier === "out";
            }
            var typescript = function(superClass) {
                var TypeScriptParserMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(TypeScriptParserMixin, superClass);
                    function TypeScriptParserMixin() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        _class_call_check(this, TypeScriptParserMixin);
                        var _this;
                        _this = _call_super(this, TypeScriptParserMixin, _to_consumable_array(args));
                        _this.tsParseInOutModifiers = _this.tsParseModifiers.bind(_this, {
                            allowedModifiers: [
                                "in",
                                "out"
                            ],
                            disallowedModifiers: [
                                "const",
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
                        });
                        _this.tsParseConstModifier = _this.tsParseModifiers.bind(_this, {
                            allowedModifiers: [
                                "const"
                            ],
                            disallowedModifiers: [
                                "in",
                                "out"
                            ],
                            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
                        });
                        _this.tsParseInOutConstModifiers = _this.tsParseModifiers.bind(_this, {
                            allowedModifiers: [
                                "in",
                                "out",
                                "const"
                            ],
                            disallowedModifiers: [
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
                        });
                        return _this;
                    }
                    _create_class(TypeScriptParserMixin, [
                        {
                            key: "getScopeHandler",
                            value: function getScopeHandler() {
                                return TypeScriptScopeHandler;
                            }
                        },
                        {
                            key: "tsIsIdentifier",
                            value: function tsIsIdentifier() {
                                return tokenIsIdentifier(this.state.type);
                            }
                        },
                        {
                            key: "tsTokenCanFollowModifier",
                            value: function tsTokenCanFollowModifier() {
                                return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName();
                            }
                        },
                        {
                            key: "tsNextTokenOnSameLineAndCanFollowModifier",
                            value: function tsNextTokenOnSameLineAndCanFollowModifier() {
                                this.next();
                                if (this.hasPrecedingLineBreak()) {
                                    return false;
                                }
                                return this.tsTokenCanFollowModifier();
                            }
                        },
                        {
                            key: "tsNextTokenCanFollowModifier",
                            value: function tsNextTokenCanFollowModifier() {
                                if (this.match(106)) {
                                    this.next();
                                    return this.tsTokenCanFollowModifier();
                                }
                                return this.tsNextTokenOnSameLineAndCanFollowModifier();
                            }
                        },
                        {
                            key: "tsParseModifier",
                            value: function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
                                if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
                                    return void 0;
                                }
                                var modifier = this.state.value;
                                if (allowedModifiers.includes(modifier)) {
                                    if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
                                        return void 0;
                                    }
                                    if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                                        return modifier;
                                    }
                                }
                                return void 0;
                            }
                        },
                        {
                            key: "tsParseModifiers",
                            value: function tsParseModifiers(param, modified) {
                                var _this = this;
                                var allowedModifiers = param.allowedModifiers, disallowedModifiers = param.disallowedModifiers, stopOnStartOfClassStaticBlock = param.stopOnStartOfClassStaticBlock, _param_errorTemplate = param.errorTemplate, errorTemplate = _param_errorTemplate === void 0 ? TSErrors.InvalidModifierOnTypeMember : _param_errorTemplate;
                                var enforceOrder = function(loc, modifier, before, after) {
                                    if (modifier === before && modified[after]) {
                                        _this.raise(TSErrors.InvalidModifiersOrder, loc, {
                                            orderedModifiers: [
                                                before,
                                                after
                                            ]
                                        });
                                    }
                                };
                                var incompatible = function(loc, modifier, mod1, mod2) {
                                    if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
                                        _this.raise(TSErrors.IncompatibleModifiers, loc, {
                                            modifiers: [
                                                mod1,
                                                mod2
                                            ]
                                        });
                                    }
                                };
                                for(;;){
                                    var startLoc = this.state.startLoc;
                                    var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
                                    if (!modifier) break;
                                    if (tsIsAccessModifier(modifier)) {
                                        if (modified.accessibility) {
                                            this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                                                modifier: modifier
                                            });
                                        } else {
                                            enforceOrder(startLoc, modifier, modifier, "override");
                                            enforceOrder(startLoc, modifier, modifier, "static");
                                            enforceOrder(startLoc, modifier, modifier, "readonly");
                                            modified.accessibility = modifier;
                                        }
                                    } else if (tsIsVarianceAnnotations(modifier)) {
                                        if (modified[modifier]) {
                                            this.raise(TSErrors.DuplicateModifier, startLoc, {
                                                modifier: modifier
                                            });
                                        }
                                        modified[modifier] = true;
                                        enforceOrder(startLoc, modifier, "in", "out");
                                    } else {
                                        if (hasOwnProperty.call(modified, modifier)) {
                                            this.raise(TSErrors.DuplicateModifier, startLoc, {
                                                modifier: modifier
                                            });
                                        } else {
                                            enforceOrder(startLoc, modifier, "static", "readonly");
                                            enforceOrder(startLoc, modifier, "static", "override");
                                            enforceOrder(startLoc, modifier, "override", "readonly");
                                            enforceOrder(startLoc, modifier, "abstract", "override");
                                            incompatible(startLoc, modifier, "declare", "override");
                                            incompatible(startLoc, modifier, "static", "abstract");
                                        }
                                        modified[modifier] = true;
                                    }
                                    if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
                                        this.raise(errorTemplate, startLoc, {
                                            modifier: modifier
                                        });
                                    }
                                }
                            }
                        },
                        {
                            key: "tsIsListTerminator",
                            value: function tsIsListTerminator(kind) {
                                switch(kind){
                                    case "EnumMembers":
                                    case "TypeMembers":
                                        return this.match(8);
                                    case "HeritageClauseElement":
                                        return this.match(5);
                                    case "TupleElementTypes":
                                        return this.match(3);
                                    case "TypeParametersOrArguments":
                                        return this.match(48);
                                }
                            }
                        },
                        {
                            key: "tsParseList",
                            value: function tsParseList(kind, parseElement) {
                                var result = [];
                                while(!this.tsIsListTerminator(kind)){
                                    result.push(parseElement());
                                }
                                return result;
                            }
                        },
                        {
                            key: "tsParseDelimitedList",
                            value: function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
                                return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
                            }
                        },
                        {
                            key: "tsParseDelimitedListWorker",
                            value: function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
                                var result = [];
                                var trailingCommaPos = -1;
                                for(;;){
                                    if (this.tsIsListTerminator(kind)) {
                                        break;
                                    }
                                    trailingCommaPos = -1;
                                    var element = parseElement();
                                    if (element == null) {
                                        return void 0;
                                    }
                                    result.push(element);
                                    if (this.eat(12)) {
                                        trailingCommaPos = this.state.lastTokStartLoc.index;
                                        continue;
                                    }
                                    if (this.tsIsListTerminator(kind)) {
                                        break;
                                    }
                                    if (expectSuccess) {
                                        this.expect(12);
                                    }
                                    return void 0;
                                }
                                if (refTrailingCommaPos) {
                                    refTrailingCommaPos.value = trailingCommaPos;
                                }
                                return result;
                            }
                        },
                        {
                            key: "tsParseBracketedList",
                            value: function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
                                if (!skipFirstToken) {
                                    if (bracket) {
                                        this.expect(0);
                                    } else {
                                        this.expect(47);
                                    }
                                }
                                var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
                                if (bracket) {
                                    this.expect(3);
                                } else {
                                    this.expect(48);
                                }
                                return result;
                            }
                        },
                        {
                            key: "tsParseImportType",
                            value: function tsParseImportType() {
                                var node = this.startNode();
                                this.expect(83);
                                this.expect(10);
                                if (!this.match(133)) {
                                    this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
                                }
                                node.argument = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                                if (this.eat(12) && !this.match(11)) {
                                    node.options = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssignAllowIn", this).call(this);
                                    this.eat(12);
                                } else {
                                    node.options = null;
                                }
                                this.expect(11);
                                if (this.eat(16)) {
                                    node.qualifier = this.tsParseEntityName();
                                }
                                if (this.match(47)) {
                                    node.typeParameters = this.tsParseTypeArguments();
                                }
                                return this.finishNode(node, "TSImportType");
                            }
                        },
                        {
                            key: "tsParseEntityName",
                            value: function tsParseEntityName() {
                                var allowReservedWords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                                var entity = this.parseIdentifier(allowReservedWords);
                                while(this.eat(16)){
                                    var node = this.startNodeAtNode(entity);
                                    node.left = entity;
                                    node.right = this.parseIdentifier(allowReservedWords);
                                    entity = this.finishNode(node, "TSQualifiedName");
                                }
                                return entity;
                            }
                        },
                        {
                            key: "tsParseTypeReference",
                            value: function tsParseTypeReference() {
                                var node = this.startNode();
                                node.typeName = this.tsParseEntityName();
                                if (!this.hasPrecedingLineBreak() && this.match(47)) {
                                    node.typeParameters = this.tsParseTypeArguments();
                                }
                                return this.finishNode(node, "TSTypeReference");
                            }
                        },
                        {
                            key: "tsParseThisTypePredicate",
                            value: function tsParseThisTypePredicate(lhs) {
                                this.next();
                                var node = this.startNodeAtNode(lhs);
                                node.parameterName = lhs;
                                node.typeAnnotation = this.tsParseTypeAnnotation(false);
                                node.asserts = false;
                                return this.finishNode(node, "TSTypePredicate");
                            }
                        },
                        {
                            key: "tsParseThisTypeNode",
                            value: function tsParseThisTypeNode() {
                                var node = this.startNode();
                                this.next();
                                return this.finishNode(node, "TSThisType");
                            }
                        },
                        {
                            key: "tsParseTypeQuery",
                            value: function tsParseTypeQuery() {
                                var node = this.startNode();
                                this.expect(87);
                                if (this.match(83)) {
                                    node.exprName = this.tsParseImportType();
                                } else {
                                    node.exprName = this.tsParseEntityName();
                                }
                                if (!this.hasPrecedingLineBreak() && this.match(47)) {
                                    node.typeParameters = this.tsParseTypeArguments();
                                }
                                return this.finishNode(node, "TSTypeQuery");
                            }
                        },
                        {
                            key: "tsParseTypeParameter",
                            value: function tsParseTypeParameter(parseModifiers) {
                                var node = this.startNode();
                                parseModifiers(node);
                                node.name = this.tsParseTypeParameterName();
                                node.constraint = this.tsEatThenParseType(81);
                                node.default = this.tsEatThenParseType(29);
                                return this.finishNode(node, "TSTypeParameter");
                            }
                        },
                        {
                            key: "tsTryParseTypeParameters",
                            value: function tsTryParseTypeParameters(parseModifiers) {
                                if (this.match(47)) {
                                    return this.tsParseTypeParameters(parseModifiers);
                                }
                            }
                        },
                        {
                            key: "tsParseTypeParameters",
                            value: function tsParseTypeParameters(parseModifiers) {
                                var node = this.startNode();
                                if (this.match(47) || this.match(142)) {
                                    this.next();
                                } else {
                                    this.unexpected();
                                }
                                var refTrailingCommaPos = {
                                    value: -1
                                };
                                node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
                                if (node.params.length === 0) {
                                    this.raise(TSErrors.EmptyTypeParameters, node);
                                }
                                if (refTrailingCommaPos.value !== -1) {
                                    this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
                                }
                                return this.finishNode(node, "TSTypeParameterDeclaration");
                            }
                        },
                        {
                            key: "tsFillSignature",
                            value: function tsFillSignature(returnToken, signature) {
                                var returnTokenRequired = returnToken === 19;
                                var paramsKey = "parameters";
                                var returnTypeKey = "typeAnnotation";
                                signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                this.expect(10);
                                signature[paramsKey] = this.tsParseBindingListForSignature();
                                if (returnTokenRequired) {
                                    signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
                                } else if (this.match(returnToken)) {
                                    signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
                                }
                            }
                        },
                        {
                            key: "tsParseBindingListForSignature",
                            value: function tsParseBindingListForSignature() {
                                var list = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 11, 41, 2);
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var pattern = _step.value;
                                        var type = pattern.type;
                                        if (type === "AssignmentPattern" || type === "TSParameterProperty") {
                                            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
                                                type: type
                                            });
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return list;
                            }
                        },
                        {
                            key: "tsParseTypeMemberSemicolon",
                            value: function tsParseTypeMemberSemicolon() {
                                if (!this.eat(12) && !this.isLineTerminator()) {
                                    this.expect(13);
                                }
                            }
                        },
                        {
                            key: "tsParseSignatureMember",
                            value: function tsParseSignatureMember(kind, node) {
                                this.tsFillSignature(14, node);
                                this.tsParseTypeMemberSemicolon();
                                return this.finishNode(node, kind);
                            }
                        },
                        {
                            key: "tsIsUnambiguouslyIndexSignature",
                            value: function tsIsUnambiguouslyIndexSignature() {
                                this.next();
                                if (tokenIsIdentifier(this.state.type)) {
                                    this.next();
                                    return this.match(14);
                                }
                                return false;
                            }
                        },
                        {
                            key: "tsTryParseIndexSignature",
                            value: function tsTryParseIndexSignature(node) {
                                if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                                    return;
                                }
                                this.expect(0);
                                var id = this.parseIdentifier();
                                id.typeAnnotation = this.tsParseTypeAnnotation();
                                this.resetEndLocation(id);
                                this.expect(3);
                                node.parameters = [
                                    id
                                ];
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) node.typeAnnotation = type;
                                this.tsParseTypeMemberSemicolon();
                                return this.finishNode(node, "TSIndexSignature");
                            }
                        },
                        {
                            key: "tsParsePropertyOrMethodSignature",
                            value: function tsParsePropertyOrMethodSignature(node, readonly) {
                                if (this.eat(17)) node.optional = true;
                                var nodeAny = node;
                                if (this.match(10) || this.match(47)) {
                                    if (readonly) {
                                        this.raise(TSErrors.ReadonlyForMethodSignature, node);
                                    }
                                    var method = nodeAny;
                                    if (method.kind && this.match(47)) {
                                        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
                                    }
                                    this.tsFillSignature(14, method);
                                    this.tsParseTypeMemberSemicolon();
                                    var paramsKey = "parameters";
                                    var returnTypeKey = "typeAnnotation";
                                    if (method.kind === "get") {
                                        if (method[paramsKey].length > 0) {
                                            this.raise(Errors.BadGetterArity, this.state.curPosition());
                                            if (this.isThisParam(method[paramsKey][0])) {
                                                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                            }
                                        }
                                    } else if (method.kind === "set") {
                                        if (method[paramsKey].length !== 1) {
                                            this.raise(Errors.BadSetterArity, this.state.curPosition());
                                        } else {
                                            var firstParameter = method[paramsKey][0];
                                            if (this.isThisParam(firstParameter)) {
                                                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
                                            }
                                            if (firstParameter.type === "Identifier" && firstParameter.optional) {
                                                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
                                            }
                                            if (firstParameter.type === "RestElement") {
                                                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                                            }
                                        }
                                        if (method[returnTypeKey]) {
                                            this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
                                        }
                                    } else {
                                        method.kind = "method";
                                    }
                                    return this.finishNode(method, "TSMethodSignature");
                                } else {
                                    var property = nodeAny;
                                    if (readonly) property.readonly = true;
                                    var type = this.tsTryParseTypeAnnotation();
                                    if (type) property.typeAnnotation = type;
                                    this.tsParseTypeMemberSemicolon();
                                    return this.finishNode(property, "TSPropertySignature");
                                }
                            }
                        },
                        {
                            key: "tsParseTypeMember",
                            value: function tsParseTypeMember() {
                                var node = this.startNode();
                                if (this.match(10) || this.match(47)) {
                                    return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
                                }
                                if (this.match(77)) {
                                    var id = this.startNode();
                                    this.next();
                                    if (this.match(10) || this.match(47)) {
                                        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
                                    } else {
                                        node.key = this.createIdentifier(id, "new");
                                        return this.tsParsePropertyOrMethodSignature(node, false);
                                    }
                                }
                                this.tsParseModifiers({
                                    allowedModifiers: [
                                        "readonly"
                                    ],
                                    disallowedModifiers: [
                                        "declare",
                                        "abstract",
                                        "private",
                                        "protected",
                                        "public",
                                        "static",
                                        "override"
                                    ]
                                }, node);
                                var idx = this.tsTryParseIndexSignature(node);
                                if (idx) {
                                    return idx;
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);
                                if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
                                    node.kind = node.key.name;
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parsePropertyName", this).call(this, node);
                                }
                                return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
                            }
                        },
                        {
                            key: "tsParseTypeLiteral",
                            value: function tsParseTypeLiteral() {
                                var node = this.startNode();
                                node.members = this.tsParseObjectTypeMembers();
                                return this.finishNode(node, "TSTypeLiteral");
                            }
                        },
                        {
                            key: "tsParseObjectTypeMembers",
                            value: function tsParseObjectTypeMembers() {
                                this.expect(5);
                                var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                                this.expect(8);
                                return members;
                            }
                        },
                        {
                            key: "tsIsStartOfMappedType",
                            value: function tsIsStartOfMappedType() {
                                this.next();
                                if (this.eat(53)) {
                                    return this.isContextual(122);
                                }
                                if (this.isContextual(122)) {
                                    this.next();
                                }
                                if (!this.match(0)) {
                                    return false;
                                }
                                this.next();
                                if (!this.tsIsIdentifier()) {
                                    return false;
                                }
                                this.next();
                                return this.match(58);
                            }
                        },
                        {
                            key: "tsParseMappedType",
                            value: function tsParseMappedType() {
                                var node = this.startNode();
                                this.expect(5);
                                if (this.match(53)) {
                                    node.readonly = this.state.value;
                                    this.next();
                                    this.expectContextual(122);
                                } else if (this.eatContextual(122)) {
                                    node.readonly = true;
                                }
                                this.expect(0);
                                {
                                    var typeParameter = this.startNode();
                                    typeParameter.name = this.tsParseTypeParameterName();
                                    typeParameter.constraint = this.tsExpectThenParseType(58);
                                    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
                                }
                                node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
                                this.expect(3);
                                if (this.match(53)) {
                                    node.optional = this.state.value;
                                    this.next();
                                    this.expect(17);
                                } else if (this.eat(17)) {
                                    node.optional = true;
                                }
                                node.typeAnnotation = this.tsTryParseType();
                                this.semicolon();
                                this.expect(8);
                                return this.finishNode(node, "TSMappedType");
                            }
                        },
                        {
                            key: "tsParseTupleType",
                            value: function tsParseTupleType() {
                                var _this = this;
                                var node = this.startNode();
                                node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                                var seenOptionalElement = false;
                                node.elementTypes.forEach(function(elementNode) {
                                    var type = elementNode.type;
                                    if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
                                        _this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
                                    }
                                    seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
                                });
                                return this.finishNode(node, "TSTupleType");
                            }
                        },
                        {
                            key: "tsParseTupleElementType",
                            value: function tsParseTupleElementType() {
                                var startLoc = this.state.startLoc;
                                var rest = this.eat(21);
                                var labeled;
                                var label;
                                var optional;
                                var type;
                                var isWord = tokenIsKeywordOrIdentifier(this.state.type);
                                var chAfterWord = isWord ? this.lookaheadCharCode() : null;
                                if (chAfterWord === 58) {
                                    labeled = true;
                                    optional = false;
                                    label = this.parseIdentifier(true);
                                    this.expect(14);
                                    type = this.tsParseType();
                                } else if (chAfterWord === 63) {
                                    optional = true;
                                    var startLoc2 = this.state.startLoc;
                                    var wordName = this.state.value;
                                    var typeOrLabel = this.tsParseNonArrayType();
                                    if (this.lookaheadCharCode() === 58) {
                                        labeled = true;
                                        label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
                                        this.expect(17);
                                        this.expect(14);
                                        type = this.tsParseType();
                                    } else {
                                        labeled = false;
                                        type = typeOrLabel;
                                        this.expect(17);
                                    }
                                } else {
                                    type = this.tsParseType();
                                    optional = this.eat(17);
                                    labeled = this.eat(14);
                                }
                                if (labeled) {
                                    var labeledNode;
                                    if (label) {
                                        labeledNode = this.startNodeAtNode(label);
                                        labeledNode.optional = optional;
                                        labeledNode.label = label;
                                        labeledNode.elementType = type;
                                        if (this.eat(17)) {
                                            labeledNode.optional = true;
                                            this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
                                        }
                                    } else {
                                        labeledNode = this.startNodeAtNode(type);
                                        labeledNode.optional = optional;
                                        this.raise(TSErrors.InvalidTupleMemberLabel, type);
                                        labeledNode.label = type;
                                        labeledNode.elementType = this.tsParseType();
                                    }
                                    type = this.finishNode(labeledNode, "TSNamedTupleMember");
                                } else if (optional) {
                                    var optionalTypeNode = this.startNodeAtNode(type);
                                    optionalTypeNode.typeAnnotation = type;
                                    type = this.finishNode(optionalTypeNode, "TSOptionalType");
                                }
                                if (rest) {
                                    var restNode = this.startNodeAt(startLoc);
                                    restNode.typeAnnotation = type;
                                    type = this.finishNode(restNode, "TSRestType");
                                }
                                return type;
                            }
                        },
                        {
                            key: "tsParseParenthesizedType",
                            value: function tsParseParenthesizedType() {
                                var node = this.startNode();
                                this.expect(10);
                                node.typeAnnotation = this.tsParseType();
                                this.expect(11);
                                return this.finishNode(node, "TSParenthesizedType");
                            }
                        },
                        {
                            key: "tsParseFunctionOrConstructorType",
                            value: function tsParseFunctionOrConstructorType(type, abstract) {
                                var _this = this;
                                var node = this.startNode();
                                if (type === "TSConstructorType") {
                                    node.abstract = !!abstract;
                                    if (abstract) this.next();
                                    this.next();
                                }
                                this.tsInAllowConditionalTypesContext(function() {
                                    return _this.tsFillSignature(19, node);
                                });
                                return this.finishNode(node, type);
                            }
                        },
                        {
                            key: "tsParseLiteralTypeNode",
                            value: function tsParseLiteralTypeNode() {
                                var node = this.startNode();
                                switch(this.state.type){
                                    case 134:
                                    case 135:
                                    case 133:
                                    case 85:
                                    case 86:
                                        node.literal = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                                        break;
                                    default:
                                        this.unexpected();
                                }
                                return this.finishNode(node, "TSLiteralType");
                            }
                        },
                        {
                            key: "tsParseTemplateLiteralType",
                            value: function tsParseTemplateLiteralType() {
                                var node = this.startNode();
                                node.literal = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTemplate", this).call(this, false);
                                return this.finishNode(node, "TSLiteralType");
                            }
                        },
                        {
                            key: "parseTemplateSubstitution",
                            value: function parseTemplateSubstitution() {
                                if (this.state.inType) return this.tsParseType();
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTemplateSubstitution", this).call(this);
                            }
                        },
                        {
                            key: "tsParseThisTypeOrThisTypePredicate",
                            value: function tsParseThisTypeOrThisTypePredicate() {
                                var thisKeyword = this.tsParseThisTypeNode();
                                if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                                    return this.tsParseThisTypePredicate(thisKeyword);
                                } else {
                                    return thisKeyword;
                                }
                            }
                        },
                        {
                            key: "tsParseNonArrayType",
                            value: function tsParseNonArrayType() {
                                switch(this.state.type){
                                    case 133:
                                    case 134:
                                    case 135:
                                    case 85:
                                    case 86:
                                        return this.tsParseLiteralTypeNode();
                                    case 53:
                                        if (this.state.value === "-") {
                                            var node = this.startNode();
                                            var nextToken = this.lookahead();
                                            if (nextToken.type !== 134 && nextToken.type !== 135) {
                                                this.unexpected();
                                            }
                                            node.literal = this.parseMaybeUnary();
                                            return this.finishNode(node, "TSLiteralType");
                                        }
                                        break;
                                    case 78:
                                        return this.tsParseThisTypeOrThisTypePredicate();
                                    case 87:
                                        return this.tsParseTypeQuery();
                                    case 83:
                                        return this.tsParseImportType();
                                    case 5:
                                        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                                    case 0:
                                        return this.tsParseTupleType();
                                    case 10:
                                        return this.tsParseParenthesizedType();
                                    case 25:
                                    case 24:
                                        return this.tsParseTemplateLiteralType();
                                    default:
                                        {
                                            var type = this.state.type;
                                            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                                                var nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                                                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                                                    var node1 = this.startNode();
                                                    this.next();
                                                    return this.finishNode(node1, nodeType);
                                                }
                                                return this.tsParseTypeReference();
                                            }
                                        }
                                }
                                this.unexpected();
                            }
                        },
                        {
                            key: "tsParseArrayTypeOrHigher",
                            value: function tsParseArrayTypeOrHigher() {
                                var type = this.tsParseNonArrayType();
                                while(!this.hasPrecedingLineBreak() && this.eat(0)){
                                    if (this.match(3)) {
                                        var node = this.startNodeAtNode(type);
                                        node.elementType = type;
                                        this.expect(3);
                                        type = this.finishNode(node, "TSArrayType");
                                    } else {
                                        var node1 = this.startNodeAtNode(type);
                                        node1.objectType = type;
                                        node1.indexType = this.tsParseType();
                                        this.expect(3);
                                        type = this.finishNode(node1, "TSIndexedAccessType");
                                    }
                                }
                                return type;
                            }
                        },
                        {
                            key: "tsParseTypeOperator",
                            value: function tsParseTypeOperator() {
                                var node = this.startNode();
                                var operator = this.state.value;
                                this.next();
                                node.operator = operator;
                                node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                                if (operator === "readonly") {
                                    this.tsCheckTypeAnnotationForReadOnly(node);
                                }
                                return this.finishNode(node, "TSTypeOperator");
                            }
                        },
                        {
                            key: "tsCheckTypeAnnotationForReadOnly",
                            value: function tsCheckTypeAnnotationForReadOnly(node) {
                                switch(node.typeAnnotation.type){
                                    case "TSTupleType":
                                    case "TSArrayType":
                                        return;
                                    default:
                                        this.raise(TSErrors.UnexpectedReadonly, node);
                                }
                            }
                        },
                        {
                            key: "tsParseInferType",
                            value: function tsParseInferType() {
                                var _this = this;
                                var node = this.startNode();
                                this.expectContextual(115);
                                var typeParameter = this.startNode();
                                typeParameter.name = this.tsParseTypeParameterName();
                                typeParameter.constraint = this.tsTryParse(function() {
                                    return _this.tsParseConstraintForInferType();
                                });
                                node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
                                return this.finishNode(node, "TSInferType");
                            }
                        },
                        {
                            key: "tsParseConstraintForInferType",
                            value: function tsParseConstraintForInferType() {
                                var _this = this;
                                if (this.eat(81)) {
                                    var constraint = this.tsInDisallowConditionalTypesContext(function() {
                                        return _this.tsParseType();
                                    });
                                    if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                                        return constraint;
                                    }
                                }
                            }
                        },
                        {
                            key: "tsParseTypeOperatorOrHigher",
                            value: function tsParseTypeOperatorOrHigher() {
                                var _this = this;
                                var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
                                return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function() {
                                    return _this.tsParseArrayTypeOrHigher();
                                });
                            }
                        },
                        {
                            key: "tsParseUnionOrIntersectionType",
                            value: function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
                                var node = this.startNode();
                                var hasLeadingOperator = this.eat(operator);
                                var types2 = [];
                                do {
                                    types2.push(parseConstituentType());
                                }while (this.eat(operator));
                                if (types2.length === 1 && !hasLeadingOperator) {
                                    return types2[0];
                                }
                                node.types = types2;
                                return this.finishNode(node, kind);
                            }
                        },
                        {
                            key: "tsParseIntersectionTypeOrHigher",
                            value: function tsParseIntersectionTypeOrHigher() {
                                return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
                            }
                        },
                        {
                            key: "tsParseUnionTypeOrHigher",
                            value: function tsParseUnionTypeOrHigher() {
                                return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
                            }
                        },
                        {
                            key: "tsIsStartOfFunctionType",
                            value: function tsIsStartOfFunctionType() {
                                if (this.match(47)) {
                                    return true;
                                }
                                return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                            }
                        },
                        {
                            key: "tsSkipParameterStart",
                            value: function tsSkipParameterStart() {
                                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                    this.next();
                                    return true;
                                }
                                if (this.match(5)) {
                                    var errors = this.state.errors;
                                    var previousErrorCount = errors.length;
                                    try {
                                        this.parseObjectLike(8, true);
                                        return errors.length === previousErrorCount;
                                    } catch (_unused) {
                                        return false;
                                    }
                                }
                                if (this.match(0)) {
                                    this.next();
                                    var errors1 = this.state.errors;
                                    var previousErrorCount1 = errors1.length;
                                    try {
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingList", this).call(this, 3, 93, 1);
                                        return errors1.length === previousErrorCount1;
                                    } catch (_unused2) {
                                        return false;
                                    }
                                }
                                return false;
                            }
                        },
                        {
                            key: "tsIsUnambiguouslyStartOfFunctionType",
                            value: function tsIsUnambiguouslyStartOfFunctionType() {
                                this.next();
                                if (this.match(11) || this.match(21)) {
                                    return true;
                                }
                                if (this.tsSkipParameterStart()) {
                                    if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                                        return true;
                                    }
                                    if (this.match(11)) {
                                        this.next();
                                        if (this.match(19)) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }
                        },
                        {
                            key: "tsParseTypeOrTypePredicateAnnotation",
                            value: function tsParseTypeOrTypePredicateAnnotation(returnToken) {
                                var _this = this;
                                return this.tsInType(function() {
                                    var t = _this.startNode();
                                    _this.expect(returnToken);
                                    var node = _this.startNode();
                                    var asserts = !!_this.tsTryParse(_this.tsParseTypePredicateAsserts.bind(_this));
                                    if (asserts && _this.match(78)) {
                                        var thisTypePredicate = _this.tsParseThisTypeOrThisTypePredicate();
                                        if (thisTypePredicate.type === "TSThisType") {
                                            node.parameterName = thisTypePredicate;
                                            node.asserts = true;
                                            node.typeAnnotation = null;
                                            thisTypePredicate = _this.finishNode(node, "TSTypePredicate");
                                        } else {
                                            _this.resetStartLocationFromNode(thisTypePredicate, node);
                                            thisTypePredicate.asserts = true;
                                        }
                                        t.typeAnnotation = thisTypePredicate;
                                        return _this.finishNode(t, "TSTypeAnnotation");
                                    }
                                    var typePredicateVariable = _this.tsIsIdentifier() && _this.tsTryParse(_this.tsParseTypePredicatePrefix.bind(_this));
                                    if (!typePredicateVariable) {
                                        if (!asserts) {
                                            return _this.tsParseTypeAnnotation(false, t);
                                        }
                                        node.parameterName = _this.parseIdentifier();
                                        node.asserts = asserts;
                                        node.typeAnnotation = null;
                                        t.typeAnnotation = _this.finishNode(node, "TSTypePredicate");
                                        return _this.finishNode(t, "TSTypeAnnotation");
                                    }
                                    var type = _this.tsParseTypeAnnotation(false);
                                    node.parameterName = typePredicateVariable;
                                    node.typeAnnotation = type;
                                    node.asserts = asserts;
                                    t.typeAnnotation = _this.finishNode(node, "TSTypePredicate");
                                    return _this.finishNode(t, "TSTypeAnnotation");
                                });
                            }
                        },
                        {
                            key: "tsTryParseTypeOrTypePredicateAnnotation",
                            value: function tsTryParseTypeOrTypePredicateAnnotation() {
                                if (this.match(14)) {
                                    return this.tsParseTypeOrTypePredicateAnnotation(14);
                                }
                            }
                        },
                        {
                            key: "tsTryParseTypeAnnotation",
                            value: function tsTryParseTypeAnnotation() {
                                if (this.match(14)) {
                                    return this.tsParseTypeAnnotation();
                                }
                            }
                        },
                        {
                            key: "tsTryParseType",
                            value: function tsTryParseType() {
                                return this.tsEatThenParseType(14);
                            }
                        },
                        {
                            key: "tsParseTypePredicatePrefix",
                            value: function tsParseTypePredicatePrefix() {
                                var id = this.parseIdentifier();
                                if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
                                    this.next();
                                    return id;
                                }
                            }
                        },
                        {
                            key: "tsParseTypePredicateAsserts",
                            value: function tsParseTypePredicateAsserts() {
                                if (this.state.type !== 109) {
                                    return false;
                                }
                                var containsEsc = this.state.containsEsc;
                                this.next();
                                if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
                                    return false;
                                }
                                if (containsEsc) {
                                    this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
                                        reservedWord: "asserts"
                                    });
                                }
                                return true;
                            }
                        },
                        {
                            key: "tsParseTypeAnnotation",
                            value: function tsParseTypeAnnotation() {
                                var _this = this;
                                var eatColon = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
                                this.tsInType(function() {
                                    if (eatColon) _this.expect(14);
                                    t.typeAnnotation = _this.tsParseType();
                                });
                                return this.finishNode(t, "TSTypeAnnotation");
                            }
                        },
                        {
                            key: "tsParseType",
                            value: function tsParseType() {
                                var _this = this;
                                assert(this.state.inType);
                                var type = this.tsParseNonConditionalType();
                                if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
                                    return type;
                                }
                                var node = this.startNodeAtNode(type);
                                node.checkType = type;
                                node.extendsType = this.tsInDisallowConditionalTypesContext(function() {
                                    return _this.tsParseNonConditionalType();
                                });
                                this.expect(17);
                                node.trueType = this.tsInAllowConditionalTypesContext(function() {
                                    return _this.tsParseType();
                                });
                                this.expect(14);
                                node.falseType = this.tsInAllowConditionalTypesContext(function() {
                                    return _this.tsParseType();
                                });
                                return this.finishNode(node, "TSConditionalType");
                            }
                        },
                        {
                            key: "isAbstractConstructorSignature",
                            value: function isAbstractConstructorSignature() {
                                return this.isContextual(124) && this.lookahead().type === 77;
                            }
                        },
                        {
                            key: "tsParseNonConditionalType",
                            value: function tsParseNonConditionalType() {
                                if (this.tsIsStartOfFunctionType()) {
                                    return this.tsParseFunctionOrConstructorType("TSFunctionType");
                                }
                                if (this.match(77)) {
                                    return this.tsParseFunctionOrConstructorType("TSConstructorType");
                                } else if (this.isAbstractConstructorSignature()) {
                                    return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
                                }
                                return this.tsParseUnionTypeOrHigher();
                            }
                        },
                        {
                            key: "tsParseTypeAssertion",
                            value: function tsParseTypeAssertion() {
                                var _this = this;
                                if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                                    this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
                                }
                                var node = this.startNode();
                                node.typeAnnotation = this.tsInType(function() {
                                    _this.next();
                                    return _this.match(75) ? _this.tsParseTypeReference() : _this.tsParseType();
                                });
                                this.expect(48);
                                node.expression = this.parseMaybeUnary();
                                return this.finishNode(node, "TSTypeAssertion");
                            }
                        },
                        {
                            key: "tsParseHeritageClause",
                            value: function tsParseHeritageClause(token) {
                                var _this = this;
                                var originalStartLoc = this.state.startLoc;
                                var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", function() {
                                    var node = _this.startNode();
                                    node.expression = _this.tsParseEntityName();
                                    if (_this.match(47)) {
                                        node.typeParameters = _this.tsParseTypeArguments();
                                    }
                                    return _this.finishNode(node, "TSExpressionWithTypeArguments");
                                });
                                if (!delimitedList.length) {
                                    this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
                                        token: token
                                    });
                                }
                                return delimitedList;
                            }
                        },
                        {
                            key: "tsParseInterfaceDeclaration",
                            value: function tsParseInterfaceDeclaration(node) {
                                var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                                if (this.hasFollowingLineBreak()) return null;
                                this.expectContextual(129);
                                if (properties.declare) node.declare = true;
                                if (tokenIsIdentifier(this.state.type)) {
                                    node.id = this.parseIdentifier();
                                    this.checkIdentifier(node.id, 130);
                                } else {
                                    node.id = null;
                                    this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
                                }
                                node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                                if (this.eat(81)) {
                                    node.extends = this.tsParseHeritageClause("extends");
                                }
                                var body = this.startNode();
                                body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
                                node.body = this.finishNode(body, "TSInterfaceBody");
                                return this.finishNode(node, "TSInterfaceDeclaration");
                            }
                        },
                        {
                            key: "tsParseTypeAliasDeclaration",
                            value: function tsParseTypeAliasDeclaration(node) {
                                var _this = this;
                                node.id = this.parseIdentifier();
                                this.checkIdentifier(node.id, 2);
                                node.typeAnnotation = this.tsInType(function() {
                                    node.typeParameters = _this.tsTryParseTypeParameters(_this.tsParseInOutModifiers);
                                    _this.expect(29);
                                    if (_this.isContextual(114) && _this.lookahead().type !== 16) {
                                        var node2 = _this.startNode();
                                        _this.next();
                                        return _this.finishNode(node2, "TSIntrinsicKeyword");
                                    }
                                    return _this.tsParseType();
                                });
                                this.semicolon();
                                return this.finishNode(node, "TSTypeAliasDeclaration");
                            }
                        },
                        {
                            key: "tsInNoContext",
                            value: function tsInNoContext(cb) {
                                var oldContext = this.state.context;
                                this.state.context = [
                                    oldContext[0]
                                ];
                                try {
                                    return cb();
                                } finally{
                                    this.state.context = oldContext;
                                }
                            }
                        },
                        {
                            key: "tsInType",
                            value: function tsInType(cb) {
                                var oldInType = this.state.inType;
                                this.state.inType = true;
                                try {
                                    return cb();
                                } finally{
                                    this.state.inType = oldInType;
                                }
                            }
                        },
                        {
                            key: "tsInDisallowConditionalTypesContext",
                            value: function tsInDisallowConditionalTypesContext(cb) {
                                var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
                                this.state.inDisallowConditionalTypesContext = true;
                                try {
                                    return cb();
                                } finally{
                                    this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
                                }
                            }
                        },
                        {
                            key: "tsInAllowConditionalTypesContext",
                            value: function tsInAllowConditionalTypesContext(cb) {
                                var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
                                this.state.inDisallowConditionalTypesContext = false;
                                try {
                                    return cb();
                                } finally{
                                    this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
                                }
                            }
                        },
                        {
                            key: "tsEatThenParseType",
                            value: function tsEatThenParseType(token) {
                                if (this.match(token)) {
                                    return this.tsNextThenParseType();
                                }
                            }
                        },
                        {
                            key: "tsExpectThenParseType",
                            value: function tsExpectThenParseType(token) {
                                var _this = this;
                                return this.tsInType(function() {
                                    _this.expect(token);
                                    return _this.tsParseType();
                                });
                            }
                        },
                        {
                            key: "tsNextThenParseType",
                            value: function tsNextThenParseType() {
                                var _this = this;
                                return this.tsInType(function() {
                                    _this.next();
                                    return _this.tsParseType();
                                });
                            }
                        },
                        {
                            key: "tsParseEnumMember",
                            value: function tsParseEnumMember() {
                                var node = this.startNode();
                                node.id = this.match(133) ? _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value) : this.parseIdentifier(true);
                                if (this.eat(29)) {
                                    node.initializer = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssignAllowIn", this).call(this);
                                }
                                return this.finishNode(node, "TSEnumMember");
                            }
                        },
                        {
                            key: "tsParseEnumDeclaration",
                            value: function tsParseEnumDeclaration(node) {
                                var properties = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                                if (properties.const) node.const = true;
                                if (properties.declare) node.declare = true;
                                this.expectContextual(126);
                                node.id = this.parseIdentifier();
                                this.checkIdentifier(node.id, node.const ? 8971 : 8459);
                                this.expect(5);
                                node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                                this.expect(8);
                                return this.finishNode(node, "TSEnumDeclaration");
                            }
                        },
                        {
                            key: "tsParseModuleBlock",
                            value: function tsParseModuleBlock() {
                                var node = this.startNode();
                                this.scope.enter(0);
                                this.expect(5);
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBlockOrModuleBlockBody", this).call(this, node.body = [], void 0, true, 8);
                                this.scope.exit();
                                return this.finishNode(node, "TSModuleBlock");
                            }
                        },
                        {
                            key: "tsParseModuleOrNamespaceDeclaration",
                            value: function tsParseModuleOrNamespaceDeclaration(node) {
                                var nested = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                                node.id = this.parseIdentifier();
                                if (!nested) {
                                    this.checkIdentifier(node.id, 1024);
                                }
                                if (this.eat(16)) {
                                    var inner = this.startNode();
                                    this.tsParseModuleOrNamespaceDeclaration(inner, true);
                                    node.body = inner;
                                } else {
                                    this.scope.enter(256);
                                    this.prodParam.enter(0);
                                    node.body = this.tsParseModuleBlock();
                                    this.prodParam.exit();
                                    this.scope.exit();
                                }
                                return this.finishNode(node, "TSModuleDeclaration");
                            }
                        },
                        {
                            key: "tsParseAmbientExternalModuleDeclaration",
                            value: function tsParseAmbientExternalModuleDeclaration(node) {
                                if (this.isContextual(112)) {
                                    node.kind = "global";
                                    node.global = true;
                                    node.id = this.parseIdentifier();
                                } else if (this.match(133)) {
                                    node.kind = "module";
                                    node.id = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStringLiteral", this).call(this, this.state.value);
                                } else {
                                    this.unexpected();
                                }
                                if (this.match(5)) {
                                    this.scope.enter(256);
                                    this.prodParam.enter(0);
                                    node.body = this.tsParseModuleBlock();
                                    this.prodParam.exit();
                                    this.scope.exit();
                                } else {
                                    this.semicolon();
                                }
                                return this.finishNode(node, "TSModuleDeclaration");
                            }
                        },
                        {
                            key: "tsParseImportEqualsDeclaration",
                            value: function tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
                                node.isExport = isExport || false;
                                node.id = maybeDefaultIdentifier || this.parseIdentifier();
                                this.checkIdentifier(node.id, 4096);
                                this.expect(29);
                                var moduleReference = this.tsParseModuleReference();
                                if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
                                    this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
                                }
                                node.moduleReference = moduleReference;
                                this.semicolon();
                                return this.finishNode(node, "TSImportEqualsDeclaration");
                            }
                        },
                        {
                            key: "tsIsExternalModuleReference",
                            value: function tsIsExternalModuleReference() {
                                return this.isContextual(119) && this.lookaheadCharCode() === 40;
                            }
                        },
                        {
                            key: "tsParseModuleReference",
                            value: function tsParseModuleReference() {
                                return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
                            }
                        },
                        {
                            key: "tsParseExternalModuleReference",
                            value: function tsParseExternalModuleReference() {
                                var node = this.startNode();
                                this.expectContextual(119);
                                this.expect(10);
                                if (!this.match(133)) {
                                    this.unexpected();
                                }
                                node.expression = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprAtom", this).call(this);
                                this.expect(11);
                                this.sawUnambiguousESM = true;
                                return this.finishNode(node, "TSExternalModuleReference");
                            }
                        },
                        {
                            key: "tsLookAhead",
                            value: function tsLookAhead(f) {
                                var state = this.state.clone();
                                var res = f();
                                this.state = state;
                                return res;
                            }
                        },
                        {
                            key: "tsTryParseAndCatch",
                            value: function tsTryParseAndCatch(f) {
                                var result = this.tryParse(function(abort) {
                                    return f() || abort();
                                });
                                if (result.aborted || !result.node) return;
                                if (result.error) this.state = result.failState;
                                return result.node;
                            }
                        },
                        {
                            key: "tsTryParse",
                            value: function tsTryParse(f) {
                                var state = this.state.clone();
                                var result = f();
                                if (result !== void 0 && result !== false) {
                                    return result;
                                }
                                this.state = state;
                            }
                        },
                        {
                            key: "tsTryParseDeclare",
                            value: function tsTryParseDeclare(nany) {
                                var _this = this;
                                if (this.isLineTerminator()) {
                                    return;
                                }
                                var startType = this.state.type;
                                var kind;
                                if (this.isContextual(100)) {
                                    startType = 74;
                                    kind = "let";
                                }
                                return this.tsInAmbientContext(function() {
                                    switch(startType){
                                        case 68:
                                            nany.declare = true;
                                            return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionStatement", _this).call(_this, nany, false, false);
                                        case 80:
                                            nany.declare = true;
                                            return _this.parseClass(nany, true, false);
                                        case 126:
                                            return _this.tsParseEnumDeclaration(nany, {
                                                declare: true
                                            });
                                        case 112:
                                            return _this.tsParseAmbientExternalModuleDeclaration(nany);
                                        case 75:
                                        case 74:
                                            if (!_this.match(75) || !_this.isLookaheadContextual("enum")) {
                                                nany.declare = true;
                                                return _this.parseVarStatement(nany, kind || _this.state.value, true);
                                            }
                                            _this.expect(75);
                                            return _this.tsParseEnumDeclaration(nany, {
                                                const: true,
                                                declare: true
                                            });
                                        case 129:
                                            {
                                                var result = _this.tsParseInterfaceDeclaration(nany, {
                                                    declare: true
                                                });
                                                if (result) return result;
                                            }
                                        default:
                                            if (tokenIsIdentifier(startType)) {
                                                return _this.tsParseDeclaration(nany, _this.state.value, true, null);
                                            }
                                    }
                                });
                            }
                        },
                        {
                            key: "tsTryParseExportDeclaration",
                            value: function tsTryParseExportDeclaration() {
                                return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
                            }
                        },
                        {
                            key: "tsParseExpressionStatement",
                            value: function tsParseExpressionStatement(node, expr, decorators) {
                                switch(expr.name){
                                    case "declare":
                                        {
                                            var declaration = this.tsTryParseDeclare(node);
                                            if (declaration) {
                                                declaration.declare = true;
                                            }
                                            return declaration;
                                        }
                                    case "global":
                                        if (this.match(5)) {
                                            this.scope.enter(256);
                                            this.prodParam.enter(0);
                                            var mod = node;
                                            mod.kind = "global";
                                            mod.global = true;
                                            mod.id = expr;
                                            mod.body = this.tsParseModuleBlock();
                                            this.scope.exit();
                                            this.prodParam.exit();
                                            return this.finishNode(mod, "TSModuleDeclaration");
                                        }
                                        break;
                                    default:
                                        return this.tsParseDeclaration(node, expr.name, false, decorators);
                                }
                            }
                        },
                        {
                            key: "tsParseDeclaration",
                            value: function tsParseDeclaration(node, value, next, decorators) {
                                switch(value){
                                    case "abstract":
                                        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                                            return this.tsParseAbstractDeclaration(node, decorators);
                                        }
                                        break;
                                    case "module":
                                        if (this.tsCheckLineTerminator(next)) {
                                            if (this.match(133)) {
                                                return this.tsParseAmbientExternalModuleDeclaration(node);
                                            } else if (tokenIsIdentifier(this.state.type)) {
                                                node.kind = "module";
                                                return this.tsParseModuleOrNamespaceDeclaration(node);
                                            }
                                        }
                                        break;
                                    case "namespace":
                                        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                                            node.kind = "namespace";
                                            return this.tsParseModuleOrNamespaceDeclaration(node);
                                        }
                                        break;
                                    case "type":
                                        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
                                            return this.tsParseTypeAliasDeclaration(node);
                                        }
                                        break;
                                }
                            }
                        },
                        {
                            key: "tsCheckLineTerminator",
                            value: function tsCheckLineTerminator(next) {
                                if (next) {
                                    if (this.hasFollowingLineBreak()) return false;
                                    this.next();
                                    return true;
                                }
                                return !this.isLineTerminator();
                            }
                        },
                        {
                            key: "tsTryParseGenericAsyncArrowFunction",
                            value: function tsTryParseGenericAsyncArrowFunction(startLoc) {
                                var _this = this;
                                if (!this.match(47)) return;
                                var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                                this.state.maybeInArrowParameters = true;
                                var res = this.tsTryParseAndCatch(function() {
                                    var node = _this.startNodeAt(startLoc);
                                    node.typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionParams", _this).call(_this, node);
                                    node.returnType = _this.tsTryParseTypeOrTypePredicateAnnotation();
                                    _this.expect(19);
                                    return node;
                                });
                                this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                                if (!res) return;
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrowExpression", this).call(this, res, null, true);
                            }
                        },
                        {
                            key: "tsParseTypeArgumentsInExpression",
                            value: function tsParseTypeArgumentsInExpression() {
                                if (this.reScan_lt() !== 47) return;
                                return this.tsParseTypeArguments();
                            }
                        },
                        {
                            key: "tsParseTypeArguments",
                            value: function tsParseTypeArguments() {
                                var _this = this;
                                var node = this.startNode();
                                node.params = this.tsInType(function() {
                                    return _this.tsInNoContext(function() {
                                        _this.expect(47);
                                        return _this.tsParseDelimitedList("TypeParametersOrArguments", _this.tsParseType.bind(_this));
                                    });
                                });
                                if (node.params.length === 0) {
                                    this.raise(TSErrors.EmptyTypeArguments, node);
                                } else if (!this.state.inType && this.curContext() === types.brace) {
                                    this.reScan_lt_gt();
                                }
                                this.expect(48);
                                return this.finishNode(node, "TSTypeParameterInstantiation");
                            }
                        },
                        {
                            key: "tsIsDeclarationStart",
                            value: function tsIsDeclarationStart() {
                                return tokenIsTSDeclarationStart(this.state.type);
                            }
                        },
                        {
                            key: "isExportDefaultSpecifier",
                            value: function isExportDefaultSpecifier() {
                                if (this.tsIsDeclarationStart()) return false;
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                            }
                        },
                        {
                            key: "parseAssignableListItem",
                            value: function parseAssignableListItem(flags, decorators) {
                                var startLoc = this.state.startLoc;
                                var modified = {};
                                this.tsParseModifiers({
                                    allowedModifiers: [
                                        "public",
                                        "private",
                                        "protected",
                                        "override",
                                        "readonly"
                                    ]
                                }, modified);
                                var accessibility = modified.accessibility;
                                var override = modified.override;
                                var readonly = modified.readonly;
                                if (!(flags & 4) && (accessibility || readonly || override)) {
                                    this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
                                }
                                var left = this.parseMaybeDefault();
                                if (flags & 2) {
                                    this.parseFunctionParamType(left);
                                }
                                var elt = this.parseMaybeDefault(left.loc.start, left);
                                if (accessibility || readonly || override) {
                                    var pp = this.startNodeAt(startLoc);
                                    if (decorators.length) {
                                        pp.decorators = decorators;
                                    }
                                    if (accessibility) pp.accessibility = accessibility;
                                    if (readonly) pp.readonly = readonly;
                                    if (override) pp.override = override;
                                    if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
                                        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
                                    }
                                    pp.parameter = elt;
                                    return this.finishNode(pp, "TSParameterProperty");
                                }
                                if (decorators.length) {
                                    left.decorators = decorators;
                                }
                                return elt;
                            }
                        },
                        {
                            key: "isSimpleParameter",
                            value: function isSimpleParameter(node) {
                                return node.type === "TSParameterProperty" && _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node.parameter) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isSimpleParameter", this).call(this, node);
                            }
                        },
                        {
                            key: "tsDisallowOptionalPattern",
                            value: function tsDisallowOptionalPattern(node) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var param = _step.value;
                                        if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
                                            this.raise(TSErrors.PatternIsOptional, param);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                        },
                        {
                            key: "setArrowFunctionParameters",
                            value: function setArrowFunctionParameters(node, params, trailingCommaLoc) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "setArrowFunctionParameters", this).call(this, node, params, trailingCommaLoc);
                                this.tsDisallowOptionalPattern(node);
                            }
                        },
                        {
                            key: "parseFunctionBodyAndFinish",
                            value: function parseFunctionBodyAndFinish(node, type) {
                                var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                                if (this.match(14)) {
                                    node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                                }
                                var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
                                if (bodilessType && !this.match(5) && this.isLineTerminator()) {
                                    return this.finishNode(node, bodilessType);
                                }
                                if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
                                    this.raise(TSErrors.DeclareFunctionHasImplementation, node);
                                    if (node.declare) {
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, bodilessType, isMethod);
                                    }
                                }
                                this.tsDisallowOptionalPattern(node);
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionBodyAndFinish", this).call(this, node, type, isMethod);
                            }
                        },
                        {
                            key: "registerFunctionStatementId",
                            value: function registerFunctionStatementId(node) {
                                if (!node.body && node.id) {
                                    this.checkIdentifier(node.id, 1024);
                                } else {
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "registerFunctionStatementId", this).call(this, node);
                                }
                            }
                        },
                        {
                            key: "tsCheckForInvalidTypeCasts",
                            value: function tsCheckForInvalidTypeCasts(items) {
                                var _this = this;
                                items.forEach(function(node) {
                                    if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
                                        _this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
                                    }
                                });
                            }
                        },
                        {
                            key: "toReferencedList",
                            value: function toReferencedList(exprList, isInParens) {
                                this.tsCheckForInvalidTypeCasts(exprList);
                                return exprList;
                            }
                        },
                        {
                            key: "parseArrayLike",
                            value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                                var node = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrayLike", this).call(this, close, canBePattern, isTuple, refExpressionErrors);
                                if (node.type === "ArrayExpression") {
                                    this.tsCheckForInvalidTypeCasts(node.elements);
                                }
                                return node;
                            }
                        },
                        {
                            key: "parseSubscript",
                            value: function parseSubscript(base, startLoc, noCalls, state) {
                                var _this = this;
                                if (!this.hasPrecedingLineBreak() && this.match(35)) {
                                    this.state.canStartJSXElement = false;
                                    this.next();
                                    var nonNullExpression = this.startNodeAt(startLoc);
                                    nonNullExpression.expression = base;
                                    return this.finishNode(nonNullExpression, "TSNonNullExpression");
                                }
                                var isOptionalCall = false;
                                if (this.match(18) && this.lookaheadCharCode() === 60) {
                                    if (noCalls) {
                                        state.stop = true;
                                        return base;
                                    }
                                    state.optionalChainMember = isOptionalCall = true;
                                    this.next();
                                }
                                if (this.match(47) || this.match(51)) {
                                    var missingParenErrorLoc;
                                    var result = this.tsTryParseAndCatch(function() {
                                        if (!noCalls && _this.atPossibleAsyncArrow(base)) {
                                            var asyncArrowFn = _this.tsTryParseGenericAsyncArrowFunction(startLoc);
                                            if (asyncArrowFn) {
                                                return asyncArrowFn;
                                            }
                                        }
                                        var typeArguments = _this.tsParseTypeArgumentsInExpression();
                                        if (!typeArguments) return;
                                        if (isOptionalCall && !_this.match(10)) {
                                            missingParenErrorLoc = _this.state.curPosition();
                                            return;
                                        }
                                        if (tokenIsTemplate(_this.state.type)) {
                                            var result2 = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseTaggedTemplateExpression", _this).call(_this, base, startLoc, state);
                                            result2.typeParameters = typeArguments;
                                            return result2;
                                        }
                                        if (!noCalls && _this.eat(10)) {
                                            var node2 = _this.startNodeAt(startLoc);
                                            node2.callee = base;
                                            node2.arguments = _this.parseCallExpressionArguments(11);
                                            _this.tsCheckForInvalidTypeCasts(node2.arguments);
                                            node2.typeParameters = typeArguments;
                                            if (state.optionalChainMember) {
                                                node2.optional = isOptionalCall;
                                            }
                                            return _this.finishCallExpression(node2, state.optionalChainMember);
                                        }
                                        var tokenType = _this.state.type;
                                        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !_this.hasPrecedingLineBreak()) {
                                            return;
                                        }
                                        var node = _this.startNodeAt(startLoc);
                                        node.expression = base;
                                        node.typeParameters = typeArguments;
                                        return _this.finishNode(node, "TSInstantiationExpression");
                                    });
                                    if (missingParenErrorLoc) {
                                        this.unexpected(missingParenErrorLoc, 10);
                                    }
                                    if (result) {
                                        if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                                            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
                                        }
                                        return result;
                                    }
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseSubscript", this).call(this, base, startLoc, noCalls, state);
                            }
                        },
                        {
                            key: "parseNewCallee",
                            value: function parseNewCallee(node) {
                                var _callee$extra;
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseNewCallee", this).call(this, node);
                                var callee = node.callee;
                                if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
                                    node.typeParameters = callee.typeParameters;
                                    node.callee = callee.expression;
                                }
                            }
                        },
                        {
                            key: "parseExprOp",
                            value: function parseExprOp(left, leftStartLoc, minPrec) {
                                var _this = this;
                                var isSatisfies;
                                if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
                                    var node = this.startNodeAt(leftStartLoc);
                                    node.expression = left;
                                    node.typeAnnotation = this.tsInType(function() {
                                        _this.next();
                                        if (_this.match(75)) {
                                            if (isSatisfies) {
                                                _this.raise(Errors.UnexpectedKeyword, _this.state.startLoc, {
                                                    keyword: "const"
                                                });
                                            }
                                            return _this.tsParseTypeReference();
                                        }
                                        return _this.tsParseType();
                                    });
                                    this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
                                    this.reScan_lt_gt();
                                    return this.parseExprOp(node, leftStartLoc, minPrec);
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExprOp", this).call(this, left, leftStartLoc, minPrec);
                            }
                        },
                        {
                            key: "checkReservedWord",
                            value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                                if (!this.state.isAmbientContext) {
                                    _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
                                }
                            }
                        },
                        {
                            key: "checkImportReflection",
                            value: function checkImportReflection(node) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkImportReflection", this).call(this, node);
                                if (node.module && node.importKind !== "value") {
                                    this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
                                }
                            }
                        },
                        {
                            key: "checkDuplicateExports",
                            value: function checkDuplicateExports() {}
                        },
                        {
                            key: "isPotentialImportPhase",
                            value: function isPotentialImportPhase(isExport) {
                                if (_get(_get_prototype_of(TypeScriptParserMixin.prototype), "isPotentialImportPhase", this).call(this, isExport)) return true;
                                if (this.isContextual(130)) {
                                    var ch = this.lookaheadCharCode();
                                    return isExport ? ch === 123 || ch === 42 : ch !== 61;
                                }
                                return !isExport && this.isContextual(87);
                            }
                        },
                        {
                            key: "applyImportPhase",
                            value: function applyImportPhase(node, isExport, phase, loc) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "applyImportPhase", this).call(this, node, isExport, phase, loc);
                                if (isExport) {
                                    node.exportKind = phase === "type" ? "type" : "value";
                                } else {
                                    node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
                                }
                            }
                        },
                        {
                            key: "parseImport",
                            value: function parseImport(node) {
                                if (this.match(133)) {
                                    node.importKind = "value";
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImport", this).call(this, node);
                                }
                                var importNode;
                                if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                                    node.importKind = "value";
                                    return this.tsParseImportEqualsDeclaration(node);
                                } else if (this.isContextual(130)) {
                                    var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
                                    if (this.lookaheadCharCode() === 61) {
                                        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
                                    } else {
                                        importNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImportSpecifiersAndAfter", this).call(this, node, maybeDefaultIdentifier);
                                    }
                                } else {
                                    importNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImport", this).call(this, node);
                                }
                                if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
                                    this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
                                }
                                return importNode;
                            }
                        },
                        {
                            key: "parseExport",
                            value: function parseExport(node, decorators) {
                                if (this.match(83)) {
                                    this.next();
                                    var nodeImportEquals = node;
                                    var maybeDefaultIdentifier = null;
                                    if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
                                        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
                                    } else {
                                        nodeImportEquals.importKind = "value";
                                    }
                                    return this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
                                } else if (this.eat(29)) {
                                    var assign = node;
                                    assign.expression = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExpression", this).call(this);
                                    this.semicolon();
                                    this.sawUnambiguousESM = true;
                                    return this.finishNode(assign, "TSExportAssignment");
                                } else if (this.eatContextual(93)) {
                                    var decl = node;
                                    this.expectContextual(128);
                                    decl.id = this.parseIdentifier();
                                    this.semicolon();
                                    return this.finishNode(decl, "TSNamespaceExportDeclaration");
                                } else {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExport", this).call(this, node, decorators);
                                }
                            }
                        },
                        {
                            key: "isAbstractClass",
                            value: function isAbstractClass() {
                                return this.isContextual(124) && this.lookahead().type === 80;
                            }
                        },
                        {
                            key: "parseExportDefaultExpression",
                            value: function parseExportDefaultExpression() {
                                if (this.isAbstractClass()) {
                                    var cls = this.startNode();
                                    this.next();
                                    cls.abstract = true;
                                    return this.parseClass(cls, true, true);
                                }
                                if (this.match(129)) {
                                    var result = this.tsParseInterfaceDeclaration(this.startNode());
                                    if (result) return result;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportDefaultExpression", this).call(this);
                            }
                        },
                        {
                            key: "parseVarStatement",
                            value: function parseVarStatement(node, kind) {
                                var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                                var isAmbientContext = this.state.isAmbientContext;
                                var declaration = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseVarStatement", this).call(this, node, kind, allowMissingInitializer || isAmbientContext);
                                if (!isAmbientContext) return declaration;
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = declaration.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var _step_value = _step.value, id = _step_value.id, init = _step_value.init;
                                        if (!init) continue;
                                        if (kind !== "const" || !!id.typeAnnotation) {
                                            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
                                        } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
                                            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                                return declaration;
                            }
                        },
                        {
                            key: "parseStatementContent",
                            value: function parseStatementContent(flags, decorators) {
                                if (this.match(75) && this.isLookaheadContextual("enum")) {
                                    var node = this.startNode();
                                    this.expect(75);
                                    return this.tsParseEnumDeclaration(node, {
                                        const: true
                                    });
                                }
                                if (this.isContextual(126)) {
                                    return this.tsParseEnumDeclaration(this.startNode());
                                }
                                if (this.isContextual(129)) {
                                    var result = this.tsParseInterfaceDeclaration(this.startNode());
                                    if (result) return result;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseStatementContent", this).call(this, flags, decorators);
                            }
                        },
                        {
                            key: "parseAccessModifier",
                            value: function parseAccessModifier() {
                                return this.tsParseModifier([
                                    "public",
                                    "protected",
                                    "private"
                                ]);
                            }
                        },
                        {
                            key: "tsHasSomeModifiers",
                            value: function tsHasSomeModifiers(member, modifiers) {
                                return modifiers.some(function(modifier) {
                                    if (tsIsAccessModifier(modifier)) {
                                        return member.accessibility === modifier;
                                    }
                                    return !!member[modifier];
                                });
                            }
                        },
                        {
                            key: "tsIsStartOfStaticBlocks",
                            value: function tsIsStartOfStaticBlocks() {
                                return this.isContextual(106) && this.lookaheadCharCode() === 123;
                            }
                        },
                        {
                            key: "parseClassMember",
                            value: function parseClassMember(classBody, member, state) {
                                var _this = this;
                                var modifiers = [
                                    "declare",
                                    "private",
                                    "public",
                                    "protected",
                                    "override",
                                    "abstract",
                                    "readonly",
                                    "static"
                                ];
                                this.tsParseModifiers({
                                    allowedModifiers: modifiers,
                                    disallowedModifiers: [
                                        "in",
                                        "out"
                                    ],
                                    stopOnStartOfClassStaticBlock: true,
                                    errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
                                }, member);
                                var callParseClassMemberWithIsStatic = function() {
                                    if (_this.tsIsStartOfStaticBlocks()) {
                                        _this.next();
                                        _this.next();
                                        if (_this.tsHasSomeModifiers(member, modifiers)) {
                                            _this.raise(TSErrors.StaticBlockCannotHaveModifier, _this.state.curPosition());
                                        }
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassStaticBlock", _this).call(_this, classBody, member);
                                    } else {
                                        _this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
                                    }
                                };
                                if (member.declare) {
                                    this.tsInAmbientContext(callParseClassMemberWithIsStatic);
                                } else {
                                    callParseClassMemberWithIsStatic();
                                }
                            }
                        },
                        {
                            key: "parseClassMemberWithIsStatic",
                            value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
                                var idx = this.tsTryParseIndexSignature(member);
                                if (idx) {
                                    classBody.body.push(idx);
                                    if (member.abstract) {
                                        this.raise(TSErrors.IndexSignatureHasAbstract, member);
                                    }
                                    if (member.accessibility) {
                                        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
                                            modifier: member.accessibility
                                        });
                                    }
                                    if (member.declare) {
                                        this.raise(TSErrors.IndexSignatureHasDeclare, member);
                                    }
                                    if (member.override) {
                                        this.raise(TSErrors.IndexSignatureHasOverride, member);
                                    }
                                    return;
                                }
                                if (!this.state.inAbstractClass && member.abstract) {
                                    this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
                                }
                                if (member.override) {
                                    if (!state.hadSuperClass) {
                                        this.raise(TSErrors.OverrideNotInSubClass, member);
                                    }
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassMemberWithIsStatic", this).call(this, classBody, member, state, isStatic);
                            }
                        },
                        {
                            key: "parsePostMemberNameModifiers",
                            value: function parsePostMemberNameModifiers(methodOrProp) {
                                var optional = this.eat(17);
                                if (optional) methodOrProp.optional = true;
                                if (methodOrProp.readonly && this.match(10)) {
                                    this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
                                }
                                if (methodOrProp.declare && this.match(10)) {
                                    this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
                                }
                            }
                        },
                        {
                            key: "parseExpressionStatement",
                            value: function parseExpressionStatement(node, expr, decorators) {
                                var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
                                return decl || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr, decorators);
                            }
                        },
                        {
                            key: "shouldParseExportDeclaration",
                            value: function shouldParseExportDeclaration() {
                                if (this.tsIsDeclarationStart()) return true;
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseExportDeclaration", this).call(this);
                            }
                        },
                        {
                            key: "parseConditional",
                            value: function parseConditional(expr, startLoc, refExpressionErrors) {
                                var _this = this;
                                if (!this.state.maybeInArrowParameters || !this.match(17)) {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseConditional", this).call(this, expr, startLoc, refExpressionErrors);
                                }
                                var result = this.tryParse(function() {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseConditional", _this).call(_this, expr, startLoc);
                                });
                                if (!result.node) {
                                    if (result.error) {
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "setOptionalParametersError", this).call(this, refExpressionErrors, result.error);
                                    }
                                    return expr;
                                }
                                if (result.error) this.state = result.failState;
                                return result.node;
                            }
                        },
                        {
                            key: "parseParenItem",
                            value: function parseParenItem(node, startLoc) {
                                var newNode = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseParenItem", this).call(this, node, startLoc);
                                if (this.eat(17)) {
                                    newNode.optional = true;
                                    this.resetEndLocation(node);
                                }
                                if (this.match(14)) {
                                    var typeCastNode = this.startNodeAt(startLoc);
                                    typeCastNode.expression = node;
                                    typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
                                    return this.finishNode(typeCastNode, "TSTypeCastExpression");
                                }
                                return node;
                            }
                        },
                        {
                            key: "parseExportDeclaration",
                            value: function parseExportDeclaration(node) {
                                var _this = this;
                                if (!this.state.isAmbientContext && this.isContextual(125)) {
                                    return this.tsInAmbientContext(function() {
                                        return _this.parseExportDeclaration(node);
                                    });
                                }
                                var startLoc = this.state.startLoc;
                                var isDeclare = this.eatContextual(125);
                                if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
                                    throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
                                }
                                var isIdentifier = tokenIsIdentifier(this.state.type);
                                var declaration = isIdentifier && this.tsTryParseExportDeclaration() || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportDeclaration", this).call(this, node);
                                if (!declaration) return null;
                                if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
                                    node.exportKind = "type";
                                }
                                if (isDeclare) {
                                    this.resetStartLocation(declaration, startLoc);
                                    declaration.declare = true;
                                }
                                return declaration;
                            }
                        },
                        {
                            key: "parseClassId",
                            value: function parseClassId(node, isStatement, optionalId, bindingType) {
                                if ((!isStatement || optionalId) && this.isContextual(113)) {
                                    return;
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassId", this).call(this, node, isStatement, optionalId, node.declare ? 1024 : 8331);
                                var typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                                if (typeParameters) node.typeParameters = typeParameters;
                            }
                        },
                        {
                            key: "parseClassPropertyAnnotation",
                            value: function parseClassPropertyAnnotation(node) {
                                if (!node.optional) {
                                    if (this.eat(35)) {
                                        node.definite = true;
                                    } else if (this.eat(17)) {
                                        node.optional = true;
                                    }
                                }
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) node.typeAnnotation = type;
                            }
                        },
                        {
                            key: "parseClassProperty",
                            value: function parseClassProperty(node) {
                                this.parseClassPropertyAnnotation(node);
                                if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
                                    this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
                                }
                                if (node.abstract && this.match(29)) {
                                    var key = node.key;
                                    this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
                                        propertyName: key.type === "Identifier" && !node.computed ? key.name : "[".concat(this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end)), "]")
                                    });
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassProperty", this).call(this, node);
                            }
                        },
                        {
                            key: "parseClassPrivateProperty",
                            value: function parseClassPrivateProperty(node) {
                                if (node.abstract) {
                                    this.raise(TSErrors.PrivateElementHasAbstract, node);
                                }
                                if (node.accessibility) {
                                    this.raise(TSErrors.PrivateElementHasAccessibility, node, {
                                        modifier: node.accessibility
                                    });
                                }
                                this.parseClassPropertyAnnotation(node);
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassPrivateProperty", this).call(this, node);
                            }
                        },
                        {
                            key: "parseClassAccessorProperty",
                            value: function parseClassAccessorProperty(node) {
                                this.parseClassPropertyAnnotation(node);
                                if (node.optional) {
                                    this.raise(TSErrors.AccessorCannotBeOptional, node);
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassAccessorProperty", this).call(this, node);
                            }
                        },
                        {
                            key: "pushClassMethod",
                            value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                                var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                if (typeParameters && isConstructor) {
                                    this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
                                }
                                var _method_declare = method.declare, declare = _method_declare === void 0 ? false : _method_declare, kind = method.kind;
                                if (declare && (kind === "get" || kind === "set")) {
                                    this.raise(TSErrors.DeclareAccessor, method, {
                                        kind: kind
                                    });
                                }
                                if (typeParameters) method.typeParameters = typeParameters;
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "pushClassMethod", this).call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
                            }
                        },
                        {
                            key: "pushClassPrivateMethod",
                            value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                                var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                if (typeParameters) method.typeParameters = typeParameters;
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "pushClassPrivateMethod", this).call(this, classBody, method, isGenerator, isAsync);
                            }
                        },
                        {
                            key: "declareClassPrivateMethodInScope",
                            value: function declareClassPrivateMethodInScope(node, kind) {
                                if (node.type === "TSDeclareMethod") return;
                                if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
                                    return;
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "declareClassPrivateMethodInScope", this).call(this, node, kind);
                            }
                        },
                        {
                            key: "parseClassSuper",
                            value: function parseClassSuper(node) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClassSuper", this).call(this, node);
                                if (node.superClass && (this.match(47) || this.match(51))) {
                                    node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
                                }
                                if (this.eatContextual(113)) {
                                    node.implements = this.tsParseHeritageClause("implements");
                                }
                            }
                        },
                        {
                            key: "parseObjPropValue",
                            value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                                var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                if (typeParameters) prop.typeParameters = typeParameters;
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseObjPropValue", this).call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
                            }
                        },
                        {
                            key: "parseFunctionParams",
                            value: function parseFunctionParams(node, isConstructor) {
                                var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                                if (typeParameters) node.typeParameters = typeParameters;
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseFunctionParams", this).call(this, node, isConstructor);
                            }
                        },
                        {
                            key: "parseVarId",
                            value: function parseVarId(decl, kind) {
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseVarId", this).call(this, decl, kind);
                                if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
                                    decl.definite = true;
                                }
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) {
                                    decl.id.typeAnnotation = type;
                                    this.resetEndLocation(decl.id);
                                }
                            }
                        },
                        {
                            key: "parseAsyncArrowFromCallExpression",
                            value: function parseAsyncArrowFromCallExpression(node, call) {
                                if (this.match(14)) {
                                    node.returnType = this.tsParseTypeAnnotation();
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseAsyncArrowFromCallExpression", this).call(this, node, call);
                            }
                        },
                        {
                            key: "parseMaybeAssign",
                            value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                                var _this = this;
                                var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
                                var state;
                                var jsx2;
                                var typeCast;
                                if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
                                    state = this.state.clone();
                                    jsx2 = this.tryParse(function() {
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                    }, state);
                                    if (!jsx2.error) return jsx2.node;
                                    var context = this.state.context;
                                    var currentContext = context[context.length - 1];
                                    if (currentContext === types.j_oTag || currentContext === types.j_expr) {
                                        context.pop();
                                    }
                                }
                                if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", this).call(this, refExpressionErrors, afterLeftParse);
                                }
                                if (!state || state === this.state) state = this.state.clone();
                                var typeParameters;
                                var arrow = this.tryParse(function(abort) {
                                    var _expr$extra, _typeParameters;
                                    typeParameters = _this.tsParseTypeParameters(_this.tsParseConstModifier);
                                    var expr = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                    if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
                                        abort();
                                    }
                                    if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
                                        _this.resetStartLocationFromNode(expr, typeParameters);
                                    }
                                    expr.typeParameters = typeParameters;
                                    return expr;
                                }, state);
                                if (!arrow.error && !arrow.aborted) {
                                    if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                                    return arrow.node;
                                }
                                if (!jsx2) {
                                    assert(!this.hasPlugin("jsx"));
                                    typeCast = this.tryParse(function() {
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeAssign", _this).call(_this, refExpressionErrors, afterLeftParse);
                                    }, state);
                                    if (!typeCast.error) return typeCast.node;
                                }
                                if ((_jsx2 = jsx2) != null && _jsx2.node) {
                                    this.state = jsx2.failState;
                                    return jsx2.node;
                                }
                                if (arrow.node) {
                                    this.state = arrow.failState;
                                    if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
                                    return arrow.node;
                                }
                                if ((_typeCast = typeCast) != null && _typeCast.node) {
                                    this.state = typeCast.failState;
                                    return typeCast.node;
                                }
                                throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
                            }
                        },
                        {
                            key: "reportReservedArrowTypeParam",
                            value: function reportReservedArrowTypeParam(node) {
                                var _node$extra;
                                if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                                    this.raise(TSErrors.ReservedArrowTypeParam, node);
                                }
                            }
                        },
                        {
                            key: "parseMaybeUnary",
                            value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
                                if (!this.hasPlugin("jsx") && this.match(47)) {
                                    return this.tsParseTypeAssertion();
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeUnary", this).call(this, refExpressionErrors, sawUnary);
                            }
                        },
                        {
                            key: "parseArrow",
                            value: function parseArrow(node) {
                                var _this = this;
                                if (this.match(14)) {
                                    var result = this.tryParse(function(abort) {
                                        var returnType = _this.tsParseTypeOrTypePredicateAnnotation(14);
                                        if (_this.canInsertSemicolon() || !_this.match(19)) abort();
                                        return returnType;
                                    });
                                    if (result.aborted) return;
                                    if (!result.thrown) {
                                        if (result.error) this.state = result.failState;
                                        node.returnType = result.node;
                                    }
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseArrow", this).call(this, node);
                            }
                        },
                        {
                            key: "parseFunctionParamType",
                            value: function parseFunctionParamType(param) {
                                if (this.eat(17)) {
                                    param.optional = true;
                                }
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) param.typeAnnotation = type;
                                this.resetEndLocation(param);
                                return param;
                            }
                        },
                        {
                            key: "isAssignable",
                            value: function isAssignable(node, isBinding) {
                                switch(node.type){
                                    case "TSTypeCastExpression":
                                        return this.isAssignable(node.expression, isBinding);
                                    case "TSParameterProperty":
                                        return true;
                                    default:
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isAssignable", this).call(this, node, isBinding);
                                }
                            }
                        },
                        {
                            key: "toAssignable",
                            value: function toAssignable(node) {
                                var isLHS = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                                switch(node.type){
                                    case "ParenthesizedExpression":
                                        this.toAssignableParenthesizedExpression(node, isLHS);
                                        break;
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSNonNullExpression":
                                    case "TSTypeAssertion":
                                        if (isLHS) {
                                            this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
                                        } else {
                                            this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
                                        }
                                        this.toAssignable(node.expression, isLHS);
                                        break;
                                    case "AssignmentExpression":
                                        if (!isLHS && node.left.type === "TSTypeCastExpression") {
                                            node.left = this.typeCastToParameter(node.left);
                                        }
                                    default:
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                                }
                            }
                        },
                        {
                            key: "toAssignableParenthesizedExpression",
                            value: function toAssignableParenthesizedExpression(node, isLHS) {
                                switch(node.expression.type){
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSNonNullExpression":
                                    case "TSTypeAssertion":
                                    case "ParenthesizedExpression":
                                        this.toAssignable(node.expression, isLHS);
                                        break;
                                    default:
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                                }
                            }
                        },
                        {
                            key: "checkToRestConversion",
                            value: function checkToRestConversion(node, allowPattern) {
                                switch(node.type){
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSTypeAssertion":
                                    case "TSNonNullExpression":
                                        this.checkToRestConversion(node.expression, false);
                                        break;
                                    default:
                                        _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkToRestConversion", this).call(this, node, allowPattern);
                                }
                            }
                        },
                        {
                            key: "isValidLVal",
                            value: function isValidLVal(type, isUnparenthesizedInAssign, binding) {
                                switch(type){
                                    case "TSTypeCastExpression":
                                        return true;
                                    case "TSParameterProperty":
                                        return "parameter";
                                    case "TSNonNullExpression":
                                    case "TSInstantiationExpression":
                                        return "expression";
                                    case "TSAsExpression":
                                    case "TSSatisfiesExpression":
                                    case "TSTypeAssertion":
                                        return (binding !== 64 || !isUnparenthesizedInAssign) && [
                                            "expression",
                                            true
                                        ];
                                    default:
                                        return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isValidLVal", this).call(this, type, isUnparenthesizedInAssign, binding);
                                }
                            }
                        },
                        {
                            key: "parseBindingAtom",
                            value: function parseBindingAtom() {
                                if (this.state.type === 78) {
                                    return this.parseIdentifier(true);
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseBindingAtom", this).call(this);
                            }
                        },
                        {
                            key: "parseMaybeDecoratorArguments",
                            value: function parseMaybeDecoratorArguments(expr) {
                                if (this.match(47) || this.match(51)) {
                                    var typeArguments = this.tsParseTypeArgumentsInExpression();
                                    if (this.match(10)) {
                                        var call = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
                                        call.typeParameters = typeArguments;
                                        return call;
                                    }
                                    this.unexpected(null, 10);
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDecoratorArguments", this).call(this, expr);
                            }
                        },
                        {
                            key: "checkCommaAfterRest",
                            value: function checkCommaAfterRest(close) {
                                if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
                                    this.next();
                                    return false;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "checkCommaAfterRest", this).call(this, close);
                            }
                        },
                        {
                            key: "isClassMethod",
                            value: function isClassMethod() {
                                return this.match(47) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isClassMethod", this).call(this);
                            }
                        },
                        {
                            key: "isClassProperty",
                            value: function isClassProperty() {
                                return this.match(35) || this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "isClassProperty", this).call(this);
                            }
                        },
                        {
                            key: "parseMaybeDefault",
                            value: function parseMaybeDefault(startLoc, left) {
                                var node = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMaybeDefault", this).call(this, startLoc, left);
                                if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
                                    this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
                                }
                                return node;
                            }
                        },
                        {
                            key: "getTokenFromCode",
                            value: function getTokenFromCode(code2) {
                                if (this.state.inType) {
                                    if (code2 === 62) {
                                        this.finishOp(48, 1);
                                        return;
                                    }
                                    if (code2 === 60) {
                                        this.finishOp(47, 1);
                                        return;
                                    }
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                            }
                        },
                        {
                            key: "reScan_lt_gt",
                            value: function reScan_lt_gt() {
                                var type = this.state.type;
                                if (type === 47) {
                                    this.state.pos -= 1;
                                    this.readToken_lt();
                                } else if (type === 48) {
                                    this.state.pos -= 1;
                                    this.readToken_gt();
                                }
                            }
                        },
                        {
                            key: "reScan_lt",
                            value: function reScan_lt() {
                                var type = this.state.type;
                                if (type === 51) {
                                    this.state.pos -= 2;
                                    this.finishOp(47, 1);
                                    return 47;
                                }
                                return type;
                            }
                        },
                        {
                            key: "toAssignableList",
                            value: function toAssignableList(exprList, trailingCommaLoc, isLHS) {
                                for(var i = 0; i < exprList.length; i++){
                                    var expr = exprList[i];
                                    if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
                                        exprList[i] = this.typeCastToParameter(expr);
                                    }
                                }
                                _get(_get_prototype_of(TypeScriptParserMixin.prototype), "toAssignableList", this).call(this, exprList, trailingCommaLoc, isLHS);
                            }
                        },
                        {
                            key: "typeCastToParameter",
                            value: function typeCastToParameter(node) {
                                node.expression.typeAnnotation = node.typeAnnotation;
                                this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
                                return node.expression;
                            }
                        },
                        {
                            key: "shouldParseArrow",
                            value: function shouldParseArrow(params) {
                                var _this = this;
                                if (this.match(14)) {
                                    return params.every(function(expr) {
                                        return _this.isAssignable(expr, true);
                                    });
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseArrow", this).call(this, params);
                            }
                        },
                        {
                            key: "shouldParseAsyncArrow",
                            value: function shouldParseAsyncArrow() {
                                return this.match(14) || _get(_get_prototype_of(TypeScriptParserMixin.prototype), "shouldParseAsyncArrow", this).call(this);
                            }
                        },
                        {
                            key: "canHaveLeadingDecorator",
                            value: function canHaveLeadingDecorator() {
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass();
                            }
                        },
                        {
                            key: "jsxParseOpeningElementAfterName",
                            value: function jsxParseOpeningElementAfterName(node) {
                                var _this = this;
                                if (this.match(47) || this.match(51)) {
                                    var typeArguments = this.tsTryParseAndCatch(function() {
                                        return _this.tsParseTypeArgumentsInExpression();
                                    });
                                    if (typeArguments) node.typeParameters = typeArguments;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "jsxParseOpeningElementAfterName", this).call(this, node);
                            }
                        },
                        {
                            key: "getGetterSetterExpectedParamCount",
                            value: function getGetterSetterExpectedParamCount(method) {
                                var baseCount = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getGetterSetterExpectedParamCount", this).call(this, method);
                                var params = this.getObjectOrClassMethodParams(method);
                                var firstParam = params[0];
                                var hasContextParam = firstParam && this.isThisParam(firstParam);
                                return hasContextParam ? baseCount + 1 : baseCount;
                            }
                        },
                        {
                            key: "parseCatchClauseParam",
                            value: function parseCatchClauseParam() {
                                var param = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseCatchClauseParam", this).call(this);
                                var type = this.tsTryParseTypeAnnotation();
                                if (type) {
                                    param.typeAnnotation = type;
                                    this.resetEndLocation(param);
                                }
                                return param;
                            }
                        },
                        {
                            key: "tsInAmbientContext",
                            value: function tsInAmbientContext(cb) {
                                var _this_state = this.state, oldIsAmbientContext = _this_state.isAmbientContext, oldStrict = _this_state.strict;
                                this.state.isAmbientContext = true;
                                this.state.strict = false;
                                try {
                                    return cb();
                                } finally{
                                    this.state.isAmbientContext = oldIsAmbientContext;
                                    this.state.strict = oldStrict;
                                }
                            }
                        },
                        {
                            key: "parseClass",
                            value: function parseClass(node, isStatement, optionalId) {
                                var oldInAbstractClass = this.state.inAbstractClass;
                                this.state.inAbstractClass = !!node.abstract;
                                try {
                                    return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseClass", this).call(this, node, isStatement, optionalId);
                                } finally{
                                    this.state.inAbstractClass = oldInAbstractClass;
                                }
                            }
                        },
                        {
                            key: "tsParseAbstractDeclaration",
                            value: function tsParseAbstractDeclaration(node, decorators) {
                                if (this.match(80)) {
                                    node.abstract = true;
                                    return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
                                } else if (this.isContextual(129)) {
                                    if (!this.hasFollowingLineBreak()) {
                                        node.abstract = true;
                                        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
                                        return this.tsParseInterfaceDeclaration(node);
                                    }
                                } else {
                                    this.unexpected(null, 80);
                                }
                            }
                        },
                        {
                            key: "parseMethod",
                            value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
                                var method = _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseMethod", this).call(this, node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
                                if (method.abstract) {
                                    var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
                                    if (hasBody) {
                                        var key = method.key;
                                        this.raise(TSErrors.AbstractMethodHasImplementation, method, {
                                            methodName: key.type === "Identifier" && !method.computed ? key.name : "[".concat(this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end)), "]")
                                        });
                                    }
                                }
                                return method;
                            }
                        },
                        {
                            key: "tsParseTypeParameterName",
                            value: function tsParseTypeParameterName() {
                                var typeName = this.parseIdentifier();
                                return typeName.name;
                            }
                        },
                        {
                            key: "shouldParseAsAmbientContext",
                            value: function shouldParseAsAmbientContext() {
                                return !!this.getPluginOption("typescript", "dts");
                            }
                        },
                        {
                            key: "parse",
                            value: function parse() {
                                if (this.shouldParseAsAmbientContext()) {
                                    this.state.isAmbientContext = true;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parse", this).call(this);
                            }
                        },
                        {
                            key: "getExpression",
                            value: function getExpression() {
                                if (this.shouldParseAsAmbientContext()) {
                                    this.state.isAmbientContext = true;
                                }
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "getExpression", this).call(this);
                            }
                        },
                        {
                            key: "parseExportSpecifier",
                            value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
                                if (!isString && isMaybeTypeOnly) {
                                    this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
                                    return this.finishNode(node, "ExportSpecifier");
                                }
                                node.exportKind = "value";
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseExportSpecifier", this).call(this, node, isString, isInTypeExport, isMaybeTypeOnly);
                            }
                        },
                        {
                            key: "parseImportSpecifier",
                            value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                                if (!importedIsString && isMaybeTypeOnly) {
                                    this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
                                    return this.finishNode(specifier, "ImportSpecifier");
                                }
                                specifier.importKind = "value";
                                return _get(_get_prototype_of(TypeScriptParserMixin.prototype), "parseImportSpecifier", this).call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
                            }
                        },
                        {
                            key: "parseTypeOnlyImportExportSpecifier",
                            value: function parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
                                var leftOfAsKey = isImport ? "imported" : "local";
                                var rightOfAsKey = isImport ? "local" : "exported";
                                var leftOfAs = node[leftOfAsKey];
                                var rightOfAs;
                                var hasTypeSpecifier = false;
                                var canParseAsKeyword = true;
                                var loc = leftOfAs.loc.start;
                                if (this.isContextual(93)) {
                                    var firstAs = this.parseIdentifier();
                                    if (this.isContextual(93)) {
                                        var secondAs = this.parseIdentifier();
                                        if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                            hasTypeSpecifier = true;
                                            leftOfAs = firstAs;
                                            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                                            canParseAsKeyword = false;
                                        } else {
                                            rightOfAs = secondAs;
                                            canParseAsKeyword = false;
                                        }
                                    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                        canParseAsKeyword = false;
                                        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                                    } else {
                                        hasTypeSpecifier = true;
                                        leftOfAs = firstAs;
                                    }
                                } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                    hasTypeSpecifier = true;
                                    if (isImport) {
                                        leftOfAs = this.parseIdentifier(true);
                                        if (!this.isContextual(93)) {
                                            this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
                                        }
                                    } else {
                                        leftOfAs = this.parseModuleExportName();
                                    }
                                }
                                if (hasTypeSpecifier && isInTypeOnlyImportExport) {
                                    this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
                                }
                                node[leftOfAsKey] = leftOfAs;
                                node[rightOfAsKey] = rightOfAs;
                                var kindKey = isImport ? "importKind" : "exportKind";
                                node[kindKey] = hasTypeSpecifier ? "type" : "value";
                                if (canParseAsKeyword && this.eatContextual(93)) {
                                    node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                                }
                                if (!node[rightOfAsKey]) {
                                    node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
                                }
                                if (isImport) {
                                    this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
                                }
                            }
                        }
                    ]);
                    return TypeScriptParserMixin;
                }(superClass);
                return TypeScriptParserMixin;
            };
            function isPossiblyLiteralEnum(expression) {
                if (expression.type !== "MemberExpression") return false;
                var computed = expression.computed, property = expression.property;
                if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(expression.object);
            }
            function isValidAmbientConstInitializer(expression, estree2) {
                var _expression$extra;
                var type = expression.type;
                if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
                    return false;
                }
                if (estree2) {
                    if (type === "Literal") {
                        var value = expression.value;
                        if (typeof value === "string" || typeof value === "boolean") {
                            return true;
                        }
                    }
                } else {
                    if (type === "StringLiteral" || type === "BooleanLiteral") {
                        return true;
                    }
                }
                if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
                    return true;
                }
                if (type === "TemplateLiteral" && expression.expressions.length === 0) {
                    return true;
                }
                if (isPossiblyLiteralEnum(expression)) {
                    return true;
                }
                return false;
            }
            function isNumber(expression, estree2) {
                if (estree2) {
                    return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
                }
                return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
            }
            function isNegativeNumber(expression, estree2) {
                if (expression.type === "UnaryExpression") {
                    var operator = expression.operator, argument = expression.argument;
                    if (operator === "-" && isNumber(argument, estree2)) {
                        return true;
                    }
                }
                return false;
            }
            function isUncomputedMemberExpressionChain(expression) {
                if (expression.type === "Identifier") return true;
                if (expression.type !== "MemberExpression" || expression.computed) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(expression.object);
            }
            var PlaceholderErrors = ParseErrorEnum(_templateObject4())({
                ClassNameIsRequired: "A class name is required.",
                UnexpectedSpace: "Unexpected space in placeholder."
            });
            var placeholders = function(superClass) {
                var PlaceholdersParserMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(PlaceholdersParserMixin, superClass);
                    function PlaceholdersParserMixin() {
                        _class_call_check(this, PlaceholdersParserMixin);
                        return _call_super(this, PlaceholdersParserMixin, arguments);
                    }
                    _create_class(PlaceholdersParserMixin, [
                        {
                            key: "parsePlaceholder",
                            value: function parsePlaceholder(expectedNode) {
                                if (this.match(144)) {
                                    var node = this.startNode();
                                    this.next();
                                    this.assertNoSpace();
                                    node.name = _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, true);
                                    this.assertNoSpace();
                                    this.expect(144);
                                    return this.finishPlaceholder(node, expectedNode);
                                }
                            }
                        },
                        {
                            key: "finishPlaceholder",
                            value: function finishPlaceholder(node, expectedNode) {
                                var placeholder = node;
                                if (!placeholder.expectedNode || !placeholder.type) {
                                    placeholder = this.finishNode(placeholder, "Placeholder");
                                }
                                placeholder.expectedNode = expectedNode;
                                return placeholder;
                            }
                        },
                        {
                            key: "getTokenFromCode",
                            value: function getTokenFromCode(code2) {
                                if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                                    this.finishOp(144, 2);
                                } else {
                                    _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "getTokenFromCode", this).call(this, code2);
                                }
                            }
                        },
                        {
                            key: "parseExprAtom",
                            value: function parseExprAtom(refExpressionErrors) {
                                return this.parsePlaceholder("Expression") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                            }
                        },
                        {
                            key: "parseIdentifier",
                            value: function parseIdentifier(liberal) {
                                return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseIdentifier", this).call(this, liberal);
                            }
                        },
                        {
                            key: "checkReservedWord",
                            value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                                if (word !== void 0) {
                                    _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "checkReservedWord", this).call(this, word, startLoc, checkKeywords, isBinding);
                                }
                            }
                        },
                        {
                            key: "parseBindingAtom",
                            value: function parseBindingAtom() {
                                return this.parsePlaceholder("Pattern") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseBindingAtom", this).call(this);
                            }
                        },
                        {
                            key: "isValidLVal",
                            value: function isValidLVal(type, isParenthesized, binding) {
                                return type === "Placeholder" || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "isValidLVal", this).call(this, type, isParenthesized, binding);
                            }
                        },
                        {
                            key: "toAssignable",
                            value: function toAssignable(node, isLHS) {
                                if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
                                    node.expectedNode = "Pattern";
                                } else {
                                    _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "toAssignable", this).call(this, node, isLHS);
                                }
                            }
                        },
                        {
                            key: "chStartsBindingIdentifier",
                            value: function chStartsBindingIdentifier(ch, pos) {
                                if (_get(_get_prototype_of(PlaceholdersParserMixin.prototype), "chStartsBindingIdentifier", this).call(this, ch, pos)) {
                                    return true;
                                }
                                var nextToken = this.lookahead();
                                if (nextToken.type === 144) {
                                    return true;
                                }
                                return false;
                            }
                        },
                        {
                            key: "verifyBreakContinue",
                            value: function verifyBreakContinue(node, isBreak) {
                                if (node.label && node.label.type === "Placeholder") return;
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "verifyBreakContinue", this).call(this, node, isBreak);
                            }
                        },
                        {
                            key: "parseExpressionStatement",
                            value: function parseExpressionStatement(node, expr) {
                                var _expr$extra;
                                if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
                                    return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExpressionStatement", this).call(this, node, expr);
                                }
                                if (this.match(14)) {
                                    var stmt = node;
                                    stmt.label = this.finishPlaceholder(expr, "Identifier");
                                    this.next();
                                    stmt.body = _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseStatementOrSloppyAnnexBFunctionDeclaration", this).call(this);
                                    return this.finishNode(stmt, "LabeledStatement");
                                }
                                this.semicolon();
                                var stmtPlaceholder = node;
                                stmtPlaceholder.name = expr.name;
                                return this.finishPlaceholder(stmtPlaceholder, "Statement");
                            }
                        },
                        {
                            key: "parseBlock",
                            value: function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
                                return this.parsePlaceholder("BlockStatement") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseBlock", this).call(this, allowDirectives, createNewLexicalScope, afterBlockParse);
                            }
                        },
                        {
                            key: "parseFunctionId",
                            value: function parseFunctionId(requireId) {
                                return this.parsePlaceholder("Identifier") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseFunctionId", this).call(this, requireId);
                            }
                        },
                        {
                            key: "parseClass",
                            value: function parseClass(node, isStatement, optionalId) {
                                var type = isStatement ? "ClassDeclaration" : "ClassExpression";
                                this.next();
                                var oldStrict = this.state.strict;
                                var placeholder = this.parsePlaceholder("Identifier");
                                if (placeholder) {
                                    if (this.match(81) || this.match(144) || this.match(5)) {
                                        node.id = placeholder;
                                    } else if (optionalId || !isStatement) {
                                        node.id = null;
                                        node.body = this.finishPlaceholder(placeholder, "ClassBody");
                                        return this.finishNode(node, type);
                                    } else {
                                        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
                                    }
                                } else {
                                    this.parseClassId(node, isStatement, optionalId);
                                }
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseClassSuper", this).call(this, node);
                                node.body = this.parsePlaceholder("ClassBody") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseClassBody", this).call(this, !!node.superClass, oldStrict);
                                return this.finishNode(node, type);
                            }
                        },
                        {
                            key: "parseExport",
                            value: function parseExport(node, decorators) {
                                var placeholder = this.parsePlaceholder("Identifier");
                                if (!placeholder) return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node, decorators);
                                var node2 = node;
                                if (!this.isContextual(98) && !this.match(12)) {
                                    node2.specifiers = [];
                                    node2.source = null;
                                    node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
                                    return this.finishNode(node2, "ExportNamedDeclaration");
                                }
                                this.expectPlugin("exportDefaultFrom");
                                var specifier = this.startNode();
                                specifier.exported = placeholder;
                                node2.specifiers = [
                                    this.finishNode(specifier, "ExportDefaultSpecifier")
                                ];
                                return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseExport", this).call(this, node2, decorators);
                            }
                        },
                        {
                            key: "isExportDefaultSpecifier",
                            value: function isExportDefaultSpecifier() {
                                if (this.match(65)) {
                                    var next = this.nextTokenStart();
                                    if (this.isUnparsedContextual(next, "from")) {
                                        if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
                                            return true;
                                        }
                                    }
                                }
                                return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "isExportDefaultSpecifier", this).call(this);
                            }
                        },
                        {
                            key: "maybeParseExportDefaultSpecifier",
                            value: function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
                                var _specifiers;
                                if ((_specifiers = node.specifiers) != null && _specifiers.length) {
                                    return true;
                                }
                                return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "maybeParseExportDefaultSpecifier", this).call(this, node, maybeDefaultIdentifier);
                            }
                        },
                        {
                            key: "checkExport",
                            value: function checkExport(node) {
                                var specifiers = node.specifiers;
                                if (specifiers != null && specifiers.length) {
                                    node.specifiers = specifiers.filter(function(node2) {
                                        return node2.exported.type === "Placeholder";
                                    });
                                }
                                _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "checkExport", this).call(this, node);
                                node.specifiers = specifiers;
                            }
                        },
                        {
                            key: "parseImport",
                            value: function parseImport(node) {
                                var placeholder = this.parsePlaceholder("Identifier");
                                if (!placeholder) return _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseImport", this).call(this, node);
                                node.specifiers = [];
                                if (!this.isContextual(98) && !this.match(12)) {
                                    node.source = this.finishPlaceholder(placeholder, "StringLiteral");
                                    this.semicolon();
                                    return this.finishNode(node, "ImportDeclaration");
                                }
                                var specifier = this.startNodeAtNode(placeholder);
                                specifier.local = placeholder;
                                node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
                                if (this.eat(12)) {
                                    var hasStarImport = this.maybeParseStarImportSpecifier(node);
                                    if (!hasStarImport) this.parseNamedImportSpecifiers(node);
                                }
                                this.expectContextual(98);
                                node.source = this.parseImportSource();
                                this.semicolon();
                                return this.finishNode(node, "ImportDeclaration");
                            }
                        },
                        {
                            key: "parseImportSource",
                            value: function parseImportSource() {
                                return this.parsePlaceholder("StringLiteral") || _get(_get_prototype_of(PlaceholdersParserMixin.prototype), "parseImportSource", this).call(this);
                            }
                        },
                        {
                            key: "assertNoSpace",
                            value: function assertNoSpace() {
                                if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
                                    this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
                                }
                            }
                        }
                    ]);
                    return PlaceholdersParserMixin;
                }(superClass);
                return PlaceholdersParserMixin;
            };
            var v8intrinsic = function(superClass) {
                var V8IntrinsicMixin = /*#__PURE__*/ function(superClass) {
                    _inherits(V8IntrinsicMixin, superClass);
                    function V8IntrinsicMixin() {
                        _class_call_check(this, V8IntrinsicMixin);
                        return _call_super(this, V8IntrinsicMixin, arguments);
                    }
                    _create_class(V8IntrinsicMixin, [
                        {
                            key: "parseV8Intrinsic",
                            value: function parseV8Intrinsic() {
                                if (this.match(54)) {
                                    var v8IntrinsicStartLoc = this.state.startLoc;
                                    var node = this.startNode();
                                    this.next();
                                    if (tokenIsIdentifier(this.state.type)) {
                                        var name = this.parseIdentifierName();
                                        var identifier = this.createIdentifier(node, name);
                                        identifier.type = "V8IntrinsicIdentifier";
                                        if (this.match(10)) {
                                            return identifier;
                                        }
                                    }
                                    this.unexpected(v8IntrinsicStartLoc);
                                }
                            }
                        },
                        {
                            key: "parseExprAtom",
                            value: function parseExprAtom(refExpressionErrors) {
                                return this.parseV8Intrinsic() || _get(_get_prototype_of(V8IntrinsicMixin.prototype), "parseExprAtom", this).call(this, refExpressionErrors);
                            }
                        }
                    ]);
                    return V8IntrinsicMixin;
                }(superClass);
                return V8IntrinsicMixin;
            };
            var PIPELINE_PROPOSALS = [
                "minimal",
                "fsharp",
                "hack",
                "smart"
            ];
            var TOPIC_TOKENS = [
                "^^",
                "@@",
                "^",
                "%",
                "#"
            ];
            function validatePlugins(pluginsMap) {
                if (pluginsMap.has("decorators")) {
                    if (pluginsMap.has("decorators-legacy")) {
                        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                    }
                    var decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
                    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
                        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                    }
                    var allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
                    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
                        throw new Error("'allowCallParenthesized' must be a boolean.");
                    }
                }
                if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
                    throw new Error("Cannot combine flow and typescript plugins.");
                }
                if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
                    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                }
                if (pluginsMap.has("pipelineOperator")) {
                    var _pluginsMap$get;
                    var proposal = pluginsMap.get("pipelineOperator").proposal;
                    if (!PIPELINE_PROPOSALS.includes(proposal)) {
                        var proposalList = PIPELINE_PROPOSALS.map(function(p) {
                            return '"'.concat(p, '"');
                        }).join(", ");
                        throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(proposalList, "."));
                    }
                    var tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
                    if (proposal === "hack") {
                        if (pluginsMap.has("placeholders")) {
                            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                        }
                        if (pluginsMap.has("v8intrinsic")) {
                            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                        }
                        var topicToken = pluginsMap.get("pipelineOperator").topicToken;
                        if (!TOPIC_TOKENS.includes(topicToken)) {
                            var tokenList = TOPIC_TOKENS.map(function(t) {
                                return '"'.concat(t, '"');
                            }).join(", ");
                            throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(tokenList, "."));
                        }
                        if (topicToken === "#" && tupleSyntaxIsHash) {
                            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `'.concat(JSON.stringify([
                                "recordAndTuple",
                                pluginsMap.get("recordAndTuple")
                            ]), "`."));
                        }
                    } else if (proposal === "smart" && tupleSyntaxIsHash) {
                        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `'.concat(JSON.stringify([
                            "recordAndTuple",
                            pluginsMap.get("recordAndTuple")
                        ]), "`."));
                    }
                }
                if (pluginsMap.has("moduleAttributes")) {
                    {
                        if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
                            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
                        }
                        var moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
                        if (moduleAttributesVersionPluginOption !== "may-2020") {
                            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
                        }
                    }
                }
                if (pluginsMap.has("importAssertions")) {
                    if (pluginsMap.has("deprecatedImportAssert")) {
                        throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
                    }
                }
                if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
                    {
                        pluginsMap.set("deprecatedImportAssert", {});
                    }
                }
                if (pluginsMap.has("recordAndTuple")) {
                    var syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
                    if (syntaxType != null) {
                        {
                            var RECORD_AND_TUPLE_SYNTAX_TYPES = [
                                "hash",
                                "bar"
                            ];
                            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
                                throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function(p) {
                                    return "'".concat(p, "'");
                                }).join(", "));
                            }
                        }
                    }
                }
                if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
                    var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                    error.missingPlugins = "doExpressions";
                    throw error;
                }
                if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
                    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
                }
            }
            var mixinPlugins = {
                estree: estree,
                jsx: jsx,
                flow: flow,
                typescript: typescript,
                v8intrinsic: v8intrinsic,
                placeholders: placeholders
            };
            var mixinPluginNames = Object.keys(mixinPlugins);
            function createDefaultOptions() {
                return {
                    sourceType: "script",
                    sourceFilename: void 0,
                    startIndex: 0,
                    startColumn: 0,
                    startLine: 1,
                    allowAwaitOutsideFunction: false,
                    allowReturnOutsideFunction: false,
                    allowNewTargetOutsideFunction: false,
                    allowImportExportEverywhere: false,
                    allowSuperOutsideMethod: false,
                    allowUndeclaredExports: false,
                    plugins: [],
                    strictMode: null,
                    ranges: false,
                    tokens: false,
                    createImportExpressions: false,
                    createParenthesizedExpressions: false,
                    errorRecovery: false,
                    attachComment: true,
                    annexB: true
                };
            }
            function getOptions(opts) {
                var options = createDefaultOptions();
                if (opts == null) {
                    return options;
                }
                if (opts.annexB != null && opts.annexB !== false) {
                    throw new Error("The `annexB` option can only be set to `false`.");
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var key = _step.value;
                        if (opts[key] != null) options[key] = opts[key];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                if (options.startLine === 1) {
                    if (opts.startIndex == null && options.startColumn > 0) {
                        options.startIndex = options.startColumn;
                    } else if (opts.startColumn == null && options.startIndex > 0) {
                        options.startColumn = options.startIndex;
                    }
                } else if (opts.startColumn == null || opts.startIndex == null) {
                    if (opts.startIndex != null) {
                        throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
                    }
                }
                return options;
            }
            var ExpressionParser = /*#__PURE__*/ function(LValParser) {
                _inherits(ExpressionParser, LValParser);
                function ExpressionParser() {
                    _class_call_check(this, ExpressionParser);
                    return _call_super(this, ExpressionParser, arguments);
                }
                _create_class(ExpressionParser, [
                    {
                        key: "checkProto",
                        value: function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
                            if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
                                return;
                            }
                            var key = prop.key;
                            var name = key.type === "Identifier" ? key.name : key.value;
                            if (name === "__proto__") {
                                if (isRecord) {
                                    this.raise(Errors.RecordNoProto, key);
                                    return;
                                }
                                if (protoRef.used) {
                                    if (refExpressionErrors) {
                                        if (refExpressionErrors.doubleProtoLoc === null) {
                                            refExpressionErrors.doubleProtoLoc = key.loc.start;
                                        }
                                    } else {
                                        this.raise(Errors.DuplicateProto, key);
                                    }
                                }
                                protoRef.used = true;
                            }
                        }
                    },
                    {
                        key: "shouldExitDescending",
                        value: function shouldExitDescending(expr, potentialArrowAt) {
                            return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
                        }
                    },
                    {
                        key: "getExpression",
                        value: function getExpression() {
                            this.enterInitialScopes();
                            this.nextToken();
                            var expr = this.parseExpression();
                            if (!this.match(139)) {
                                this.unexpected();
                            }
                            this.finalizeRemainingComments();
                            expr.comments = this.comments;
                            expr.errors = this.state.errors;
                            if (this.options.tokens) {
                                expr.tokens = this.tokens;
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseExpression",
                        value: function parseExpression(disallowIn, refExpressionErrors) {
                            var _this = this;
                            if (disallowIn) {
                                return this.disallowInAnd(function() {
                                    return _this.parseExpressionBase(refExpressionErrors);
                                });
                            }
                            return this.allowInAnd(function() {
                                return _this.parseExpressionBase(refExpressionErrors);
                            });
                        }
                    },
                    {
                        key: "parseExpressionBase",
                        value: function parseExpressionBase(refExpressionErrors) {
                            var startLoc = this.state.startLoc;
                            var expr = this.parseMaybeAssign(refExpressionErrors);
                            if (this.match(12)) {
                                var node = this.startNodeAt(startLoc);
                                node.expressions = [
                                    expr
                                ];
                                while(this.eat(12)){
                                    node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
                                }
                                this.toReferencedList(node.expressions);
                                return this.finishNode(node, "SequenceExpression");
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseMaybeAssignDisallowIn",
                        value: function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
                            var _this = this;
                            return this.disallowInAnd(function() {
                                return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                            });
                        }
                    },
                    {
                        key: "parseMaybeAssignAllowIn",
                        value: function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
                            var _this = this;
                            return this.allowInAnd(function() {
                                return _this.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                            });
                        }
                    },
                    {
                        key: "setOptionalParametersError",
                        value: function setOptionalParametersError(refExpressionErrors, resultError) {
                            var _resultError$loc;
                            refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
                        }
                    },
                    {
                        key: "parseMaybeAssign",
                        value: function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
                            var startLoc = this.state.startLoc;
                            if (this.isContextual(108)) {
                                if (this.prodParam.hasYield) {
                                    var left2 = this.parseYield();
                                    if (afterLeftParse) {
                                        left2 = afterLeftParse.call(this, left2, startLoc);
                                    }
                                    return left2;
                                }
                            }
                            var ownExpressionErrors;
                            if (refExpressionErrors) {
                                ownExpressionErrors = false;
                            } else {
                                refExpressionErrors = new ExpressionErrors();
                                ownExpressionErrors = true;
                            }
                            var type = this.state.type;
                            if (type === 10 || tokenIsIdentifier(type)) {
                                this.state.potentialArrowAt = this.state.start;
                            }
                            var left = this.parseMaybeConditional(refExpressionErrors);
                            if (afterLeftParse) {
                                left = afterLeftParse.call(this, left, startLoc);
                            }
                            if (tokenIsAssignment(this.state.type)) {
                                var node = this.startNodeAt(startLoc);
                                var operator = this.state.value;
                                node.operator = operator;
                                if (this.match(29)) {
                                    this.toAssignable(left, true);
                                    node.left = left;
                                    var startIndex = startLoc.index;
                                    if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
                                        refExpressionErrors.doubleProtoLoc = null;
                                    }
                                    if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
                                        refExpressionErrors.shorthandAssignLoc = null;
                                    }
                                    if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
                                        this.checkDestructuringPrivate(refExpressionErrors);
                                        refExpressionErrors.privateKeyLoc = null;
                                    }
                                } else {
                                    node.left = left;
                                }
                                this.next();
                                node.right = this.parseMaybeAssign();
                                this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));
                                return node;
                            } else if (ownExpressionErrors) {
                                this.checkExpressionErrors(refExpressionErrors, true);
                            }
                            return left;
                        }
                    },
                    {
                        key: "parseMaybeConditional",
                        value: function parseMaybeConditional(refExpressionErrors) {
                            var startLoc = this.state.startLoc;
                            var potentialArrowAt = this.state.potentialArrowAt;
                            var expr = this.parseExprOps(refExpressionErrors);
                            if (this.shouldExitDescending(expr, potentialArrowAt)) {
                                return expr;
                            }
                            return this.parseConditional(expr, startLoc, refExpressionErrors);
                        }
                    },
                    {
                        key: "parseConditional",
                        value: function parseConditional(expr, startLoc, refExpressionErrors) {
                            if (this.eat(17)) {
                                var node = this.startNodeAt(startLoc);
                                node.test = expr;
                                node.consequent = this.parseMaybeAssignAllowIn();
                                this.expect(14);
                                node.alternate = this.parseMaybeAssign();
                                return this.finishNode(node, "ConditionalExpression");
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseMaybeUnaryOrPrivate",
                        value: function parseMaybeUnaryOrPrivate(refExpressionErrors) {
                            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
                        }
                    },
                    {
                        key: "parseExprOps",
                        value: function parseExprOps(refExpressionErrors) {
                            var startLoc = this.state.startLoc;
                            var potentialArrowAt = this.state.potentialArrowAt;
                            var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
                            if (this.shouldExitDescending(expr, potentialArrowAt)) {
                                return expr;
                            }
                            return this.parseExprOp(expr, startLoc, -1);
                        }
                    },
                    {
                        key: "parseExprOp",
                        value: function parseExprOp(left, leftStartLoc, minPrec) {
                            if (this.isPrivateName(left)) {
                                var value = this.getPrivateNameSV(left);
                                if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                                    this.raise(Errors.PrivateInExpectedIn, left, {
                                        identifierName: value
                                    });
                                }
                                this.classScope.usePrivateName(value, left.loc.start);
                            }
                            var op = this.state.type;
                            if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
                                var prec = tokenOperatorPrecedence(op);
                                if (prec > minPrec) {
                                    if (op === 39) {
                                        this.expectPlugin("pipelineOperator");
                                        if (this.state.inFSharpPipelineDirectBody) {
                                            return left;
                                        }
                                        this.checkPipelineAtInfixOperator(left, leftStartLoc);
                                    }
                                    var node = this.startNodeAt(leftStartLoc);
                                    node.left = left;
                                    node.operator = this.state.value;
                                    var logical = op === 41 || op === 42;
                                    var coalesce = op === 40;
                                    if (coalesce) {
                                        prec = tokenOperatorPrecedence(42);
                                    }
                                    this.next();
                                    if (op === 39 && this.hasPlugin([
                                        "pipelineOperator",
                                        {
                                            proposal: "minimal"
                                        }
                                    ])) {
                                        if (this.state.type === 96 && this.prodParam.hasAwait) {
                                            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                                        }
                                    }
                                    node.right = this.parseExprOpRightExpr(op, prec);
                                    var finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                                    var nextOp = this.state.type;
                                    if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                                        throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
                                    }
                                    return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
                                }
                            }
                            return left;
                        }
                    },
                    {
                        key: "parseExprOpRightExpr",
                        value: function parseExprOpRightExpr(op, prec) {
                            var _this = this;
                            var startLoc = this.state.startLoc;
                            switch(op){
                                case 39:
                                    switch(this.getPluginOption("pipelineOperator", "proposal")){
                                        case "hack":
                                            return this.withTopicBindingContext(function() {
                                                return _this.parseHackPipeBody();
                                            });
                                        case "smart":
                                            return this.withTopicBindingContext(function() {
                                                if (_this.prodParam.hasYield && _this.isContextual(108)) {
                                                    throw _this.raise(Errors.PipeBodyIsTighter, _this.state.startLoc);
                                                }
                                                return _this.parseSmartPipelineBodyInStyle(_this.parseExprOpBaseRightExpr(op, prec), startLoc);
                                            });
                                        case "fsharp":
                                            return this.withSoloAwaitPermittingContext(function() {
                                                return _this.parseFSharpPipelineBody(prec);
                                            });
                                    }
                                default:
                                    return this.parseExprOpBaseRightExpr(op, prec);
                            }
                        }
                    },
                    {
                        key: "parseExprOpBaseRightExpr",
                        value: function parseExprOpBaseRightExpr(op, prec) {
                            var startLoc = this.state.startLoc;
                            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
                        }
                    },
                    {
                        key: "parseHackPipeBody",
                        value: function parseHackPipeBody() {
                            var _body$extra;
                            var startLoc = this.state.startLoc;
                            var body = this.parseMaybeAssign();
                            var requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
                            if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
                                this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
                                    type: body.type
                                });
                            }
                            if (!this.topicReferenceWasUsedInCurrentContext()) {
                                this.raise(Errors.PipeTopicUnused, startLoc);
                            }
                            return body;
                        }
                    },
                    {
                        key: "checkExponentialAfterUnary",
                        value: function checkExponentialAfterUnary(node) {
                            if (this.match(57)) {
                                this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
                            }
                        }
                    },
                    {
                        key: "parseMaybeUnary",
                        value: function parseMaybeUnary(refExpressionErrors, sawUnary) {
                            var startLoc = this.state.startLoc;
                            var isAwait = this.isContextual(96);
                            if (isAwait && this.recordAwaitIfAllowed()) {
                                this.next();
                                var expr2 = this.parseAwait(startLoc);
                                if (!sawUnary) this.checkExponentialAfterUnary(expr2);
                                return expr2;
                            }
                            var update = this.match(34);
                            var node = this.startNode();
                            if (tokenIsPrefix(this.state.type)) {
                                node.operator = this.state.value;
                                node.prefix = true;
                                if (this.match(72)) {
                                    this.expectPlugin("throwExpressions");
                                }
                                var isDelete = this.match(89);
                                this.next();
                                node.argument = this.parseMaybeUnary(null, true);
                                this.checkExpressionErrors(refExpressionErrors, true);
                                if (this.state.strict && isDelete) {
                                    var arg = node.argument;
                                    if (arg.type === "Identifier") {
                                        this.raise(Errors.StrictDelete, node);
                                    } else if (this.hasPropertyAsPrivateName(arg)) {
                                        this.raise(Errors.DeletePrivateField, node);
                                    }
                                }
                                if (!update) {
                                    if (!sawUnary) {
                                        this.checkExponentialAfterUnary(node);
                                    }
                                    return this.finishNode(node, "UnaryExpression");
                                }
                            }
                            var expr = this.parseUpdate(node, update, refExpressionErrors);
                            if (isAwait) {
                                var type = this.state.type;
                                var startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
                                if (startsExpr2 && !this.isAmbiguousAwait()) {
                                    this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
                                    return this.parseAwait(startLoc);
                                }
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseUpdate",
                        value: function parseUpdate(node, update, refExpressionErrors) {
                            if (update) {
                                var updateExpressionNode = node;
                                this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
                                return node;
                            }
                            var startLoc = this.state.startLoc;
                            var expr = this.parseExprSubscripts(refExpressionErrors);
                            if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
                            while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
                                var node2 = this.startNodeAt(startLoc);
                                node2.operator = this.state.value;
                                node2.prefix = false;
                                node2.argument = expr;
                                this.next();
                                this.checkLVal(expr, expr = this.finishNode(node2, "UpdateExpression"));
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseExprSubscripts",
                        value: function parseExprSubscripts(refExpressionErrors) {
                            var startLoc = this.state.startLoc;
                            var potentialArrowAt = this.state.potentialArrowAt;
                            var expr = this.parseExprAtom(refExpressionErrors);
                            if (this.shouldExitDescending(expr, potentialArrowAt)) {
                                return expr;
                            }
                            return this.parseSubscripts(expr, startLoc);
                        }
                    },
                    {
                        key: "parseSubscripts",
                        value: function parseSubscripts(base, startLoc, noCalls) {
                            var state = {
                                optionalChainMember: false,
                                maybeAsyncArrow: this.atPossibleAsyncArrow(base),
                                stop: false
                            };
                            do {
                                base = this.parseSubscript(base, startLoc, noCalls, state);
                                state.maybeAsyncArrow = false;
                            }while (!state.stop);
                            return base;
                        }
                    },
                    {
                        key: "parseSubscript",
                        value: function parseSubscript(base, startLoc, noCalls, state) {
                            var type = this.state.type;
                            if (!noCalls && type === 15) {
                                return this.parseBind(base, startLoc, noCalls, state);
                            } else if (tokenIsTemplate(type)) {
                                return this.parseTaggedTemplateExpression(base, startLoc, state);
                            }
                            var optional = false;
                            if (type === 18) {
                                if (noCalls) {
                                    this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
                                    if (this.lookaheadCharCode() === 40) {
                                        state.stop = true;
                                        return base;
                                    }
                                }
                                state.optionalChainMember = optional = true;
                                this.next();
                            }
                            if (!noCalls && this.match(10)) {
                                return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
                            } else {
                                var computed = this.eat(0);
                                if (computed || optional || this.eat(16)) {
                                    return this.parseMember(base, startLoc, state, computed, optional);
                                } else {
                                    state.stop = true;
                                    return base;
                                }
                            }
                        }
                    },
                    {
                        key: "parseMember",
                        value: function parseMember(base, startLoc, state, computed, optional) {
                            var node = this.startNodeAt(startLoc);
                            node.object = base;
                            node.computed = computed;
                            if (computed) {
                                node.property = this.parseExpression();
                                this.expect(3);
                            } else if (this.match(138)) {
                                if (base.type === "Super") {
                                    this.raise(Errors.SuperPrivateField, startLoc);
                                }
                                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                                node.property = this.parsePrivateName();
                            } else {
                                node.property = this.parseIdentifier(true);
                            }
                            if (state.optionalChainMember) {
                                node.optional = optional;
                                return this.finishNode(node, "OptionalMemberExpression");
                            } else {
                                return this.finishNode(node, "MemberExpression");
                            }
                        }
                    },
                    {
                        key: "parseBind",
                        value: function parseBind(base, startLoc, noCalls, state) {
                            var node = this.startNodeAt(startLoc);
                            node.object = base;
                            this.next();
                            node.callee = this.parseNoCallExpr();
                            state.stop = true;
                            return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
                        }
                    },
                    {
                        key: "parseCoverCallAndAsyncArrowHead",
                        value: function parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
                            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                            var refExpressionErrors = null;
                            this.state.maybeInArrowParameters = true;
                            this.next();
                            var node = this.startNodeAt(startLoc);
                            node.callee = base;
                            var maybeAsyncArrow = state.maybeAsyncArrow, optionalChainMember = state.optionalChainMember;
                            if (maybeAsyncArrow) {
                                this.expressionScope.enter(newAsyncArrowScope());
                                refExpressionErrors = new ExpressionErrors();
                            }
                            if (optionalChainMember) {
                                node.optional = optional;
                            }
                            if (optional) {
                                node.arguments = this.parseCallExpressionArguments(11);
                            } else {
                                node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);
                            }
                            var finishedNode = this.finishCallExpression(node, optionalChainMember);
                            if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
                                state.stop = true;
                                this.checkDestructuringPrivate(refExpressionErrors);
                                this.expressionScope.validateAsPattern();
                                this.expressionScope.exit();
                                finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
                            } else {
                                if (maybeAsyncArrow) {
                                    this.checkExpressionErrors(refExpressionErrors, true);
                                    this.expressionScope.exit();
                                }
                                this.toReferencedArguments(finishedNode);
                            }
                            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                            return finishedNode;
                        }
                    },
                    {
                        key: "toReferencedArguments",
                        value: function toReferencedArguments(node, isParenthesizedExpr) {
                            this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
                        }
                    },
                    {
                        key: "parseTaggedTemplateExpression",
                        value: function parseTaggedTemplateExpression(base, startLoc, state) {
                            var node = this.startNodeAt(startLoc);
                            node.tag = base;
                            node.quasi = this.parseTemplate(true);
                            if (state.optionalChainMember) {
                                this.raise(Errors.OptionalChainingNoTemplate, startLoc);
                            }
                            return this.finishNode(node, "TaggedTemplateExpression");
                        }
                    },
                    {
                        key: "atPossibleAsyncArrow",
                        value: function atPossibleAsyncArrow(base) {
                            return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
                        }
                    },
                    {
                        key: "finishCallExpression",
                        value: function finishCallExpression(node, optional) {
                            if (node.callee.type === "Import") {
                                if (node.arguments.length === 0 || node.arguments.length > 2) {
                                    this.raise(Errors.ImportCallArity, node);
                                } else {
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = node.arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var arg = _step.value;
                                            if (arg.type === "SpreadElement") {
                                                this.raise(Errors.ImportCallSpreadArgument, arg);
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                }
                            }
                            return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
                        }
                    },
                    {
                        key: "parseCallExpressionArguments",
                        value: function parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {
                            var elts = [];
                            var first = true;
                            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                            this.state.inFSharpPipelineDirectBody = false;
                            while(!this.eat(close)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12);
                                    if (this.match(close)) {
                                        if (nodeForExtra) {
                                            this.addTrailingCommaExtraToNode(nodeForExtra);
                                        }
                                        this.next();
                                        break;
                                    }
                                }
                                elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
                            }
                            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                            return elts;
                        }
                    },
                    {
                        key: "shouldParseAsyncArrow",
                        value: function shouldParseAsyncArrow() {
                            return this.match(19) && !this.canInsertSemicolon();
                        }
                    },
                    {
                        key: "parseAsyncArrowFromCallExpression",
                        value: function parseAsyncArrowFromCallExpression(node, call) {
                            var _call$extra;
                            this.resetPreviousNodeTrailingComments(call);
                            this.expect(19);
                            this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
                            if (call.innerComments) {
                                setInnerComments(node, call.innerComments);
                            }
                            if (call.callee.trailingComments) {
                                setInnerComments(node, call.callee.trailingComments);
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseNoCallExpr",
                        value: function parseNoCallExpr() {
                            var startLoc = this.state.startLoc;
                            return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
                        }
                    },
                    {
                        key: "parseExprAtom",
                        value: function parseExprAtom(refExpressionErrors) {
                            var node;
                            var decorators = null;
                            var type = this.state.type;
                            switch(type){
                                case 79:
                                    return this.parseSuper();
                                case 83:
                                    node = this.startNode();
                                    this.next();
                                    if (this.match(16)) {
                                        return this.parseImportMetaProperty(node);
                                    }
                                    if (this.match(10)) {
                                        if (this.options.createImportExpressions) {
                                            return this.parseImportCall(node);
                                        } else {
                                            return this.finishNode(node, "Import");
                                        }
                                    } else {
                                        this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
                                        return this.finishNode(node, "Import");
                                    }
                                case 78:
                                    node = this.startNode();
                                    this.next();
                                    return this.finishNode(node, "ThisExpression");
                                case 90:
                                    {
                                        return this.parseDo(this.startNode(), false);
                                    }
                                case 56:
                                case 31:
                                    {
                                        this.readRegexp();
                                        return this.parseRegExpLiteral(this.state.value);
                                    }
                                case 134:
                                    return this.parseNumericLiteral(this.state.value);
                                case 135:
                                    return this.parseBigIntLiteral(this.state.value);
                                case 133:
                                    return this.parseStringLiteral(this.state.value);
                                case 84:
                                    return this.parseNullLiteral();
                                case 85:
                                    return this.parseBooleanLiteral(true);
                                case 86:
                                    return this.parseBooleanLiteral(false);
                                case 10:
                                    {
                                        var canBeArrow = this.state.potentialArrowAt === this.state.start;
                                        return this.parseParenAndDistinguishExpression(canBeArrow);
                                    }
                                case 2:
                                case 1:
                                    {
                                        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                                    }
                                case 0:
                                    {
                                        return this.parseArrayLike(3, true, false, refExpressionErrors);
                                    }
                                case 6:
                                case 7:
                                    {
                                        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                                    }
                                case 5:
                                    {
                                        return this.parseObjectLike(8, false, false, refExpressionErrors);
                                    }
                                case 68:
                                    return this.parseFunctionOrFunctionSent();
                                case 26:
                                    decorators = this.parseDecorators();
                                case 80:
                                    return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
                                case 77:
                                    return this.parseNewOrNewTarget();
                                case 25:
                                case 24:
                                    return this.parseTemplate(false);
                                case 15:
                                    {
                                        node = this.startNode();
                                        this.next();
                                        node.object = null;
                                        var callee = node.callee = this.parseNoCallExpr();
                                        if (callee.type === "MemberExpression") {
                                            return this.finishNode(node, "BindExpression");
                                        } else {
                                            throw this.raise(Errors.UnsupportedBind, callee);
                                        }
                                    }
                                case 138:
                                    {
                                        this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
                                            identifierName: this.state.value
                                        });
                                        return this.parsePrivateName();
                                    }
                                case 33:
                                    {
                                        return this.parseTopicReferenceThenEqualsSign(54, "%");
                                    }
                                case 32:
                                    {
                                        return this.parseTopicReferenceThenEqualsSign(44, "^");
                                    }
                                case 37:
                                case 38:
                                    {
                                        return this.parseTopicReference("hack");
                                    }
                                case 44:
                                case 54:
                                case 27:
                                    {
                                        var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                                        if (pipeProposal) {
                                            return this.parseTopicReference(pipeProposal);
                                        }
                                        this.unexpected();
                                        break;
                                    }
                                case 47:
                                    {
                                        var lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                                        if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                                            this.expectOnePlugin([
                                                "jsx",
                                                "flow",
                                                "typescript"
                                            ]);
                                        } else {
                                            this.unexpected();
                                        }
                                        break;
                                    }
                                default:
                                    if (type === 136) {
                                        return this.parseDecimalLiteral(this.state.value);
                                    }
                                    if (tokenIsIdentifier(type)) {
                                        if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                                            return this.parseModuleExpression();
                                        }
                                        var canBeArrow1 = this.state.potentialArrowAt === this.state.start;
                                        var containsEsc = this.state.containsEsc;
                                        var id = this.parseIdentifier();
                                        if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                                            var _this_state = this.state, type2 = _this_state.type;
                                            if (type2 === 68) {
                                                this.resetPreviousNodeTrailingComments(id);
                                                this.next();
                                                return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                                            } else if (tokenIsIdentifier(type2)) {
                                                if (this.lookaheadCharCode() === 61) {
                                                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                                                } else {
                                                    return id;
                                                }
                                            } else if (type2 === 90) {
                                                this.resetPreviousNodeTrailingComments(id);
                                                return this.parseDo(this.startNodeAtNode(id), true);
                                            }
                                        }
                                        if (canBeArrow1 && this.match(19) && !this.canInsertSemicolon()) {
                                            this.next();
                                            return this.parseArrowExpression(this.startNodeAtNode(id), [
                                                id
                                            ], false);
                                        }
                                        return id;
                                    } else {
                                        this.unexpected();
                                    }
                            }
                        }
                    },
                    {
                        key: "parseTopicReferenceThenEqualsSign",
                        value: function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
                            var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                            if (pipeProposal) {
                                this.state.type = topicTokenType;
                                this.state.value = topicTokenValue;
                                this.state.pos--;
                                this.state.end--;
                                this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
                                return this.parseTopicReference(pipeProposal);
                            } else {
                                this.unexpected();
                            }
                        }
                    },
                    {
                        key: "parseTopicReference",
                        value: function parseTopicReference(pipeProposal) {
                            var node = this.startNode();
                            var startLoc = this.state.startLoc;
                            var tokenType = this.state.type;
                            this.next();
                            return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
                        }
                    },
                    {
                        key: "finishTopicReference",
                        value: function finishTopicReference(node, startLoc, pipeProposal, tokenType) {
                            if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
                                var nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                                if (!this.topicReferenceIsAllowedInCurrentContext()) {
                                    this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);
                                }
                                this.registerTopicReference();
                                return this.finishNode(node, nodeType);
                            } else {
                                throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
                                    token: tokenLabelName(tokenType)
                                });
                            }
                        }
                    },
                    {
                        key: "testTopicReferenceConfiguration",
                        value: function testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
                            switch(pipeProposal){
                                case "hack":
                                    {
                                        return this.hasPlugin([
                                            "pipelineOperator",
                                            {
                                                topicToken: tokenLabelName(tokenType)
                                            }
                                        ]);
                                    }
                                case "smart":
                                    return tokenType === 27;
                                default:
                                    throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
                            }
                        }
                    },
                    {
                        key: "parseAsyncArrowUnaryFunction",
                        value: function parseAsyncArrowUnaryFunction(node) {
                            this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
                            var params = [
                                this.parseIdentifier()
                            ];
                            this.prodParam.exit();
                            if (this.hasPrecedingLineBreak()) {
                                this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
                            }
                            this.expect(19);
                            return this.parseArrowExpression(node, params, true);
                        }
                    },
                    {
                        key: "parseDo",
                        value: function parseDo(node, isAsync) {
                            this.expectPlugin("doExpressions");
                            if (isAsync) {
                                this.expectPlugin("asyncDoExpressions");
                            }
                            node.async = isAsync;
                            this.next();
                            var oldLabels = this.state.labels;
                            this.state.labels = [];
                            if (isAsync) {
                                this.prodParam.enter(2);
                                node.body = this.parseBlock();
                                this.prodParam.exit();
                            } else {
                                node.body = this.parseBlock();
                            }
                            this.state.labels = oldLabels;
                            return this.finishNode(node, "DoExpression");
                        }
                    },
                    {
                        key: "parseSuper",
                        value: function parseSuper() {
                            var node = this.startNode();
                            this.next();
                            if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
                                this.raise(Errors.SuperNotAllowed, node);
                            } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
                                this.raise(Errors.UnexpectedSuper, node);
                            }
                            if (!this.match(10) && !this.match(0) && !this.match(16)) {
                                this.raise(Errors.UnsupportedSuper, node);
                            }
                            return this.finishNode(node, "Super");
                        }
                    },
                    {
                        key: "parsePrivateName",
                        value: function parsePrivateName() {
                            var node = this.startNode();
                            var id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
                            var name = this.state.value;
                            this.next();
                            node.id = this.createIdentifier(id, name);
                            return this.finishNode(node, "PrivateName");
                        }
                    },
                    {
                        key: "parseFunctionOrFunctionSent",
                        value: function parseFunctionOrFunctionSent() {
                            var node = this.startNode();
                            this.next();
                            if (this.prodParam.hasYield && this.match(16)) {
                                var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
                                this.next();
                                if (this.match(103)) {
                                    this.expectPlugin("functionSent");
                                } else if (!this.hasPlugin("functionSent")) {
                                    this.unexpected();
                                }
                                return this.parseMetaProperty(node, meta, "sent");
                            }
                            return this.parseFunction(node);
                        }
                    },
                    {
                        key: "parseMetaProperty",
                        value: function parseMetaProperty(node, meta, propertyName) {
                            node.meta = meta;
                            var containsEsc = this.state.containsEsc;
                            node.property = this.parseIdentifier(true);
                            if (node.property.name !== propertyName || containsEsc) {
                                this.raise(Errors.UnsupportedMetaProperty, node.property, {
                                    target: meta.name,
                                    onlyValidPropertyName: propertyName
                                });
                            }
                            return this.finishNode(node, "MetaProperty");
                        }
                    },
                    {
                        key: "parseImportMetaProperty",
                        value: function parseImportMetaProperty(node) {
                            var id = this.createIdentifier(this.startNodeAtNode(node), "import");
                            this.next();
                            if (this.isContextual(101)) {
                                if (!this.inModule) {
                                    this.raise(Errors.ImportMetaOutsideModule, id);
                                }
                                this.sawUnambiguousESM = true;
                            } else if (this.isContextual(105) || this.isContextual(97)) {
                                var isSource = this.isContextual(105);
                                if (!isSource) this.unexpected();
                                this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
                                if (!this.options.createImportExpressions) {
                                    throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
                                        phase: this.state.value
                                    });
                                }
                                this.next();
                                node.phase = isSource ? "source" : "defer";
                                return this.parseImportCall(node);
                            }
                            return this.parseMetaProperty(node, id, "meta");
                        }
                    },
                    {
                        key: "parseLiteralAtNode",
                        value: function parseLiteralAtNode(value, type, node) {
                            this.addExtra(node, "rawValue", value);
                            this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
                            node.value = value;
                            this.next();
                            return this.finishNode(node, type);
                        }
                    },
                    {
                        key: "parseLiteral",
                        value: function parseLiteral(value, type) {
                            var node = this.startNode();
                            return this.parseLiteralAtNode(value, type, node);
                        }
                    },
                    {
                        key: "parseStringLiteral",
                        value: function parseStringLiteral(value) {
                            return this.parseLiteral(value, "StringLiteral");
                        }
                    },
                    {
                        key: "parseNumericLiteral",
                        value: function parseNumericLiteral(value) {
                            return this.parseLiteral(value, "NumericLiteral");
                        }
                    },
                    {
                        key: "parseBigIntLiteral",
                        value: function parseBigIntLiteral(value) {
                            return this.parseLiteral(value, "BigIntLiteral");
                        }
                    },
                    {
                        key: "parseDecimalLiteral",
                        value: function parseDecimalLiteral(value) {
                            return this.parseLiteral(value, "DecimalLiteral");
                        }
                    },
                    {
                        key: "parseRegExpLiteral",
                        value: function parseRegExpLiteral(value) {
                            var node = this.startNode();
                            this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
                            node.pattern = value.pattern;
                            node.flags = value.flags;
                            this.next();
                            return this.finishNode(node, "RegExpLiteral");
                        }
                    },
                    {
                        key: "parseBooleanLiteral",
                        value: function parseBooleanLiteral(value) {
                            var node = this.startNode();
                            node.value = value;
                            this.next();
                            return this.finishNode(node, "BooleanLiteral");
                        }
                    },
                    {
                        key: "parseNullLiteral",
                        value: function parseNullLiteral() {
                            var node = this.startNode();
                            this.next();
                            return this.finishNode(node, "NullLiteral");
                        }
                    },
                    {
                        key: "parseParenAndDistinguishExpression",
                        value: function parseParenAndDistinguishExpression(canBeArrow) {
                            var startLoc = this.state.startLoc;
                            var val;
                            this.next();
                            this.expressionScope.enter(newArrowHeadScope());
                            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                            this.state.maybeInArrowParameters = true;
                            this.state.inFSharpPipelineDirectBody = false;
                            var innerStartLoc = this.state.startLoc;
                            var exprList = [];
                            var refExpressionErrors = new ExpressionErrors();
                            var first = true;
                            var spreadStartLoc;
                            var optionalCommaStartLoc;
                            while(!this.match(11)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
                                    if (this.match(11)) {
                                        optionalCommaStartLoc = this.state.startLoc;
                                        break;
                                    }
                                }
                                if (this.match(21)) {
                                    var spreadNodeStartLoc = this.state.startLoc;
                                    spreadStartLoc = this.state.startLoc;
                                    exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
                                    if (!this.checkCommaAfterRest(41)) {
                                        break;
                                    }
                                } else {
                                    exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
                                }
                            }
                            var innerEndLoc = this.state.lastTokEndLoc;
                            this.expect(11);
                            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                            var arrowNode = this.startNodeAt(startLoc);
                            if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
                                this.checkDestructuringPrivate(refExpressionErrors);
                                this.expressionScope.validateAsPattern();
                                this.expressionScope.exit();
                                this.parseArrowExpression(arrowNode, exprList, false);
                                return arrowNode;
                            }
                            this.expressionScope.exit();
                            if (!exprList.length) {
                                this.unexpected(this.state.lastTokStartLoc);
                            }
                            if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
                            if (spreadStartLoc) this.unexpected(spreadStartLoc);
                            this.checkExpressionErrors(refExpressionErrors, true);
                            this.toReferencedListDeep(exprList, true);
                            if (exprList.length > 1) {
                                val = this.startNodeAt(innerStartLoc);
                                val.expressions = exprList;
                                this.finishNode(val, "SequenceExpression");
                                this.resetEndLocation(val, innerEndLoc);
                            } else {
                                val = exprList[0];
                            }
                            return this.wrapParenthesis(startLoc, val);
                        }
                    },
                    {
                        key: "wrapParenthesis",
                        value: function wrapParenthesis(startLoc, expression) {
                            if (!this.options.createParenthesizedExpressions) {
                                this.addExtra(expression, "parenthesized", true);
                                this.addExtra(expression, "parenStart", startLoc.index);
                                this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
                                return expression;
                            }
                            var parenExpression = this.startNodeAt(startLoc);
                            parenExpression.expression = expression;
                            return this.finishNode(parenExpression, "ParenthesizedExpression");
                        }
                    },
                    {
                        key: "shouldParseArrow",
                        value: function shouldParseArrow(params) {
                            return !this.canInsertSemicolon();
                        }
                    },
                    {
                        key: "parseArrow",
                        value: function parseArrow(node) {
                            if (this.eat(19)) {
                                return node;
                            }
                        }
                    },
                    {
                        key: "parseParenItem",
                        value: function parseParenItem(node, startLoc) {
                            return node;
                        }
                    },
                    {
                        key: "parseNewOrNewTarget",
                        value: function parseNewOrNewTarget() {
                            var node = this.startNode();
                            this.next();
                            if (this.match(16)) {
                                var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
                                this.next();
                                var metaProp = this.parseMetaProperty(node, meta, "target");
                                if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
                                    this.raise(Errors.UnexpectedNewTarget, metaProp);
                                }
                                return metaProp;
                            }
                            return this.parseNew(node);
                        }
                    },
                    {
                        key: "parseNew",
                        value: function parseNew(node) {
                            this.parseNewCallee(node);
                            if (this.eat(10)) {
                                var args = this.parseExprList(11);
                                this.toReferencedList(args);
                                node.arguments = args;
                            } else {
                                node.arguments = [];
                            }
                            return this.finishNode(node, "NewExpression");
                        }
                    },
                    {
                        key: "parseNewCallee",
                        value: function parseNewCallee(node) {
                            var isImport = this.match(83);
                            var callee = this.parseNoCallExpr();
                            node.callee = callee;
                            if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
                                this.raise(Errors.ImportCallNotNewExpression, callee);
                            }
                        }
                    },
                    {
                        key: "parseTemplateElement",
                        value: function parseTemplateElement(isTagged) {
                            var _this_state = this.state, start = _this_state.start, startLoc = _this_state.startLoc, end = _this_state.end, value = _this_state.value;
                            var elemStart = start + 1;
                            var elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
                            if (value === null) {
                                if (!isTagged) {
                                    this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
                                }
                            }
                            var isTail = this.match(24);
                            var endOffset = isTail ? -1 : -2;
                            var elemEnd = end + endOffset;
                            elem.value = {
                                raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
                                cooked: value === null ? null : value.slice(1, endOffset)
                            };
                            elem.tail = isTail;
                            this.next();
                            var finishedNode = this.finishNode(elem, "TemplateElement");
                            this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
                            return finishedNode;
                        }
                    },
                    {
                        key: "parseTemplate",
                        value: function parseTemplate(isTagged) {
                            var node = this.startNode();
                            var curElt = this.parseTemplateElement(isTagged);
                            var quasis = [
                                curElt
                            ];
                            var substitutions = [];
                            while(!curElt.tail){
                                substitutions.push(this.parseTemplateSubstitution());
                                this.readTemplateContinuation();
                                quasis.push(curElt = this.parseTemplateElement(isTagged));
                            }
                            node.expressions = substitutions;
                            node.quasis = quasis;
                            return this.finishNode(node, "TemplateLiteral");
                        }
                    },
                    {
                        key: "parseTemplateSubstitution",
                        value: function parseTemplateSubstitution() {
                            return this.parseExpression();
                        }
                    },
                    {
                        key: "parseObjectLike",
                        value: function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
                            if (isRecord) {
                                this.expectPlugin("recordAndTuple");
                            }
                            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                            this.state.inFSharpPipelineDirectBody = false;
                            var propHash = /* @__PURE__ */ Object.create(null);
                            var first = true;
                            var node = this.startNode();
                            node.properties = [];
                            this.next();
                            while(!this.match(close)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12);
                                    if (this.match(close)) {
                                        this.addTrailingCommaExtraToNode(node);
                                        break;
                                    }
                                }
                                var prop = void 0;
                                if (isPattern) {
                                    prop = this.parseBindingProperty();
                                } else {
                                    prop = this.parsePropertyDefinition(refExpressionErrors);
                                    this.checkProto(prop, isRecord, propHash, refExpressionErrors);
                                }
                                if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
                                    this.raise(Errors.InvalidRecordProperty, prop);
                                }
                                {
                                    if (prop.shorthand) {
                                        this.addExtra(prop, "shorthand", true);
                                    }
                                }
                                node.properties.push(prop);
                            }
                            this.next();
                            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                            var type = "ObjectExpression";
                            if (isPattern) {
                                type = "ObjectPattern";
                            } else if (isRecord) {
                                type = "RecordExpression";
                            }
                            return this.finishNode(node, type);
                        }
                    },
                    {
                        key: "addTrailingCommaExtraToNode",
                        value: function addTrailingCommaExtraToNode(node) {
                            this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
                            this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
                        }
                    },
                    {
                        key: "maybeAsyncOrAccessorProp",
                        value: function maybeAsyncOrAccessorProp(prop) {
                            return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
                        }
                    },
                    {
                        key: "parsePropertyDefinition",
                        value: function parsePropertyDefinition(refExpressionErrors) {
                            var decorators = [];
                            if (this.match(26)) {
                                if (this.hasPlugin("decorators")) {
                                    this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
                                }
                                while(this.match(26)){
                                    decorators.push(this.parseDecorator());
                                }
                            }
                            var prop = this.startNode();
                            var isAsync = false;
                            var isAccessor = false;
                            var startLoc;
                            if (this.match(21)) {
                                if (decorators.length) this.unexpected();
                                return this.parseSpread();
                            }
                            if (decorators.length) {
                                prop.decorators = decorators;
                                decorators = [];
                            }
                            prop.method = false;
                            if (refExpressionErrors) {
                                startLoc = this.state.startLoc;
                            }
                            var isGenerator = this.eat(55);
                            this.parsePropertyNamePrefixOperator(prop);
                            var containsEsc = this.state.containsEsc;
                            this.parsePropertyName(prop, refExpressionErrors);
                            if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
                                var key = prop.key;
                                var keyName = key.name;
                                if (keyName === "async" && !this.hasPrecedingLineBreak()) {
                                    isAsync = true;
                                    this.resetPreviousNodeTrailingComments(key);
                                    isGenerator = this.eat(55);
                                    this.parsePropertyName(prop);
                                }
                                if (keyName === "get" || keyName === "set") {
                                    isAccessor = true;
                                    this.resetPreviousNodeTrailingComments(key);
                                    prop.kind = keyName;
                                    if (this.match(55)) {
                                        isGenerator = true;
                                        this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                                            kind: keyName
                                        });
                                        this.next();
                                    }
                                    this.parsePropertyName(prop);
                                }
                            }
                            return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
                        }
                    },
                    {
                        key: "getGetterSetterExpectedParamCount",
                        value: function getGetterSetterExpectedParamCount(method) {
                            return method.kind === "get" ? 0 : 1;
                        }
                    },
                    {
                        key: "getObjectOrClassMethodParams",
                        value: function getObjectOrClassMethodParams(method) {
                            return method.params;
                        }
                    },
                    {
                        key: "checkGetterSetterParams",
                        value: function checkGetterSetterParams(method) {
                            var _params;
                            var paramCount = this.getGetterSetterExpectedParamCount(method);
                            var params = this.getObjectOrClassMethodParams(method);
                            if (params.length !== paramCount) {
                                this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
                            }
                            if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
                                this.raise(Errors.BadSetterRestParameter, method);
                            }
                        }
                    },
                    {
                        key: "parseObjectMethod",
                        value: function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
                            if (isAccessor) {
                                var finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
                                this.checkGetterSetterParams(finishedProp);
                                return finishedProp;
                            }
                            if (isAsync || isGenerator || this.match(10)) {
                                if (isPattern) this.unexpected();
                                prop.kind = "method";
                                prop.method = true;
                                return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
                            }
                        }
                    },
                    {
                        key: "parseObjectProperty",
                        value: function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
                            prop.shorthand = false;
                            if (this.eat(14)) {
                                prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
                                return this.finishNode(prop, "ObjectProperty");
                            }
                            if (!prop.computed && prop.key.type === "Identifier") {
                                this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
                                if (isPattern) {
                                    prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
                                } else if (this.match(29)) {
                                    var shorthandAssignLoc = this.state.startLoc;
                                    if (refExpressionErrors != null) {
                                        if (refExpressionErrors.shorthandAssignLoc === null) {
                                            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                                        }
                                    } else {
                                        this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
                                    }
                                    prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
                                } else {
                                    prop.value = cloneIdentifier(prop.key);
                                }
                                prop.shorthand = true;
                                return this.finishNode(prop, "ObjectProperty");
                            }
                        }
                    },
                    {
                        key: "parseObjPropValue",
                        value: function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
                            var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
                            if (!node) this.unexpected();
                            return node;
                        }
                    },
                    {
                        key: "parsePropertyName",
                        value: function parsePropertyName(prop, refExpressionErrors) {
                            if (this.eat(0)) {
                                prop.computed = true;
                                prop.key = this.parseMaybeAssignAllowIn();
                                this.expect(3);
                            } else {
                                var _this_state = this.state, type = _this_state.type, value = _this_state.value;
                                var key;
                                if (tokenIsKeywordOrIdentifier(type)) {
                                    key = this.parseIdentifier(true);
                                } else {
                                    switch(type){
                                        case 134:
                                            key = this.parseNumericLiteral(value);
                                            break;
                                        case 133:
                                            key = this.parseStringLiteral(value);
                                            break;
                                        case 135:
                                            key = this.parseBigIntLiteral(value);
                                            break;
                                        case 138:
                                            {
                                                var privateKeyLoc = this.state.startLoc;
                                                if (refExpressionErrors != null) {
                                                    if (refExpressionErrors.privateKeyLoc === null) {
                                                        refExpressionErrors.privateKeyLoc = privateKeyLoc;
                                                    }
                                                } else {
                                                    this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                                                }
                                                key = this.parsePrivateName();
                                                break;
                                            }
                                        default:
                                            if (type === 136) {
                                                key = this.parseDecimalLiteral(value);
                                                break;
                                            }
                                            this.unexpected();
                                    }
                                }
                                prop.key = key;
                                if (type !== 138) {
                                    prop.computed = false;
                                }
                            }
                        }
                    },
                    {
                        key: "initFunction",
                        value: function initFunction(node, isAsync) {
                            node.id = null;
                            node.generator = false;
                            node.async = isAsync;
                        }
                    },
                    {
                        key: "parseMethod",
                        value: function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {
                            var inClassScope = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
                            this.initFunction(node, isAsync);
                            node.generator = isGenerator;
                            this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
                            this.prodParam.enter(functionFlags(isAsync, node.generator));
                            this.parseFunctionParams(node, isConstructor);
                            var finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
                            this.prodParam.exit();
                            this.scope.exit();
                            return finishedNode;
                        }
                    },
                    {
                        key: "parseArrayLike",
                        value: function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
                            if (isTuple) {
                                this.expectPlugin("recordAndTuple");
                            }
                            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                            this.state.inFSharpPipelineDirectBody = false;
                            var node = this.startNode();
                            this.next();
                            node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
                            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                            return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
                        }
                    },
                    {
                        key: "parseArrowExpression",
                        value: function parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
                            this.scope.enter(2 | 4);
                            var flags = functionFlags(isAsync, false);
                            if (!this.match(5) && this.prodParam.hasIn) {
                                flags |= 8;
                            }
                            this.prodParam.enter(flags);
                            this.initFunction(node, isAsync);
                            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                            if (params) {
                                this.state.maybeInArrowParameters = true;
                                this.setArrowFunctionParameters(node, params, trailingCommaLoc);
                            }
                            this.state.maybeInArrowParameters = false;
                            this.parseFunctionBody(node, true);
                            this.prodParam.exit();
                            this.scope.exit();
                            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                            return this.finishNode(node, "ArrowFunctionExpression");
                        }
                    },
                    {
                        key: "setArrowFunctionParameters",
                        value: function setArrowFunctionParameters(node, params, trailingCommaLoc) {
                            this.toAssignableList(params, trailingCommaLoc, false);
                            node.params = params;
                        }
                    },
                    {
                        key: "parseFunctionBodyAndFinish",
                        value: function parseFunctionBodyAndFinish(node, type) {
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            this.parseFunctionBody(node, false, isMethod);
                            return this.finishNode(node, type);
                        }
                    },
                    {
                        key: "parseFunctionBody",
                        value: function parseFunctionBody(node, allowExpression) {
                            var _this = this;
                            var isMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            var isExpression = allowExpression && !this.match(5);
                            this.expressionScope.enter(newExpressionScope());
                            if (isExpression) {
                                node.body = this.parseMaybeAssign();
                                this.checkParams(node, false, allowExpression, false);
                            } else {
                                var oldStrict = this.state.strict;
                                var oldLabels = this.state.labels;
                                this.state.labels = [];
                                this.prodParam.enter(this.prodParam.currentFlags() | 4);
                                node.body = this.parseBlock(true, false, function(hasStrictModeDirective) {
                                    var nonSimple = !_this.isSimpleParamList(node.params);
                                    if (hasStrictModeDirective && nonSimple) {
                                        _this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
                                    }
                                    var strictModeChanged = !oldStrict && _this.state.strict;
                                    _this.checkParams(node, !_this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
                                    if (_this.state.strict && node.id) {
                                        _this.checkIdentifier(node.id, 65, strictModeChanged);
                                    }
                                });
                                this.prodParam.exit();
                                this.state.labels = oldLabels;
                            }
                            this.expressionScope.exit();
                        }
                    },
                    {
                        key: "isSimpleParameter",
                        value: function isSimpleParameter(node) {
                            return node.type === "Identifier";
                        }
                    },
                    {
                        key: "isSimpleParamList",
                        value: function isSimpleParamList(params) {
                            for(var i = 0, len = params.length; i < len; i++){
                                if (!this.isSimpleParameter(params[i])) return false;
                            }
                            return true;
                        }
                    },
                    {
                        key: "checkParams",
                        value: function checkParams(node, allowDuplicates, isArrowFunction) {
                            var strictModeChanged = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                            var checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
                            var formalParameters = {
                                type: "FormalParameters"
                            };
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var param = _step.value;
                                    this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "parseExprList",
                        value: function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
                            var elts = [];
                            var first = true;
                            while(!this.eat(close)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12);
                                    if (this.match(close)) {
                                        if (nodeForExtra) {
                                            this.addTrailingCommaExtraToNode(nodeForExtra);
                                        }
                                        this.next();
                                        break;
                                    }
                                }
                                elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
                            }
                            return elts;
                        }
                    },
                    {
                        key: "parseExprListItem",
                        value: function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
                            var elt;
                            if (this.match(12)) {
                                if (!allowEmpty) {
                                    this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
                                        unexpected: ","
                                    });
                                }
                                elt = null;
                            } else if (this.match(21)) {
                                var spreadNodeStartLoc = this.state.startLoc;
                                elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
                            } else if (this.match(17)) {
                                this.expectPlugin("partialApplication");
                                if (!allowPlaceholder) {
                                    this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
                                }
                                var node = this.startNode();
                                this.next();
                                elt = this.finishNode(node, "ArgumentPlaceholder");
                            } else {
                                elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
                            }
                            return elt;
                        }
                    },
                    {
                        key: "parseIdentifier",
                        value: function parseIdentifier(liberal) {
                            var node = this.startNode();
                            var name = this.parseIdentifierName(liberal);
                            return this.createIdentifier(node, name);
                        }
                    },
                    {
                        key: "createIdentifier",
                        value: function createIdentifier(node, name) {
                            node.name = name;
                            node.loc.identifierName = name;
                            return this.finishNode(node, "Identifier");
                        }
                    },
                    {
                        key: "parseIdentifierName",
                        value: function parseIdentifierName(liberal) {
                            var name;
                            var _this_state = this.state, startLoc = _this_state.startLoc, type = _this_state.type;
                            if (tokenIsKeywordOrIdentifier(type)) {
                                name = this.state.value;
                            } else {
                                this.unexpected();
                            }
                            var tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
                            if (liberal) {
                                if (tokenIsKeyword2) {
                                    this.replaceToken(132);
                                }
                            } else {
                                this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
                            }
                            this.next();
                            return name;
                        }
                    },
                    {
                        key: "checkReservedWord",
                        value: function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
                            if (word.length > 10) {
                                return;
                            }
                            if (!canBeReservedWord(word)) {
                                return;
                            }
                            if (checkKeywords && isKeyword(word)) {
                                this.raise(Errors.UnexpectedKeyword, startLoc, {
                                    keyword: word
                                });
                                return;
                            }
                            var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
                            if (reservedTest(word, this.inModule)) {
                                this.raise(Errors.UnexpectedReservedWord, startLoc, {
                                    reservedWord: word
                                });
                                return;
                            } else if (word === "yield") {
                                if (this.prodParam.hasYield) {
                                    this.raise(Errors.YieldBindingIdentifier, startLoc);
                                    return;
                                }
                            } else if (word === "await") {
                                if (this.prodParam.hasAwait) {
                                    this.raise(Errors.AwaitBindingIdentifier, startLoc);
                                    return;
                                }
                                if (this.scope.inStaticBlock) {
                                    this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
                                    return;
                                }
                                this.expressionScope.recordAsyncArrowParametersError(startLoc);
                            } else if (word === "arguments") {
                                if (this.scope.inClassAndNotInNonArrowFunction) {
                                    this.raise(Errors.ArgumentsInClass, startLoc);
                                    return;
                                }
                            }
                        }
                    },
                    {
                        key: "recordAwaitIfAllowed",
                        value: function recordAwaitIfAllowed() {
                            var isAwaitAllowed = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
                            if (isAwaitAllowed && !this.scope.inFunction) {
                                this.state.hasTopLevelAwait = true;
                            }
                            return isAwaitAllowed;
                        }
                    },
                    {
                        key: "parseAwait",
                        value: function parseAwait(startLoc) {
                            var node = this.startNodeAt(startLoc);
                            this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
                            if (this.eat(55)) {
                                this.raise(Errors.ObsoleteAwaitStar, node);
                            }
                            if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
                                if (this.isAmbiguousAwait()) {
                                    this.ambiguousScriptDifferentAst = true;
                                } else {
                                    this.sawUnambiguousESM = true;
                                }
                            }
                            if (!this.state.soloAwait) {
                                node.argument = this.parseMaybeUnary(null, true);
                            }
                            return this.finishNode(node, "AwaitExpression");
                        }
                    },
                    {
                        key: "isAmbiguousAwait",
                        value: function isAmbiguousAwait() {
                            if (this.hasPrecedingLineBreak()) return true;
                            var type = this.state.type;
                            return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
                        }
                    },
                    {
                        key: "parseYield",
                        value: function parseYield() {
                            var node = this.startNode();
                            this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
                            this.next();
                            var delegating = false;
                            var argument = null;
                            if (!this.hasPrecedingLineBreak()) {
                                delegating = this.eat(55);
                                switch(this.state.type){
                                    case 13:
                                    case 139:
                                    case 8:
                                    case 11:
                                    case 3:
                                    case 9:
                                    case 14:
                                    case 12:
                                        if (!delegating) break;
                                    default:
                                        argument = this.parseMaybeAssign();
                                }
                            }
                            node.delegate = delegating;
                            node.argument = argument;
                            return this.finishNode(node, "YieldExpression");
                        }
                    },
                    {
                        key: "parseImportCall",
                        value: function parseImportCall(node) {
                            this.next();
                            node.source = this.parseMaybeAssignAllowIn();
                            node.options = null;
                            if (this.eat(12)) {
                                if (!this.match(11)) {
                                    node.options = this.parseMaybeAssignAllowIn();
                                    if (this.eat(12) && !this.match(11)) {
                                        do {
                                            this.parseMaybeAssignAllowIn();
                                        }while (this.eat(12) && !this.match(11));
                                        this.raise(Errors.ImportCallArity, node);
                                    }
                                }
                            }
                            this.expect(11);
                            return this.finishNode(node, "ImportExpression");
                        }
                    },
                    {
                        key: "checkPipelineAtInfixOperator",
                        value: function checkPipelineAtInfixOperator(left, leftStartLoc) {
                            if (this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "smart"
                                }
                            ])) {
                                if (left.type === "SequenceExpression") {
                                    this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
                                }
                            }
                        }
                    },
                    {
                        key: "parseSmartPipelineBodyInStyle",
                        value: function parseSmartPipelineBodyInStyle(childExpr, startLoc) {
                            if (this.isSimpleReference(childExpr)) {
                                var bodyNode = this.startNodeAt(startLoc);
                                bodyNode.callee = childExpr;
                                return this.finishNode(bodyNode, "PipelineBareFunction");
                            } else {
                                var bodyNode1 = this.startNodeAt(startLoc);
                                this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
                                bodyNode1.expression = childExpr;
                                return this.finishNode(bodyNode1, "PipelineTopicExpression");
                            }
                        }
                    },
                    {
                        key: "isSimpleReference",
                        value: function isSimpleReference(expression) {
                            switch(expression.type){
                                case "MemberExpression":
                                    return !expression.computed && this.isSimpleReference(expression.object);
                                case "Identifier":
                                    return true;
                                default:
                                    return false;
                            }
                        }
                    },
                    {
                        key: "checkSmartPipeTopicBodyEarlyErrors",
                        value: function checkSmartPipeTopicBodyEarlyErrors(startLoc) {
                            if (this.match(19)) {
                                throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
                            }
                            if (!this.topicReferenceWasUsedInCurrentContext()) {
                                this.raise(Errors.PipelineTopicUnused, startLoc);
                            }
                        }
                    },
                    {
                        key: "withTopicBindingContext",
                        value: function withTopicBindingContext(callback) {
                            var outerContextTopicState = this.state.topicContext;
                            this.state.topicContext = {
                                maxNumOfResolvableTopics: 1,
                                maxTopicIndex: null
                            };
                            try {
                                return callback();
                            } finally{
                                this.state.topicContext = outerContextTopicState;
                            }
                        }
                    },
                    {
                        key: "withSmartMixTopicForbiddingContext",
                        value: function withSmartMixTopicForbiddingContext(callback) {
                            if (this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "smart"
                                }
                            ])) {
                                var outerContextTopicState = this.state.topicContext;
                                this.state.topicContext = {
                                    maxNumOfResolvableTopics: 0,
                                    maxTopicIndex: null
                                };
                                try {
                                    return callback();
                                } finally{
                                    this.state.topicContext = outerContextTopicState;
                                }
                            } else {
                                return callback();
                            }
                        }
                    },
                    {
                        key: "withSoloAwaitPermittingContext",
                        value: function withSoloAwaitPermittingContext(callback) {
                            var outerContextSoloAwaitState = this.state.soloAwait;
                            this.state.soloAwait = true;
                            try {
                                return callback();
                            } finally{
                                this.state.soloAwait = outerContextSoloAwaitState;
                            }
                        }
                    },
                    {
                        key: "allowInAnd",
                        value: function allowInAnd(callback) {
                            var flags = this.prodParam.currentFlags();
                            var prodParamToSet = 8 & ~flags;
                            if (prodParamToSet) {
                                this.prodParam.enter(flags | 8);
                                try {
                                    return callback();
                                } finally{
                                    this.prodParam.exit();
                                }
                            }
                            return callback();
                        }
                    },
                    {
                        key: "disallowInAnd",
                        value: function disallowInAnd(callback) {
                            var flags = this.prodParam.currentFlags();
                            var prodParamToClear = 8 & flags;
                            if (prodParamToClear) {
                                this.prodParam.enter(flags & ~8);
                                try {
                                    return callback();
                                } finally{
                                    this.prodParam.exit();
                                }
                            }
                            return callback();
                        }
                    },
                    {
                        key: "registerTopicReference",
                        value: function registerTopicReference() {
                            this.state.topicContext.maxTopicIndex = 0;
                        }
                    },
                    {
                        key: "topicReferenceIsAllowedInCurrentContext",
                        value: function topicReferenceIsAllowedInCurrentContext() {
                            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                        }
                    },
                    {
                        key: "topicReferenceWasUsedInCurrentContext",
                        value: function topicReferenceWasUsedInCurrentContext() {
                            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
                        }
                    },
                    {
                        key: "parseFSharpPipelineBody",
                        value: function parseFSharpPipelineBody(prec) {
                            var startLoc = this.state.startLoc;
                            this.state.potentialArrowAt = this.state.start;
                            var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
                            this.state.inFSharpPipelineDirectBody = true;
                            var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
                            this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
                            return ret;
                        }
                    },
                    {
                        key: "parseModuleExpression",
                        value: function parseModuleExpression() {
                            this.expectPlugin("moduleBlocks");
                            var node = this.startNode();
                            this.next();
                            if (!this.match(5)) {
                                this.unexpected(null, 5);
                            }
                            var program = this.startNodeAt(this.state.endLoc);
                            this.next();
                            var revertScopes = this.initializeScopes(true);
                            this.enterInitialScopes();
                            try {
                                node.body = this.parseProgram(program, 8, "module");
                            } finally{
                                revertScopes();
                            }
                            return this.finishNode(node, "ModuleExpression");
                        }
                    },
                    {
                        key: "parsePropertyNamePrefixOperator",
                        value: function parsePropertyNamePrefixOperator(prop) {}
                    }
                ]);
                return ExpressionParser;
            }(LValParser);
            var loopLabel = {
                kind: 1
            };
            var switchLabel = {
                kind: 2
            };
            var loneSurrogate = RegExp("[\uD800-\uDFFF]", "u");
            var keywordRelationalOperator = RegExp("in(?:stanceof)?", "y");
            function babel7CompatTokens(tokens, input) {
                for(var i = 0; i < tokens.length; i++){
                    var token = tokens[i];
                    var type = token.type;
                    if (typeof type === "number") {
                        {
                            if (type === 138) {
                                var loc = token.loc, start = token.start, value = token.value, end = token.end;
                                var hashEndPos = start + 1;
                                var hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                                tokens.splice(i, 1, new Token({
                                    type: getExportedToken(27),
                                    value: "#",
                                    start: start,
                                    end: hashEndPos,
                                    startLoc: loc.start,
                                    endLoc: hashEndLoc
                                }), new Token({
                                    type: getExportedToken(132),
                                    value: value,
                                    start: hashEndPos,
                                    end: end,
                                    startLoc: hashEndLoc,
                                    endLoc: loc.end
                                }));
                                i++;
                                continue;
                            }
                            if (tokenIsTemplate(type)) {
                                var loc1 = token.loc, start1 = token.start, value1 = token.value, end1 = token.end;
                                var backquoteEnd = start1 + 1;
                                var backquoteEndLoc = createPositionWithColumnOffset(loc1.start, 1);
                                var startToken = void 0;
                                if (input.charCodeAt(start1) === 96) {
                                    startToken = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: start1,
                                        end: backquoteEnd,
                                        startLoc: loc1.start,
                                        endLoc: backquoteEndLoc
                                    });
                                } else {
                                    startToken = new Token({
                                        type: getExportedToken(8),
                                        value: "}",
                                        start: start1,
                                        end: backquoteEnd,
                                        startLoc: loc1.start,
                                        endLoc: backquoteEndLoc
                                    });
                                }
                                var templateValue = void 0, templateElementEnd = void 0, templateElementEndLoc = void 0, endToken = void 0;
                                if (type === 24) {
                                    templateElementEnd = end1 - 1;
                                    templateElementEndLoc = createPositionWithColumnOffset(loc1.end, -1);
                                    templateValue = value1 === null ? null : value1.slice(1, -1);
                                    endToken = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: templateElementEnd,
                                        end: end1,
                                        startLoc: templateElementEndLoc,
                                        endLoc: loc1.end
                                    });
                                } else {
                                    templateElementEnd = end1 - 2;
                                    templateElementEndLoc = createPositionWithColumnOffset(loc1.end, -2);
                                    templateValue = value1 === null ? null : value1.slice(1, -2);
                                    endToken = new Token({
                                        type: getExportedToken(23),
                                        value: "${",
                                        start: templateElementEnd,
                                        end: end1,
                                        startLoc: templateElementEndLoc,
                                        endLoc: loc1.end
                                    });
                                }
                                tokens.splice(i, 1, startToken, new Token({
                                    type: getExportedToken(20),
                                    value: templateValue,
                                    start: backquoteEnd,
                                    end: templateElementEnd,
                                    startLoc: backquoteEndLoc,
                                    endLoc: templateElementEndLoc
                                }), endToken);
                                i += 2;
                                continue;
                            }
                        }
                        token.type = getExportedToken(type);
                    }
                }
                return tokens;
            }
            var StatementParser = /*#__PURE__*/ function(ExpressionParser) {
                _inherits(StatementParser, ExpressionParser);
                function StatementParser() {
                    _class_call_check(this, StatementParser);
                    return _call_super(this, StatementParser, arguments);
                }
                _create_class(StatementParser, [
                    {
                        key: "parseTopLevel",
                        value: function parseTopLevel(file, program) {
                            file.program = this.parseProgram(program);
                            file.comments = this.comments;
                            if (this.options.tokens) {
                                file.tokens = babel7CompatTokens(this.tokens, this.input);
                            }
                            return this.finishNode(file, "File");
                        }
                    },
                    {
                        key: "parseProgram",
                        value: function parseProgram(program) {
                            var end = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 139, sourceType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
                            program.sourceType = sourceType;
                            program.interpreter = this.parseInterpreterDirective();
                            this.parseBlockBody(program, true, true, end);
                            if (this.inModule) {
                                if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = Array.from(this.scope.undefinedExports)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var _step_value = _sliced_to_array(_step.value, 2), localName = _step_value[0], at = _step_value[1];
                                            this.raise(Errors.ModuleExportUndefined, at, {
                                                localName: localName
                                            });
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                }
                                this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
                            }
                            var finishedProgram;
                            if (end === 139) {
                                finishedProgram = this.finishNode(program, "Program");
                            } else {
                                finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
                            }
                            return finishedProgram;
                        }
                    },
                    {
                        key: "stmtToDirective",
                        value: function stmtToDirective(stmt) {
                            var directive = stmt;
                            directive.type = "Directive";
                            directive.value = directive.expression;
                            delete directive.expression;
                            var directiveLiteral = directive.value;
                            var expressionValue = directiveLiteral.value;
                            var raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
                            var val = directiveLiteral.value = raw.slice(1, -1);
                            this.addExtra(directiveLiteral, "raw", raw);
                            this.addExtra(directiveLiteral, "rawValue", val);
                            this.addExtra(directiveLiteral, "expressionValue", expressionValue);
                            directiveLiteral.type = "DirectiveLiteral";
                            return directive;
                        }
                    },
                    {
                        key: "parseInterpreterDirective",
                        value: function parseInterpreterDirective() {
                            if (!this.match(28)) {
                                return null;
                            }
                            var node = this.startNode();
                            node.value = this.state.value;
                            this.next();
                            return this.finishNode(node, "InterpreterDirective");
                        }
                    },
                    {
                        key: "isLet",
                        value: function isLet() {
                            if (!this.isContextual(100)) {
                                return false;
                            }
                            return this.hasFollowingBindingAtom();
                        }
                    },
                    {
                        key: "chStartsBindingIdentifier",
                        value: function chStartsBindingIdentifier(ch, pos) {
                            if (isIdentifierStart(ch)) {
                                keywordRelationalOperator.lastIndex = pos;
                                if (keywordRelationalOperator.test(this.input)) {
                                    var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                                    if (!isIdentifierChar(endCh) && endCh !== 92) {
                                        return false;
                                    }
                                }
                                return true;
                            } else if (ch === 92) {
                                return true;
                            } else {
                                return false;
                            }
                        }
                    },
                    {
                        key: "chStartsBindingPattern",
                        value: function chStartsBindingPattern(ch) {
                            return ch === 91 || ch === 123;
                        }
                    },
                    {
                        key: "hasFollowingBindingAtom",
                        value: function hasFollowingBindingAtom() {
                            var next = this.nextTokenStart();
                            var nextCh = this.codePointAtPos(next);
                            return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
                        }
                    },
                    {
                        key: "hasInLineFollowingBindingIdentifierOrBrace",
                        value: function hasInLineFollowingBindingIdentifierOrBrace() {
                            var next = this.nextTokenInLineStart();
                            var nextCh = this.codePointAtPos(next);
                            return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
                        }
                    },
                    {
                        key: "startsUsingForOf",
                        value: function startsUsingForOf() {
                            var _this_lookahead = this.lookahead(), type = _this_lookahead.type, containsEsc = _this_lookahead.containsEsc;
                            if (type === 102 && !containsEsc) {
                                return false;
                            } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
                                this.expectPlugin("explicitResourceManagement");
                                return true;
                            }
                        }
                    },
                    {
                        key: "startsAwaitUsing",
                        value: function startsAwaitUsing() {
                            var next = this.nextTokenInLineStart();
                            if (this.isUnparsedContextual(next, "using")) {
                                next = this.nextTokenInLineStartSince(next + 5);
                                var nextCh = this.codePointAtPos(next);
                                if (this.chStartsBindingIdentifier(nextCh, next)) {
                                    this.expectPlugin("explicitResourceManagement");
                                    return true;
                                }
                            }
                            return false;
                        }
                    },
                    {
                        key: "parseModuleItem",
                        value: function parseModuleItem() {
                            return this.parseStatementLike(1 | 2 | 4 | 8);
                        }
                    },
                    {
                        key: "parseStatementListItem",
                        value: function parseStatementListItem() {
                            return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
                        }
                    },
                    {
                        key: "parseStatementOrSloppyAnnexBFunctionDeclaration",
                        value: function parseStatementOrSloppyAnnexBFunctionDeclaration() {
                            var allowLabeledFunction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                            var flags = 0;
                            if (this.options.annexB && !this.state.strict) {
                                flags |= 4;
                                if (allowLabeledFunction) {
                                    flags |= 8;
                                }
                            }
                            return this.parseStatementLike(flags);
                        }
                    },
                    {
                        key: "parseStatement",
                        value: function parseStatement() {
                            return this.parseStatementLike(0);
                        }
                    },
                    {
                        key: "parseStatementLike",
                        value: function parseStatementLike(flags) {
                            var decorators = null;
                            if (this.match(26)) {
                                decorators = this.parseDecorators(true);
                            }
                            return this.parseStatementContent(flags, decorators);
                        }
                    },
                    {
                        key: "parseStatementContent",
                        value: function parseStatementContent(flags, decorators) {
                            var startType = this.state.type;
                            var node = this.startNode();
                            var allowDeclaration = !!(flags & 2);
                            var allowFunctionDeclaration = !!(flags & 4);
                            var topLevel = flags & 1;
                            switch(startType){
                                case 60:
                                    return this.parseBreakContinueStatement(node, true);
                                case 63:
                                    return this.parseBreakContinueStatement(node, false);
                                case 64:
                                    return this.parseDebuggerStatement(node);
                                case 90:
                                    return this.parseDoWhileStatement(node);
                                case 91:
                                    return this.parseForStatement(node);
                                case 68:
                                    if (this.lookaheadCharCode() === 46) break;
                                    if (!allowFunctionDeclaration) {
                                        this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
                                    }
                                    return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
                                case 80:
                                    if (!allowDeclaration) this.unexpected();
                                    return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
                                case 69:
                                    return this.parseIfStatement(node);
                                case 70:
                                    return this.parseReturnStatement(node);
                                case 71:
                                    return this.parseSwitchStatement(node);
                                case 72:
                                    return this.parseThrowStatement(node);
                                case 73:
                                    return this.parseTryStatement(node);
                                case 96:
                                    if (!this.state.containsEsc && this.startsAwaitUsing()) {
                                        if (!this.recordAwaitIfAllowed()) {
                                            this.raise(Errors.AwaitUsingNotInAsyncContext, node);
                                        } else if (!allowDeclaration) {
                                            this.raise(Errors.UnexpectedLexicalDeclaration, node);
                                        }
                                        this.next();
                                        return this.parseVarStatement(node, "await using");
                                    }
                                    break;
                                case 107:
                                    if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
                                        break;
                                    }
                                    this.expectPlugin("explicitResourceManagement");
                                    if (!this.scope.inModule && this.scope.inTopLevel) {
                                        this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
                                    } else if (!allowDeclaration) {
                                        this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
                                    }
                                    return this.parseVarStatement(node, "using");
                                case 100:
                                    {
                                        if (this.state.containsEsc) {
                                            break;
                                        }
                                        var next = this.nextTokenStart();
                                        var nextCh = this.codePointAtPos(next);
                                        if (nextCh !== 91) {
                                            if (!allowDeclaration && this.hasFollowingLineBreak()) break;
                                            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                                                break;
                                            }
                                        }
                                    }
                                case 75:
                                    {
                                        if (!allowDeclaration) {
                                            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
                                        }
                                    }
                                case 74:
                                    {
                                        var kind = this.state.value;
                                        return this.parseVarStatement(node, kind);
                                    }
                                case 92:
                                    return this.parseWhileStatement(node);
                                case 76:
                                    return this.parseWithStatement(node);
                                case 5:
                                    return this.parseBlock();
                                case 13:
                                    return this.parseEmptyStatement(node);
                                case 83:
                                    {
                                        var nextTokenCharCode = this.lookaheadCharCode();
                                        if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                                            break;
                                        }
                                    }
                                case 82:
                                    {
                                        if (!this.options.allowImportExportEverywhere && !topLevel) {
                                            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
                                        }
                                        this.next();
                                        var result;
                                        if (startType === 83) {
                                            result = this.parseImport(node);
                                            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                                                this.sawUnambiguousESM = true;
                                            }
                                        } else {
                                            result = this.parseExport(node, decorators);
                                            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                                                this.sawUnambiguousESM = true;
                                            }
                                        }
                                        this.assertModuleNodeAllowed(result);
                                        return result;
                                    }
                                default:
                                    {
                                        if (this.isAsyncFunction()) {
                                            if (!allowDeclaration) {
                                                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
                                            }
                                            this.next();
                                            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
                                        }
                                    }
                            }
                            var maybeName = this.state.value;
                            var expr = this.parseExpression();
                            if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
                                return this.parseLabeledStatement(node, maybeName, expr, flags);
                            } else {
                                return this.parseExpressionStatement(node, expr, decorators);
                            }
                        }
                    },
                    {
                        key: "assertModuleNodeAllowed",
                        value: function assertModuleNodeAllowed(node) {
                            if (!this.options.allowImportExportEverywhere && !this.inModule) {
                                this.raise(Errors.ImportOutsideModule, node);
                            }
                        }
                    },
                    {
                        key: "decoratorsEnabledBeforeExport",
                        value: function decoratorsEnabledBeforeExport() {
                            if (this.hasPlugin("decorators-legacy")) return true;
                            return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
                        }
                    },
                    {
                        key: "maybeTakeDecorators",
                        value: function maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
                            if (maybeDecorators) {
                                if (classNode.decorators && classNode.decorators.length > 0) {
                                    var _classNode_decorators;
                                    if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                                        this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
                                    }
                                    (_classNode_decorators = classNode.decorators).unshift.apply(_classNode_decorators, _to_consumable_array(maybeDecorators));
                                } else {
                                    classNode.decorators = maybeDecorators;
                                }
                                this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
                                if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
                            }
                            return classNode;
                        }
                    },
                    {
                        key: "canHaveLeadingDecorator",
                        value: function canHaveLeadingDecorator() {
                            return this.match(80);
                        }
                    },
                    {
                        key: "parseDecorators",
                        value: function parseDecorators(allowExport) {
                            var decorators = [];
                            do {
                                decorators.push(this.parseDecorator());
                            }while (this.match(26));
                            if (this.match(82)) {
                                if (!allowExport) {
                                    this.unexpected();
                                }
                                if (!this.decoratorsEnabledBeforeExport()) {
                                    this.raise(Errors.DecoratorExportClass, this.state.startLoc);
                                }
                            } else if (!this.canHaveLeadingDecorator()) {
                                throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
                            }
                            return decorators;
                        }
                    },
                    {
                        key: "parseDecorator",
                        value: function parseDecorator() {
                            this.expectOnePlugin([
                                "decorators",
                                "decorators-legacy"
                            ]);
                            var node = this.startNode();
                            this.next();
                            if (this.hasPlugin("decorators")) {
                                var startLoc = this.state.startLoc;
                                var expr;
                                if (this.match(10)) {
                                    var startLoc2 = this.state.startLoc;
                                    this.next();
                                    expr = this.parseExpression();
                                    this.expect(11);
                                    expr = this.wrapParenthesis(startLoc2, expr);
                                    var paramsStartLoc = this.state.startLoc;
                                    node.expression = this.parseMaybeDecoratorArguments(expr);
                                    if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
                                        this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
                                    }
                                } else {
                                    expr = this.parseIdentifier(false);
                                    while(this.eat(16)){
                                        var node2 = this.startNodeAt(startLoc);
                                        node2.object = expr;
                                        if (this.match(138)) {
                                            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                                            node2.property = this.parsePrivateName();
                                        } else {
                                            node2.property = this.parseIdentifier(true);
                                        }
                                        node2.computed = false;
                                        expr = this.finishNode(node2, "MemberExpression");
                                    }
                                    node.expression = this.parseMaybeDecoratorArguments(expr);
                                }
                            } else {
                                node.expression = this.parseExprSubscripts();
                            }
                            return this.finishNode(node, "Decorator");
                        }
                    },
                    {
                        key: "parseMaybeDecoratorArguments",
                        value: function parseMaybeDecoratorArguments(expr) {
                            if (this.eat(10)) {
                                var node = this.startNodeAtNode(expr);
                                node.callee = expr;
                                node.arguments = this.parseCallExpressionArguments(11);
                                this.toReferencedList(node.arguments);
                                return this.finishNode(node, "CallExpression");
                            }
                            return expr;
                        }
                    },
                    {
                        key: "parseBreakContinueStatement",
                        value: function parseBreakContinueStatement(node, isBreak) {
                            this.next();
                            if (this.isLineTerminator()) {
                                node.label = null;
                            } else {
                                node.label = this.parseIdentifier();
                                this.semicolon();
                            }
                            this.verifyBreakContinue(node, isBreak);
                            return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
                        }
                    },
                    {
                        key: "verifyBreakContinue",
                        value: function verifyBreakContinue(node, isBreak) {
                            var i;
                            for(i = 0; i < this.state.labels.length; ++i){
                                var lab = this.state.labels[i];
                                if (node.label == null || lab.name === node.label.name) {
                                    if (lab.kind != null && (isBreak || lab.kind === 1)) {
                                        break;
                                    }
                                    if (node.label && isBreak) break;
                                }
                            }
                            if (i === this.state.labels.length) {
                                var type = isBreak ? "BreakStatement" : "ContinueStatement";
                                this.raise(Errors.IllegalBreakContinue, node, {
                                    type: type
                                });
                            }
                        }
                    },
                    {
                        key: "parseDebuggerStatement",
                        value: function parseDebuggerStatement(node) {
                            this.next();
                            this.semicolon();
                            return this.finishNode(node, "DebuggerStatement");
                        }
                    },
                    {
                        key: "parseHeaderExpression",
                        value: function parseHeaderExpression() {
                            this.expect(10);
                            var val = this.parseExpression();
                            this.expect(11);
                            return val;
                        }
                    },
                    {
                        key: "parseDoWhileStatement",
                        value: function parseDoWhileStatement(node) {
                            var _this = this;
                            this.next();
                            this.state.labels.push(loopLabel);
                            node.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseStatement();
                            });
                            this.state.labels.pop();
                            this.expect(92);
                            node.test = this.parseHeaderExpression();
                            this.eat(13);
                            return this.finishNode(node, "DoWhileStatement");
                        }
                    },
                    {
                        key: "parseForStatement",
                        value: function parseForStatement(node) {
                            this.next();
                            this.state.labels.push(loopLabel);
                            var awaitAt = null;
                            if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
                                awaitAt = this.state.startLoc;
                                this.next();
                            }
                            this.scope.enter(0);
                            this.expect(10);
                            if (this.match(13)) {
                                if (awaitAt !== null) {
                                    this.unexpected(awaitAt);
                                }
                                return this.parseFor(node, null);
                            }
                            var startsWithLet = this.isContextual(100);
                            {
                                var startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
                                var starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
                                var isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
                                if (this.match(74) || this.match(75) || isLetOrUsing) {
                                    var initNode = this.startNode();
                                    var kind;
                                    if (startsWithAwaitUsing) {
                                        kind = "await using";
                                        if (!this.recordAwaitIfAllowed()) {
                                            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
                                        }
                                        this.next();
                                    } else {
                                        kind = this.state.value;
                                    }
                                    this.next();
                                    this.parseVar(initNode, true, kind);
                                    var init2 = this.finishNode(initNode, "VariableDeclaration");
                                    var isForIn = this.match(58);
                                    if (isForIn && starsWithUsingDeclaration) {
                                        this.raise(Errors.ForInUsing, init2);
                                    }
                                    if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
                                        return this.parseForIn(node, init2, awaitAt);
                                    }
                                    if (awaitAt !== null) {
                                        this.unexpected(awaitAt);
                                    }
                                    return this.parseFor(node, init2);
                                }
                            }
                            var startsWithAsync = this.isContextual(95);
                            var refExpressionErrors = new ExpressionErrors();
                            var init = this.parseExpression(true, refExpressionErrors);
                            var isForOf = this.isContextual(102);
                            if (isForOf) {
                                if (startsWithLet) {
                                    this.raise(Errors.ForOfLet, init);
                                }
                                if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
                                    this.raise(Errors.ForOfAsync, init);
                                }
                            }
                            if (isForOf || this.match(58)) {
                                this.checkDestructuringPrivate(refExpressionErrors);
                                this.toAssignable(init, true);
                                var type = isForOf ? "ForOfStatement" : "ForInStatement";
                                this.checkLVal(init, {
                                    type: type
                                });
                                return this.parseForIn(node, init, awaitAt);
                            } else {
                                this.checkExpressionErrors(refExpressionErrors, true);
                            }
                            if (awaitAt !== null) {
                                this.unexpected(awaitAt);
                            }
                            return this.parseFor(node, init);
                        }
                    },
                    {
                        key: "parseFunctionStatement",
                        value: function parseFunctionStatement(node, isAsync, isHangingDeclaration) {
                            this.next();
                            return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
                        }
                    },
                    {
                        key: "parseIfStatement",
                        value: function parseIfStatement(node) {
                            this.next();
                            node.test = this.parseHeaderExpression();
                            node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
                            node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
                            return this.finishNode(node, "IfStatement");
                        }
                    },
                    {
                        key: "parseReturnStatement",
                        value: function parseReturnStatement(node) {
                            if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
                                this.raise(Errors.IllegalReturn, this.state.startLoc);
                            }
                            this.next();
                            if (this.isLineTerminator()) {
                                node.argument = null;
                            } else {
                                node.argument = this.parseExpression();
                                this.semicolon();
                            }
                            return this.finishNode(node, "ReturnStatement");
                        }
                    },
                    {
                        key: "parseSwitchStatement",
                        value: function parseSwitchStatement(node) {
                            this.next();
                            node.discriminant = this.parseHeaderExpression();
                            var cases = node.cases = [];
                            this.expect(5);
                            this.state.labels.push(switchLabel);
                            this.scope.enter(0);
                            var cur;
                            for(var sawDefault; !this.match(8);){
                                if (this.match(61) || this.match(65)) {
                                    var isCase = this.match(61);
                                    if (cur) this.finishNode(cur, "SwitchCase");
                                    cases.push(cur = this.startNode());
                                    cur.consequent = [];
                                    this.next();
                                    if (isCase) {
                                        cur.test = this.parseExpression();
                                    } else {
                                        if (sawDefault) {
                                            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
                                        }
                                        sawDefault = true;
                                        cur.test = null;
                                    }
                                    this.expect(14);
                                } else {
                                    if (cur) {
                                        cur.consequent.push(this.parseStatementListItem());
                                    } else {
                                        this.unexpected();
                                    }
                                }
                            }
                            this.scope.exit();
                            if (cur) this.finishNode(cur, "SwitchCase");
                            this.next();
                            this.state.labels.pop();
                            return this.finishNode(node, "SwitchStatement");
                        }
                    },
                    {
                        key: "parseThrowStatement",
                        value: function parseThrowStatement(node) {
                            this.next();
                            if (this.hasPrecedingLineBreak()) {
                                this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
                            }
                            node.argument = this.parseExpression();
                            this.semicolon();
                            return this.finishNode(node, "ThrowStatement");
                        }
                    },
                    {
                        key: "parseCatchClauseParam",
                        value: function parseCatchClauseParam() {
                            var param = this.parseBindingAtom();
                            this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
                            this.checkLVal(param, {
                                type: "CatchClause"
                            }, 9);
                            return param;
                        }
                    },
                    {
                        key: "parseTryStatement",
                        value: function parseTryStatement(node) {
                            var _this = this;
                            this.next();
                            node.block = this.parseBlock();
                            node.handler = null;
                            if (this.match(62)) {
                                var clause = this.startNode();
                                this.next();
                                if (this.match(10)) {
                                    this.expect(10);
                                    clause.param = this.parseCatchClauseParam();
                                    this.expect(11);
                                } else {
                                    clause.param = null;
                                    this.scope.enter(0);
                                }
                                clause.body = this.withSmartMixTopicForbiddingContext(function() {
                                    return _this.parseBlock(false, false);
                                });
                                this.scope.exit();
                                node.handler = this.finishNode(clause, "CatchClause");
                            }
                            node.finalizer = this.eat(67) ? this.parseBlock() : null;
                            if (!node.handler && !node.finalizer) {
                                this.raise(Errors.NoCatchOrFinally, node);
                            }
                            return this.finishNode(node, "TryStatement");
                        }
                    },
                    {
                        key: "parseVarStatement",
                        value: function parseVarStatement(node, kind) {
                            var allowMissingInitializer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                            this.next();
                            this.parseVar(node, false, kind, allowMissingInitializer);
                            this.semicolon();
                            return this.finishNode(node, "VariableDeclaration");
                        }
                    },
                    {
                        key: "parseWhileStatement",
                        value: function parseWhileStatement(node) {
                            var _this = this;
                            this.next();
                            node.test = this.parseHeaderExpression();
                            this.state.labels.push(loopLabel);
                            node.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseStatement();
                            });
                            this.state.labels.pop();
                            return this.finishNode(node, "WhileStatement");
                        }
                    },
                    {
                        key: "parseWithStatement",
                        value: function parseWithStatement(node) {
                            var _this = this;
                            if (this.state.strict) {
                                this.raise(Errors.StrictWith, this.state.startLoc);
                            }
                            this.next();
                            node.object = this.parseHeaderExpression();
                            node.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseStatement();
                            });
                            return this.finishNode(node, "WithStatement");
                        }
                    },
                    {
                        key: "parseEmptyStatement",
                        value: function parseEmptyStatement(node) {
                            this.next();
                            return this.finishNode(node, "EmptyStatement");
                        }
                    },
                    {
                        key: "parseLabeledStatement",
                        value: function parseLabeledStatement(node, maybeName, expr, flags) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = this.state.labels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var label = _step.value;
                                    if (label.name === maybeName) {
                                        this.raise(Errors.LabelRedeclaration, expr, {
                                            labelName: maybeName
                                        });
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            var kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
                            for(var i = this.state.labels.length - 1; i >= 0; i--){
                                var label1 = this.state.labels[i];
                                if (label1.statementStart === node.start) {
                                    label1.statementStart = this.sourceToOffsetPos(this.state.start);
                                    label1.kind = kind;
                                } else {
                                    break;
                                }
                            }
                            this.state.labels.push({
                                name: maybeName,
                                kind: kind,
                                statementStart: this.sourceToOffsetPos(this.state.start)
                            });
                            node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
                            this.state.labels.pop();
                            node.label = expr;
                            return this.finishNode(node, "LabeledStatement");
                        }
                    },
                    {
                        key: "parseExpressionStatement",
                        value: function parseExpressionStatement(node, expr, decorators) {
                            node.expression = expr;
                            this.semicolon();
                            return this.finishNode(node, "ExpressionStatement");
                        }
                    },
                    {
                        key: "parseBlock",
                        value: function parseBlock() {
                            var allowDirectives = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, createNewLexicalScope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, afterBlockParse = arguments.length > 2 ? arguments[2] : void 0;
                            var node = this.startNode();
                            if (allowDirectives) {
                                this.state.strictErrors.clear();
                            }
                            this.expect(5);
                            if (createNewLexicalScope) {
                                this.scope.enter(0);
                            }
                            this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
                            if (createNewLexicalScope) {
                                this.scope.exit();
                            }
                            return this.finishNode(node, "BlockStatement");
                        }
                    },
                    {
                        key: "isValidDirective",
                        value: function isValidDirective(stmt) {
                            return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
                        }
                    },
                    {
                        key: "parseBlockBody",
                        value: function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
                            var body = node.body = [];
                            var directives = node.directives = [];
                            this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
                        }
                    },
                    {
                        key: "parseBlockOrModuleBlockBody",
                        value: function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
                            var oldStrict = this.state.strict;
                            var hasStrictModeDirective = false;
                            var parsedNonDirective = false;
                            while(!this.match(end)){
                                var stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
                                if (directives && !parsedNonDirective) {
                                    if (this.isValidDirective(stmt)) {
                                        var directive = this.stmtToDirective(stmt);
                                        directives.push(directive);
                                        if (!hasStrictModeDirective && directive.value.value === "use strict") {
                                            hasStrictModeDirective = true;
                                            this.setStrict(true);
                                        }
                                        continue;
                                    }
                                    parsedNonDirective = true;
                                    this.state.strictErrors.clear();
                                }
                                body.push(stmt);
                            }
                            afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
                            if (!oldStrict) {
                                this.setStrict(false);
                            }
                            this.next();
                        }
                    },
                    {
                        key: "parseFor",
                        value: function parseFor(node, init) {
                            var _this = this;
                            node.init = init;
                            this.semicolon(false);
                            node.test = this.match(13) ? null : this.parseExpression();
                            this.semicolon(false);
                            node.update = this.match(11) ? null : this.parseExpression();
                            this.expect(11);
                            node.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseStatement();
                            });
                            this.scope.exit();
                            this.state.labels.pop();
                            return this.finishNode(node, "ForStatement");
                        }
                    },
                    {
                        key: "parseForIn",
                        value: function parseForIn(node, init, awaitAt) {
                            var _this = this;
                            var isForIn = this.match(58);
                            this.next();
                            if (isForIn) {
                                if (awaitAt !== null) this.unexpected(awaitAt);
                            } else {
                                node.await = awaitAt !== null;
                            }
                            if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
                                this.raise(Errors.ForInOfLoopInitializer, init, {
                                    type: isForIn ? "ForInStatement" : "ForOfStatement"
                                });
                            }
                            if (init.type === "AssignmentPattern") {
                                this.raise(Errors.InvalidLhs, init, {
                                    ancestor: {
                                        type: "ForStatement"
                                    }
                                });
                            }
                            node.left = init;
                            node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
                            this.expect(11);
                            node.body = this.withSmartMixTopicForbiddingContext(function() {
                                return _this.parseStatement();
                            });
                            this.scope.exit();
                            this.state.labels.pop();
                            return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
                        }
                    },
                    {
                        key: "parseVar",
                        value: function parseVar(node, isFor, kind) {
                            var allowMissingInitializer = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                            var declarations = node.declarations = [];
                            node.kind = kind;
                            for(;;){
                                var decl = this.startNode();
                                this.parseVarId(decl, kind);
                                decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
                                if (decl.init === null && !allowMissingInitializer) {
                                    if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
                                        this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                            kind: "destructuring"
                                        });
                                    } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
                                        this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                                            kind: kind
                                        });
                                    }
                                }
                                declarations.push(this.finishNode(decl, "VariableDeclarator"));
                                if (!this.eat(12)) break;
                            }
                            return node;
                        }
                    },
                    {
                        key: "parseVarId",
                        value: function parseVarId(decl, kind) {
                            var id = this.parseBindingAtom();
                            if (kind === "using" || kind === "await using") {
                                if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
                                    this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
                                }
                            }
                            this.checkLVal(id, {
                                type: "VariableDeclarator"
                            }, kind === "var" ? 5 : 8201);
                            decl.id = id;
                        }
                    },
                    {
                        key: "parseAsyncFunctionExpression",
                        value: function parseAsyncFunctionExpression(node) {
                            return this.parseFunction(node, 8);
                        }
                    },
                    {
                        key: "parseFunction",
                        value: function parseFunction(node) {
                            var _this = this;
                            var flags = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                            var hangingDeclaration = flags & 2;
                            var isDeclaration = !!(flags & 1);
                            var requireId = isDeclaration && !(flags & 4);
                            var isAsync = !!(flags & 8);
                            this.initFunction(node, isAsync);
                            if (this.match(55)) {
                                if (hangingDeclaration) {
                                    this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
                                }
                                this.next();
                                node.generator = true;
                            }
                            if (isDeclaration) {
                                node.id = this.parseFunctionId(requireId);
                            }
                            var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
                            this.state.maybeInArrowParameters = false;
                            this.scope.enter(2);
                            this.prodParam.enter(functionFlags(isAsync, node.generator));
                            if (!isDeclaration) {
                                node.id = this.parseFunctionId();
                            }
                            this.parseFunctionParams(node, false);
                            this.withSmartMixTopicForbiddingContext(function() {
                                _this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
                            });
                            this.prodParam.exit();
                            this.scope.exit();
                            if (isDeclaration && !hangingDeclaration) {
                                this.registerFunctionStatementId(node);
                            }
                            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
                            return node;
                        }
                    },
                    {
                        key: "parseFunctionId",
                        value: function parseFunctionId(requireId) {
                            return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
                        }
                    },
                    {
                        key: "parseFunctionParams",
                        value: function parseFunctionParams(node, isConstructor) {
                            this.expect(10);
                            this.expressionScope.enter(newParameterDeclarationScope());
                            node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
                            this.expressionScope.exit();
                        }
                    },
                    {
                        key: "registerFunctionStatementId",
                        value: function registerFunctionStatementId(node) {
                            if (!node.id) return;
                            this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
                        }
                    },
                    {
                        key: "parseClass",
                        value: function parseClass(node, isStatement, optionalId) {
                            this.next();
                            var oldStrict = this.state.strict;
                            this.state.strict = true;
                            this.parseClassId(node, isStatement, optionalId);
                            this.parseClassSuper(node);
                            node.body = this.parseClassBody(!!node.superClass, oldStrict);
                            return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
                        }
                    },
                    {
                        key: "isClassProperty",
                        value: function isClassProperty() {
                            return this.match(29) || this.match(13) || this.match(8);
                        }
                    },
                    {
                        key: "isClassMethod",
                        value: function isClassMethod() {
                            return this.match(10);
                        }
                    },
                    {
                        key: "nameIsConstructor",
                        value: function nameIsConstructor(key) {
                            return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
                        }
                    },
                    {
                        key: "isNonstaticConstructor",
                        value: function isNonstaticConstructor(method) {
                            return !method.computed && !method.static && this.nameIsConstructor(method.key);
                        }
                    },
                    {
                        key: "parseClassBody",
                        value: function parseClassBody(hadSuperClass, oldStrict) {
                            var _this = this;
                            this.classScope.enter();
                            var state = {
                                hadConstructor: false,
                                hadSuperClass: hadSuperClass
                            };
                            var decorators = [];
                            var classBody = this.startNode();
                            classBody.body = [];
                            this.expect(5);
                            this.withSmartMixTopicForbiddingContext(function() {
                                while(!_this.match(8)){
                                    if (_this.eat(13)) {
                                        if (decorators.length > 0) {
                                            throw _this.raise(Errors.DecoratorSemicolon, _this.state.lastTokEndLoc);
                                        }
                                        continue;
                                    }
                                    if (_this.match(26)) {
                                        decorators.push(_this.parseDecorator());
                                        continue;
                                    }
                                    var member = _this.startNode();
                                    if (decorators.length) {
                                        member.decorators = decorators;
                                        _this.resetStartLocationFromNode(member, decorators[0]);
                                        decorators = [];
                                    }
                                    _this.parseClassMember(classBody, member, state);
                                    if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                                        _this.raise(Errors.DecoratorConstructor, member);
                                    }
                                }
                            });
                            this.state.strict = oldStrict;
                            this.next();
                            if (decorators.length) {
                                throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
                            }
                            this.classScope.exit();
                            return this.finishNode(classBody, "ClassBody");
                        }
                    },
                    {
                        key: "parseClassMemberFromModifier",
                        value: function parseClassMemberFromModifier(classBody, member) {
                            var key = this.parseIdentifier(true);
                            if (this.isClassMethod()) {
                                var method = member;
                                method.kind = "method";
                                method.computed = false;
                                method.key = key;
                                method.static = false;
                                this.pushClassMethod(classBody, method, false, false, false, false);
                                return true;
                            } else if (this.isClassProperty()) {
                                var prop = member;
                                prop.computed = false;
                                prop.key = key;
                                prop.static = false;
                                classBody.body.push(this.parseClassProperty(prop));
                                return true;
                            }
                            this.resetPreviousNodeTrailingComments(key);
                            return false;
                        }
                    },
                    {
                        key: "parseClassMember",
                        value: function parseClassMember(classBody, member, state) {
                            var isStatic = this.isContextual(106);
                            if (isStatic) {
                                if (this.parseClassMemberFromModifier(classBody, member)) {
                                    return;
                                }
                                if (this.eat(5)) {
                                    this.parseClassStaticBlock(classBody, member);
                                    return;
                                }
                            }
                            this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
                        }
                    },
                    {
                        key: "parseClassMemberWithIsStatic",
                        value: function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
                            var publicMethod = member;
                            var privateMethod = member;
                            var publicProp = member;
                            var privateProp = member;
                            var accessorProp = member;
                            var method = publicMethod;
                            var publicMember = publicMethod;
                            member.static = isStatic;
                            this.parsePropertyNamePrefixOperator(member);
                            if (this.eat(55)) {
                                method.kind = "method";
                                var isPrivateName = this.match(138);
                                this.parseClassElementName(method);
                                if (isPrivateName) {
                                    this.pushClassPrivateMethod(classBody, privateMethod, true, false);
                                    return;
                                }
                                if (this.isNonstaticConstructor(publicMethod)) {
                                    this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
                                }
                                this.pushClassMethod(classBody, publicMethod, true, false, false, false);
                                return;
                            }
                            var isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
                            var key = this.parseClassElementName(member);
                            var maybeContextualKw = isContextual ? key.name : null;
                            var isPrivate = this.isPrivateName(key);
                            var maybeQuestionTokenStartLoc = this.state.startLoc;
                            this.parsePostMemberNameModifiers(publicMember);
                            if (this.isClassMethod()) {
                                method.kind = "method";
                                if (isPrivate) {
                                    this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                                    return;
                                }
                                var isConstructor = this.isNonstaticConstructor(publicMethod);
                                var allowsDirectSuper = false;
                                if (isConstructor) {
                                    publicMethod.kind = "constructor";
                                    if (state.hadConstructor && !this.hasPlugin("typescript")) {
                                        this.raise(Errors.DuplicateConstructor, key);
                                    }
                                    if (isConstructor && this.hasPlugin("typescript") && member.override) {
                                        this.raise(Errors.OverrideOnConstructor, key);
                                    }
                                    state.hadConstructor = true;
                                    allowsDirectSuper = state.hadSuperClass;
                                }
                                this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
                            } else if (this.isClassProperty()) {
                                if (isPrivate) {
                                    this.pushClassPrivateProperty(classBody, privateProp);
                                } else {
                                    this.pushClassProperty(classBody, publicProp);
                                }
                            } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
                                this.resetPreviousNodeTrailingComments(key);
                                var isGenerator = this.eat(55);
                                if (publicMember.optional) {
                                    this.unexpected(maybeQuestionTokenStartLoc);
                                }
                                method.kind = "method";
                                var isPrivate2 = this.match(138);
                                this.parseClassElementName(method);
                                this.parsePostMemberNameModifiers(publicMember);
                                if (isPrivate2) {
                                    this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
                                } else {
                                    if (this.isNonstaticConstructor(publicMethod)) {
                                        this.raise(Errors.ConstructorIsAsync, publicMethod.key);
                                    }
                                    this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
                                }
                            } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
                                this.resetPreviousNodeTrailingComments(key);
                                method.kind = maybeContextualKw;
                                var isPrivate21 = this.match(138);
                                this.parseClassElementName(publicMethod);
                                if (isPrivate21) {
                                    this.pushClassPrivateMethod(classBody, privateMethod, false, false);
                                } else {
                                    if (this.isNonstaticConstructor(publicMethod)) {
                                        this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
                                    }
                                    this.pushClassMethod(classBody, publicMethod, false, false, false, false);
                                }
                                this.checkGetterSetterParams(publicMethod);
                            } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
                                this.expectPlugin("decoratorAutoAccessors");
                                this.resetPreviousNodeTrailingComments(key);
                                var isPrivate22 = this.match(138);
                                this.parseClassElementName(publicProp);
                                this.pushClassAccessorProperty(classBody, accessorProp, isPrivate22);
                            } else if (this.isLineTerminator()) {
                                if (isPrivate) {
                                    this.pushClassPrivateProperty(classBody, privateProp);
                                } else {
                                    this.pushClassProperty(classBody, publicProp);
                                }
                            } else {
                                this.unexpected();
                            }
                        }
                    },
                    {
                        key: "parseClassElementName",
                        value: function parseClassElementName(member) {
                            var _this_state = this.state, type = _this_state.type, value = _this_state.value;
                            if ((type === 132 || type === 133) && member.static && value === "prototype") {
                                this.raise(Errors.StaticPrototype, this.state.startLoc);
                            }
                            if (type === 138) {
                                if (value === "constructor") {
                                    this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
                                }
                                var key = this.parsePrivateName();
                                member.key = key;
                                return key;
                            }
                            this.parsePropertyName(member);
                            return member.key;
                        }
                    },
                    {
                        key: "parseClassStaticBlock",
                        value: function parseClassStaticBlock(classBody, member) {
                            var _member$decorators;
                            this.scope.enter(64 | 128 | 16);
                            var oldLabels = this.state.labels;
                            this.state.labels = [];
                            this.prodParam.enter(0);
                            var body = member.body = [];
                            this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
                            this.prodParam.exit();
                            this.scope.exit();
                            this.state.labels = oldLabels;
                            classBody.body.push(this.finishNode(member, "StaticBlock"));
                            if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
                                this.raise(Errors.DecoratorStaticBlock, member);
                            }
                        }
                    },
                    {
                        key: "pushClassProperty",
                        value: function pushClassProperty(classBody, prop) {
                            if (!prop.computed && this.nameIsConstructor(prop.key)) {
                                this.raise(Errors.ConstructorClassField, prop.key);
                            }
                            classBody.body.push(this.parseClassProperty(prop));
                        }
                    },
                    {
                        key: "pushClassPrivateProperty",
                        value: function pushClassPrivateProperty(classBody, prop) {
                            var node = this.parseClassPrivateProperty(prop);
                            classBody.body.push(node);
                            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
                        }
                    },
                    {
                        key: "pushClassAccessorProperty",
                        value: function pushClassAccessorProperty(classBody, prop, isPrivate) {
                            if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
                                this.raise(Errors.ConstructorClassField, prop.key);
                            }
                            var node = this.parseClassAccessorProperty(prop);
                            classBody.body.push(node);
                            if (isPrivate) {
                                this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
                            }
                        }
                    },
                    {
                        key: "pushClassMethod",
                        value: function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
                            classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
                        }
                    },
                    {
                        key: "pushClassPrivateMethod",
                        value: function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
                            var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
                            classBody.body.push(node);
                            var kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
                            this.declareClassPrivateMethodInScope(node, kind);
                        }
                    },
                    {
                        key: "declareClassPrivateMethodInScope",
                        value: function declareClassPrivateMethodInScope(node, kind) {
                            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
                        }
                    },
                    {
                        key: "parsePostMemberNameModifiers",
                        value: function parsePostMemberNameModifiers(methodOrProp) {}
                    },
                    {
                        key: "parseClassPrivateProperty",
                        value: function parseClassPrivateProperty(node) {
                            this.parseInitializer(node);
                            this.semicolon();
                            return this.finishNode(node, "ClassPrivateProperty");
                        }
                    },
                    {
                        key: "parseClassProperty",
                        value: function parseClassProperty(node) {
                            this.parseInitializer(node);
                            this.semicolon();
                            return this.finishNode(node, "ClassProperty");
                        }
                    },
                    {
                        key: "parseClassAccessorProperty",
                        value: function parseClassAccessorProperty(node) {
                            this.parseInitializer(node);
                            this.semicolon();
                            return this.finishNode(node, "ClassAccessorProperty");
                        }
                    },
                    {
                        key: "parseInitializer",
                        value: function parseInitializer(node) {
                            this.scope.enter(64 | 16);
                            this.expressionScope.enter(newExpressionScope());
                            this.prodParam.enter(0);
                            node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
                            this.expressionScope.exit();
                            this.prodParam.exit();
                            this.scope.exit();
                        }
                    },
                    {
                        key: "parseClassId",
                        value: function parseClassId(node, isStatement, optionalId) {
                            var bindingType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 8331;
                            if (tokenIsIdentifier(this.state.type)) {
                                node.id = this.parseIdentifier();
                                if (isStatement) {
                                    this.declareNameFromIdentifier(node.id, bindingType);
                                }
                            } else {
                                if (optionalId || !isStatement) {
                                    node.id = null;
                                } else {
                                    throw this.raise(Errors.MissingClassName, this.state.startLoc);
                                }
                            }
                        }
                    },
                    {
                        key: "parseClassSuper",
                        value: function parseClassSuper(node) {
                            node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
                        }
                    },
                    {
                        key: "parseExport",
                        value: function parseExport(node, decorators) {
                            var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
                            var hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
                            var parseAfterDefault = !hasDefault || this.eat(12);
                            var hasStar = parseAfterDefault && this.eatExportStar(node);
                            var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
                            var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
                            var isFromRequired = hasDefault || hasStar;
                            if (hasStar && !hasNamespace) {
                                if (hasDefault) this.unexpected();
                                if (decorators) {
                                    throw this.raise(Errors.UnsupportedDecoratorExport, node);
                                }
                                this.parseExportFrom(node, true);
                                return this.finishNode(node, "ExportAllDeclaration");
                            }
                            var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
                            if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
                                this.unexpected(null, 5);
                            }
                            if (hasNamespace && parseAfterNamespace) {
                                this.unexpected(null, 98);
                            }
                            var hasDeclaration;
                            if (isFromRequired || hasSpecifiers) {
                                hasDeclaration = false;
                                if (decorators) {
                                    throw this.raise(Errors.UnsupportedDecoratorExport, node);
                                }
                                this.parseExportFrom(node, isFromRequired);
                            } else {
                                hasDeclaration = this.maybeParseExportDeclaration(node);
                            }
                            if (isFromRequired || hasSpecifiers || hasDeclaration) {
                                var _node2$declaration;
                                var node2 = node;
                                this.checkExport(node2, true, false, !!node2.source);
                                if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
                                    this.maybeTakeDecorators(decorators, node2.declaration, node2);
                                } else if (decorators) {
                                    throw this.raise(Errors.UnsupportedDecoratorExport, node);
                                }
                                return this.finishNode(node2, "ExportNamedDeclaration");
                            }
                            if (this.eat(65)) {
                                var node21 = node;
                                var decl = this.parseExportDefaultExpression();
                                node21.declaration = decl;
                                if (decl.type === "ClassDeclaration") {
                                    this.maybeTakeDecorators(decorators, decl, node21);
                                } else if (decorators) {
                                    throw this.raise(Errors.UnsupportedDecoratorExport, node);
                                }
                                this.checkExport(node21, true, true);
                                return this.finishNode(node21, "ExportDefaultDeclaration");
                            }
                            this.unexpected(null, 5);
                        }
                    },
                    {
                        key: "eatExportStar",
                        value: function eatExportStar(node) {
                            return this.eat(55);
                        }
                    },
                    {
                        key: "maybeParseExportDefaultSpecifier",
                        value: function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
                            if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
                                this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
                                var id = maybeDefaultIdentifier || this.parseIdentifier(true);
                                var specifier = this.startNodeAtNode(id);
                                specifier.exported = id;
                                node.specifiers = [
                                    this.finishNode(specifier, "ExportDefaultSpecifier")
                                ];
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeParseExportNamespaceSpecifier",
                        value: function maybeParseExportNamespaceSpecifier(node) {
                            if (this.isContextual(93)) {
                                var _ref, _ref$specifiers;
                                (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
                                var specifier = this.startNodeAt(this.state.lastTokStartLoc);
                                this.next();
                                specifier.exported = this.parseModuleExportName();
                                node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeParseExportNamedSpecifiers",
                        value: function maybeParseExportNamedSpecifiers(node) {
                            if (this.match(5)) {
                                var _node2_specifiers;
                                var node2 = node;
                                if (!node2.specifiers) node2.specifiers = [];
                                var isTypeExport = node2.exportKind === "type";
                                (_node2_specifiers = node2.specifiers).push.apply(_node2_specifiers, _to_consumable_array(this.parseExportSpecifiers(isTypeExport)));
                                node2.source = null;
                                node2.declaration = null;
                                if (this.hasPlugin("importAssertions")) {
                                    node2.assertions = [];
                                }
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeParseExportDeclaration",
                        value: function maybeParseExportDeclaration(node) {
                            if (this.shouldParseExportDeclaration()) {
                                node.specifiers = [];
                                node.source = null;
                                if (this.hasPlugin("importAssertions")) {
                                    node.assertions = [];
                                }
                                node.declaration = this.parseExportDeclaration(node);
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "isAsyncFunction",
                        value: function isAsyncFunction() {
                            if (!this.isContextual(95)) return false;
                            var next = this.nextTokenInLineStart();
                            return this.isUnparsedContextual(next, "function");
                        }
                    },
                    {
                        key: "parseExportDefaultExpression",
                        value: function parseExportDefaultExpression() {
                            var expr = this.startNode();
                            if (this.match(68)) {
                                this.next();
                                return this.parseFunction(expr, 1 | 4);
                            } else if (this.isAsyncFunction()) {
                                this.next();
                                this.next();
                                return this.parseFunction(expr, 1 | 4 | 8);
                            }
                            if (this.match(80)) {
                                return this.parseClass(expr, true, true);
                            }
                            if (this.match(26)) {
                                if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                    this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
                                }
                                return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
                            }
                            if (this.match(75) || this.match(74) || this.isLet()) {
                                throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
                            }
                            var res = this.parseMaybeAssignAllowIn();
                            this.semicolon();
                            return res;
                        }
                    },
                    {
                        key: "parseExportDeclaration",
                        value: function parseExportDeclaration(node) {
                            if (this.match(80)) {
                                var node2 = this.parseClass(this.startNode(), true, false);
                                return node2;
                            }
                            return this.parseStatementListItem();
                        }
                    },
                    {
                        key: "isExportDefaultSpecifier",
                        value: function isExportDefaultSpecifier() {
                            var type = this.state.type;
                            if (tokenIsIdentifier(type)) {
                                if (type === 95 && !this.state.containsEsc || type === 100) {
                                    return false;
                                }
                                if ((type === 130 || type === 129) && !this.state.containsEsc) {
                                    var _this_lookahead = this.lookahead(), nextType = _this_lookahead.type;
                                    if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
                                        this.expectOnePlugin([
                                            "flow",
                                            "typescript"
                                        ]);
                                        return false;
                                    }
                                }
                            } else if (!this.match(65)) {
                                return false;
                            }
                            var next = this.nextTokenStart();
                            var hasFrom = this.isUnparsedContextual(next, "from");
                            if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
                                return true;
                            }
                            if (this.match(65) && hasFrom) {
                                var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
                                return nextAfterFrom === 34 || nextAfterFrom === 39;
                            }
                            return false;
                        }
                    },
                    {
                        key: "parseExportFrom",
                        value: function parseExportFrom(node, expect) {
                            if (this.eatContextual(98)) {
                                node.source = this.parseImportSource();
                                this.checkExport(node);
                                this.maybeParseImportAttributes(node);
                                this.checkJSONModuleImport(node);
                            } else if (expect) {
                                this.unexpected();
                            }
                            this.semicolon();
                        }
                    },
                    {
                        key: "shouldParseExportDeclaration",
                        value: function shouldParseExportDeclaration() {
                            var type = this.state.type;
                            if (type === 26) {
                                this.expectOnePlugin([
                                    "decorators",
                                    "decorators-legacy"
                                ]);
                                if (this.hasPlugin("decorators")) {
                                    if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
                                    }
                                    return true;
                                }
                            }
                            if (this.isContextual(107)) {
                                this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
                                return true;
                            }
                            if (this.isContextual(96) && this.startsAwaitUsing()) {
                                this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
                                return true;
                            }
                            return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
                        }
                    },
                    {
                        key: "checkExport",
                        value: function checkExport(node, checkNames, isDefault, isFrom) {
                            if (checkNames) {
                                var _node$specifiers;
                                if (isDefault) {
                                    this.checkDuplicateExports(node, "default");
                                    if (this.hasPlugin("exportDefaultFrom")) {
                                        var _declaration$extra;
                                        var declaration = node.declaration;
                                        if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                                            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
                                        }
                                    }
                                } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var specifier = _step.value;
                                            var exported = specifier.exported;
                                            var exportName = exported.type === "Identifier" ? exported.name : exported.value;
                                            this.checkDuplicateExports(specifier, exportName);
                                            if (!isFrom && specifier.local) {
                                                var local = specifier.local;
                                                if (local.type !== "Identifier") {
                                                    this.raise(Errors.ExportBindingIsString, specifier, {
                                                        localName: local.value,
                                                        exportName: exportName
                                                    });
                                                } else {
                                                    this.checkReservedWord(local.name, local.loc.start, true, false);
                                                    this.scope.checkLocalExport(local);
                                                }
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                } else if (node.declaration) {
                                    var decl = node.declaration;
                                    if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
                                        var id = decl.id;
                                        if (!id) throw new Error("Assertion failure");
                                        this.checkDuplicateExports(node, id.name);
                                    } else if (decl.type === "VariableDeclaration") {
                                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                        try {
                                            for(var _iterator1 = decl.declarations[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                                var declaration1 = _step1.value;
                                                this.checkDeclaration(declaration1.id);
                                            }
                                        } catch (err) {
                                            _didIteratorError1 = true;
                                            _iteratorError1 = err;
                                        } finally{
                                            try {
                                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                                    _iterator1.return();
                                                }
                                            } finally{
                                                if (_didIteratorError1) {
                                                    throw _iteratorError1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "checkDeclaration",
                        value: function checkDeclaration(node) {
                            if (node.type === "Identifier") {
                                this.checkDuplicateExports(node, node.name);
                            } else if (node.type === "ObjectPattern") {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var prop = _step.value;
                                        this.checkDeclaration(prop);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            } else if (node.type === "ArrayPattern") {
                                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                                try {
                                    for(var _iterator1 = node.elements[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                        var elem = _step1.value;
                                        if (elem) {
                                            this.checkDeclaration(elem);
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError1 = true;
                                    _iteratorError1 = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                            _iterator1.return();
                                        }
                                    } finally{
                                        if (_didIteratorError1) {
                                            throw _iteratorError1;
                                        }
                                    }
                                }
                            } else if (node.type === "ObjectProperty") {
                                this.checkDeclaration(node.value);
                            } else if (node.type === "RestElement") {
                                this.checkDeclaration(node.argument);
                            } else if (node.type === "AssignmentPattern") {
                                this.checkDeclaration(node.left);
                            }
                        }
                    },
                    {
                        key: "checkDuplicateExports",
                        value: function checkDuplicateExports(node, exportName) {
                            if (this.exportedIdentifiers.has(exportName)) {
                                if (exportName === "default") {
                                    this.raise(Errors.DuplicateDefaultExport, node);
                                } else {
                                    this.raise(Errors.DuplicateExport, node, {
                                        exportName: exportName
                                    });
                                }
                            }
                            this.exportedIdentifiers.add(exportName);
                        }
                    },
                    {
                        key: "parseExportSpecifiers",
                        value: function parseExportSpecifiers(isInTypeExport) {
                            var nodes = [];
                            var first = true;
                            this.expect(5);
                            while(!this.eat(8)){
                                if (first) {
                                    first = false;
                                } else {
                                    this.expect(12);
                                    if (this.eat(8)) break;
                                }
                                var isMaybeTypeOnly = this.isContextual(130);
                                var isString = this.match(133);
                                var node = this.startNode();
                                node.local = this.parseModuleExportName();
                                nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
                            }
                            return nodes;
                        }
                    },
                    {
                        key: "parseExportSpecifier",
                        value: function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
                            if (this.eatContextual(93)) {
                                node.exported = this.parseModuleExportName();
                            } else if (isString) {
                                node.exported = cloneStringLiteral(node.local);
                            } else if (!node.exported) {
                                node.exported = cloneIdentifier(node.local);
                            }
                            return this.finishNode(node, "ExportSpecifier");
                        }
                    },
                    {
                        key: "parseModuleExportName",
                        value: function parseModuleExportName() {
                            if (this.match(133)) {
                                var result = this.parseStringLiteral(this.state.value);
                                var surrogate = loneSurrogate.exec(result.value);
                                if (surrogate) {
                                    this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
                                        surrogateCharCode: surrogate[0].charCodeAt(0)
                                    });
                                }
                                return result;
                            }
                            return this.parseIdentifier(true);
                        }
                    },
                    {
                        key: "isJSONModuleImport",
                        value: function isJSONModuleImport(node) {
                            if (node.assertions != null) {
                                return node.assertions.some(function(param) {
                                    var key = param.key, value = param.value;
                                    return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
                                });
                            }
                            return false;
                        }
                    },
                    {
                        key: "checkImportReflection",
                        value: function checkImportReflection(node) {
                            var specifiers = node.specifiers;
                            var singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
                            if (node.phase === "source") {
                                if (singleBindingType !== "ImportDefaultSpecifier") {
                                    this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
                                }
                            } else if (node.phase === "defer") {
                                if (singleBindingType !== "ImportNamespaceSpecifier") {
                                    this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
                                }
                            } else if (node.module) {
                                var _node$assertions;
                                if (singleBindingType !== "ImportDefaultSpecifier") {
                                    this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
                                }
                                if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
                                    this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
                                }
                            }
                        }
                    },
                    {
                        key: "checkJSONModuleImport",
                        value: function checkJSONModuleImport(node) {
                            if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
                                var specifiers = node.specifiers;
                                if (specifiers != null) {
                                    var nonDefaultNamedSpecifier = specifiers.find(function(specifier) {
                                        var imported;
                                        if (specifier.type === "ExportSpecifier") {
                                            imported = specifier.local;
                                        } else if (specifier.type === "ImportSpecifier") {
                                            imported = specifier.imported;
                                        }
                                        if (imported !== void 0) {
                                            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                                        }
                                    });
                                    if (nonDefaultNamedSpecifier !== void 0) {
                                        this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "isPotentialImportPhase",
                        value: function isPotentialImportPhase(isExport) {
                            if (isExport) return false;
                            return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
                        }
                    },
                    {
                        key: "applyImportPhase",
                        value: function applyImportPhase(node, isExport, phase, loc) {
                            if (isExport) {
                                return;
                            }
                            if (phase === "module") {
                                this.expectPlugin("importReflection", loc);
                                node.module = true;
                            } else if (this.hasPlugin("importReflection")) {
                                node.module = false;
                            }
                            if (phase === "source") {
                                this.expectPlugin("sourcePhaseImports", loc);
                                node.phase = "source";
                            } else if (phase === "defer") {
                                this.expectPlugin("deferredImportEvaluation", loc);
                                node.phase = "defer";
                            } else if (this.hasPlugin("sourcePhaseImports")) {
                                node.phase = null;
                            }
                        }
                    },
                    {
                        key: "parseMaybeImportPhase",
                        value: function parseMaybeImportPhase(node, isExport) {
                            if (!this.isPotentialImportPhase(isExport)) {
                                this.applyImportPhase(node, isExport, null);
                                return null;
                            }
                            var phaseIdentifier = this.parseIdentifier(true);
                            var type = this.state.type;
                            var isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
                            if (isImportPhase) {
                                this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
                                this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
                                return null;
                            } else {
                                this.applyImportPhase(node, isExport, null);
                                return phaseIdentifier;
                            }
                        }
                    },
                    {
                        key: "isPrecedingIdImportPhase",
                        value: function isPrecedingIdImportPhase(phase) {
                            var type = this.state.type;
                            return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
                        }
                    },
                    {
                        key: "parseImport",
                        value: function parseImport(node) {
                            if (this.match(133)) {
                                return this.parseImportSourceAndAttributes(node);
                            }
                            return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
                        }
                    },
                    {
                        key: "parseImportSpecifiersAndAfter",
                        value: function parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
                            node.specifiers = [];
                            var hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
                            var parseNext = !hasDefault || this.eat(12);
                            var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
                            if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
                            this.expectContextual(98);
                            return this.parseImportSourceAndAttributes(node);
                        }
                    },
                    {
                        key: "parseImportSourceAndAttributes",
                        value: function parseImportSourceAndAttributes(node) {
                            var _node$specifiers2;
                            (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
                            node.source = this.parseImportSource();
                            this.maybeParseImportAttributes(node);
                            this.checkImportReflection(node);
                            this.checkJSONModuleImport(node);
                            this.semicolon();
                            return this.finishNode(node, "ImportDeclaration");
                        }
                    },
                    {
                        key: "parseImportSource",
                        value: function parseImportSource() {
                            if (!this.match(133)) this.unexpected();
                            return this.parseExprAtom();
                        }
                    },
                    {
                        key: "parseImportSpecifierLocal",
                        value: function parseImportSpecifierLocal(node, specifier, type) {
                            specifier.local = this.parseIdentifier();
                            node.specifiers.push(this.finishImportSpecifier(specifier, type));
                        }
                    },
                    {
                        key: "finishImportSpecifier",
                        value: function finishImportSpecifier(specifier, type) {
                            var bindingType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 8201;
                            this.checkLVal(specifier.local, {
                                type: type
                            }, bindingType);
                            return this.finishNode(specifier, type);
                        }
                    },
                    {
                        key: "parseImportAttributes",
                        value: function parseImportAttributes() {
                            this.expect(5);
                            var attrs = [];
                            var attrNames = /* @__PURE__ */ new Set();
                            do {
                                if (this.match(8)) {
                                    break;
                                }
                                var node = this.startNode();
                                var keyName = this.state.value;
                                if (attrNames.has(keyName)) {
                                    this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
                                        key: keyName
                                    });
                                }
                                attrNames.add(keyName);
                                if (this.match(133)) {
                                    node.key = this.parseStringLiteral(keyName);
                                } else {
                                    node.key = this.parseIdentifier(true);
                                }
                                this.expect(14);
                                if (!this.match(133)) {
                                    throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
                                }
                                node.value = this.parseStringLiteral(this.state.value);
                                attrs.push(this.finishNode(node, "ImportAttribute"));
                            }while (this.eat(12));
                            this.expect(8);
                            return attrs;
                        }
                    },
                    {
                        key: "parseModuleAttributes",
                        value: function parseModuleAttributes() {
                            var attrs = [];
                            var attributes = /* @__PURE__ */ new Set();
                            do {
                                var node = this.startNode();
                                node.key = this.parseIdentifier(true);
                                if (node.key.name !== "type") {
                                    this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
                                }
                                if (attributes.has(node.key.name)) {
                                    this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
                                        key: node.key.name
                                    });
                                }
                                attributes.add(node.key.name);
                                this.expect(14);
                                if (!this.match(133)) {
                                    throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
                                }
                                node.value = this.parseStringLiteral(this.state.value);
                                attrs.push(this.finishNode(node, "ImportAttribute"));
                            }while (this.eat(12));
                            return attrs;
                        }
                    },
                    {
                        key: "maybeParseImportAttributes",
                        value: function maybeParseImportAttributes(node) {
                            var attributes;
                            {
                                var useWith = false;
                            }
                            if (this.match(76)) {
                                if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                                    return;
                                }
                                this.next();
                                if (this.hasPlugin("moduleAttributes")) {
                                    attributes = this.parseModuleAttributes();
                                } else {
                                    attributes = this.parseImportAttributes();
                                }
                                {
                                    useWith = true;
                                }
                            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
                                if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
                                    this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
                                }
                                if (!this.hasPlugin("importAssertions")) {
                                    this.addExtra(node, "deprecatedAssertSyntax", true);
                                }
                                this.next();
                                attributes = this.parseImportAttributes();
                            } else {
                                attributes = [];
                            }
                            if (!useWith && this.hasPlugin("importAssertions")) {
                                node.assertions = attributes;
                            } else {
                                node.attributes = attributes;
                            }
                        }
                    },
                    {
                        key: "maybeParseDefaultImportSpecifier",
                        value: function maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
                            if (maybeDefaultIdentifier) {
                                var specifier = this.startNodeAtNode(maybeDefaultIdentifier);
                                specifier.local = maybeDefaultIdentifier;
                                node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
                                return true;
                            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "maybeParseStarImportSpecifier",
                        value: function maybeParseStarImportSpecifier(node) {
                            if (this.match(55)) {
                                var specifier = this.startNode();
                                this.next();
                                this.expectContextual(93);
                                this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
                                return true;
                            }
                            return false;
                        }
                    },
                    {
                        key: "parseNamedImportSpecifiers",
                        value: function parseNamedImportSpecifiers(node) {
                            var first = true;
                            this.expect(5);
                            while(!this.eat(8)){
                                if (first) {
                                    first = false;
                                } else {
                                    if (this.eat(14)) {
                                        throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
                                    }
                                    this.expect(12);
                                    if (this.eat(8)) break;
                                }
                                var specifier = this.startNode();
                                var importedIsString = this.match(133);
                                var isMaybeTypeOnly = this.isContextual(130);
                                specifier.imported = this.parseModuleExportName();
                                var importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
                                node.specifiers.push(importSpecifier);
                            }
                        }
                    },
                    {
                        key: "parseImportSpecifier",
                        value: function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
                            if (this.eatContextual(93)) {
                                specifier.local = this.parseIdentifier();
                            } else {
                                var imported = specifier.imported;
                                if (importedIsString) {
                                    throw this.raise(Errors.ImportBindingIsString, specifier, {
                                        importName: imported.value
                                    });
                                }
                                this.checkReservedWord(imported.name, specifier.loc.start, true, true);
                                if (!specifier.local) {
                                    specifier.local = cloneIdentifier(imported);
                                }
                            }
                            return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
                        }
                    },
                    {
                        key: "isThisParam",
                        value: function isThisParam(param) {
                            return param.type === "Identifier" && param.name === "this";
                        }
                    }
                ]);
                return StatementParser;
            }(ExpressionParser);
            var Parser = /*#__PURE__*/ function(StatementParser) {
                _inherits(Parser, StatementParser);
                function Parser(options, input, pluginsMap) {
                    _class_call_check(this, Parser);
                    var _this;
                    options = getOptions(options);
                    _this = _call_super(this, Parser, [
                        options,
                        input
                    ]);
                    _this.options = options;
                    _this.initializeScopes();
                    _this.plugins = pluginsMap;
                    _this.filename = options.sourceFilename;
                    _this.startIndex = options.startIndex;
                    return _this;
                }
                _create_class(Parser, [
                    {
                        key: "getScopeHandler",
                        value: function getScopeHandler() {
                            return ScopeHandler;
                        }
                    },
                    {
                        key: "parse",
                        value: function parse() {
                            this.enterInitialScopes();
                            var file = this.startNode();
                            var program = this.startNode();
                            this.nextToken();
                            file.errors = null;
                            this.parseTopLevel(file, program);
                            file.errors = this.state.errors;
                            file.comments.length = this.state.commentsLen;
                            return file;
                        }
                    }
                ]);
                return Parser;
            }(StatementParser);
            function parse(input, options) {
                var _options;
                if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
                    options = Object.assign({}, options);
                    try {
                        options.sourceType = "module";
                        var parser = getParser(options, input);
                        var ast = parser.parse();
                        if (parser.sawUnambiguousESM) {
                            return ast;
                        }
                        if (parser.ambiguousScriptDifferentAst) {
                            try {
                                options.sourceType = "script";
                                return getParser(options, input).parse();
                            } catch (_unused) {}
                        } else {
                            ast.program.sourceType = "script";
                        }
                        return ast;
                    } catch (moduleError) {
                        try {
                            options.sourceType = "script";
                            return getParser(options, input).parse();
                        } catch (_unused2) {}
                        throw moduleError;
                    }
                } else {
                    return getParser(options, input).parse();
                }
            }
            function parseExpression(input, options) {
                var parser = getParser(options, input);
                if (parser.options.strictMode) {
                    parser.state.strict = true;
                }
                return parser.getExpression();
            }
            function generateExportedTokenTypes(internalTokenTypes) {
                var tokenTypes2 = {};
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = Object.keys(internalTokenTypes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var typeName = _step.value;
                        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return tokenTypes2;
            }
            var tokTypes = generateExportedTokenTypes(tt);
            function getParser(options, input) {
                var cls = Parser;
                var pluginsMap = /* @__PURE__ */ new Map();
                if (options != null && options.plugins) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var plugin = _step.value;
                            var name = void 0, opts = void 0;
                            if (typeof plugin === "string") {
                                name = plugin;
                            } else {
                                var ref;
                                ref = _sliced_to_array(plugin, 2), name = ref[0], opts = ref[1], ref;
                            }
                            if (!pluginsMap.has(name)) {
                                pluginsMap.set(name, opts || {});
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    validatePlugins(pluginsMap);
                    cls = getParserClass(pluginsMap);
                }
                return new cls(options, input, pluginsMap);
            }
            var parserClassCache = /* @__PURE__ */ new Map();
            function getParserClass(pluginsMap) {
                var pluginList = [];
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = mixinPluginNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var name = _step.value;
                        if (pluginsMap.has(name)) {
                            pluginList.push(name);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                var key = pluginList.join("|");
                var cls = parserClassCache.get(key);
                if (!cls) {
                    cls = Parser;
                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                    try {
                        for(var _iterator1 = pluginList[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                            var plugin = _step1.value;
                            cls = mixinPlugins[plugin](cls);
                        }
                    } catch (err) {
                        _didIteratorError1 = true;
                        _iteratorError1 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                _iterator1.return();
                            }
                        } finally{
                            if (_didIteratorError1) {
                                throw _iteratorError1;
                            }
                        }
                    }
                    parserClassCache.set(key, cls);
                }
                return cls;
            }
            exports.parse = parse;
            exports.parseExpression = parseExpression;
            exports.tokTypes = tokTypes;
        }
    });
    // ../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/umd/estree-walker.js
    var require_estree_walker = __commonJS({
        "../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/umd/estree-walker.js": function(exports, module) {
            "use strict";
            (function(global2, factory) {
                (typeof exports === "undefined" ? "undefined" : _type_of(exports)) === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define([
                    "exports"
                ], factory) : (global2 = global2 || self, factory(global2.estreeWalker = {}));
            })(exports, function(exports2) {
                "use strict";
                var WalkerBase = /*#__PURE__*/ function() {
                    function WalkerBase() {
                        var _this = this;
                        _class_call_check(this, WalkerBase);
                        this.should_skip = false;
                        this.should_remove = false;
                        this.replacement = null;
                        this.context = {
                            skip: function() {
                                return _this.should_skip = true;
                            },
                            remove: function() {
                                return _this.should_remove = true;
                            },
                            replace: function(node) {
                                return _this.replacement = node;
                            }
                        };
                    }
                    _create_class(WalkerBase, [
                        {
                            /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           * @param {BaseNode} node
           */ key: "replace",
                            value: function replace(parent, prop, index, node) {
                                if (parent) {
                                    if (index !== null) {
                                        parent[prop][index] = node;
                                    } else {
                                        parent[prop] = node;
                                    }
                                }
                            }
                        },
                        {
                            /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           */ key: "remove",
                            value: function remove(parent, prop, index) {
                                if (parent) {
                                    if (index !== null) {
                                        parent[prop].splice(index, 1);
                                    } else {
                                        delete parent[prop];
                                    }
                                }
                            }
                        }
                    ]);
                    return WalkerBase;
                }();
                var SyncWalker = /*#__PURE__*/ function(WalkerBase) {
                    _inherits(SyncWalker, WalkerBase);
                    function SyncWalker(enter, leave) {
                        _class_call_check(this, SyncWalker);
                        var _this;
                        _this = _call_super(this, SyncWalker);
                        _this.enter = enter;
                        _this.leave = leave;
                        return _this;
                    }
                    _create_class(SyncWalker, [
                        {
                            /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {BaseNode}
           */ key: "visit",
                            value: function visit(node, parent, prop, index) {
                                if (node) {
                                    if (this.enter) {
                                        var _should_skip = this.should_skip;
                                        var _should_remove = this.should_remove;
                                        var _replacement = this.replacement;
                                        this.should_skip = false;
                                        this.should_remove = false;
                                        this.replacement = null;
                                        this.enter.call(this.context, node, parent, prop, index);
                                        if (this.replacement) {
                                            node = this.replacement;
                                            this.replace(parent, prop, index, node);
                                        }
                                        if (this.should_remove) {
                                            this.remove(parent, prop, index);
                                        }
                                        var skipped = this.should_skip;
                                        var removed = this.should_remove;
                                        this.should_skip = _should_skip;
                                        this.should_remove = _should_remove;
                                        this.replacement = _replacement;
                                        if (skipped) return node;
                                        if (removed) return null;
                                    }
                                    for(var key in node){
                                        var value = node[key];
                                        if ((typeof value === "undefined" ? "undefined" : _type_of(value)) !== "object") {
                                            continue;
                                        } else if (Array.isArray(value)) {
                                            for(var i = 0; i < value.length; i += 1){
                                                if (value[i] !== null && typeof value[i].type === "string") {
                                                    if (!this.visit(value[i], node, key, i)) {
                                                        i--;
                                                    }
                                                }
                                            }
                                        } else if (value !== null && typeof value.type === "string") {
                                            this.visit(value, node, key, null);
                                        }
                                    }
                                    if (this.leave) {
                                        var _replacement1 = this.replacement;
                                        var _should_remove1 = this.should_remove;
                                        this.replacement = null;
                                        this.should_remove = false;
                                        this.leave.call(this.context, node, parent, prop, index);
                                        if (this.replacement) {
                                            node = this.replacement;
                                            this.replace(parent, prop, index, node);
                                        }
                                        if (this.should_remove) {
                                            this.remove(parent, prop, index);
                                        }
                                        var removed1 = this.should_remove;
                                        this.replacement = _replacement1;
                                        this.should_remove = _should_remove1;
                                        if (removed1) return null;
                                    }
                                }
                                return node;
                            }
                        }
                    ]);
                    return SyncWalker;
                }(WalkerBase);
                var AsyncWalker = /*#__PURE__*/ function(WalkerBase) {
                    _inherits(AsyncWalker, WalkerBase);
                    function AsyncWalker(enter, leave) {
                        _class_call_check(this, AsyncWalker);
                        var _this;
                        _this = _call_super(this, AsyncWalker);
                        _this.enter = enter;
                        _this.leave = leave;
                        return _this;
                    }
                    _create_class(AsyncWalker, [
                        {
                            key: "visit",
                            value: /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {Promise<BaseNode>}
           */ function visit(node, parent, prop, index) {
                                var _this = this;
                                return _async_to_generator(function() {
                                    var _should_skip, _should_remove, _replacement, skipped, removed, _tmp, _tmp1, _i, key, value, i, _replacement1, _should_remove1, removed1;
                                    return _ts_generator(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                if (!node) return [
                                                    3,
                                                    14
                                                ];
                                                if (!_this.enter) return [
                                                    3,
                                                    2
                                                ];
                                                _should_skip = _this.should_skip;
                                                _should_remove = _this.should_remove;
                                                _replacement = _this.replacement;
                                                _this.should_skip = false;
                                                _this.should_remove = false;
                                                _this.replacement = null;
                                                return [
                                                    4,
                                                    _this.enter.call(_this.context, node, parent, prop, index)
                                                ];
                                            case 1:
                                                _state.sent();
                                                if (_this.replacement) {
                                                    node = _this.replacement;
                                                    _this.replace(parent, prop, index, node);
                                                }
                                                if (_this.should_remove) {
                                                    _this.remove(parent, prop, index);
                                                }
                                                skipped = _this.should_skip;
                                                removed = _this.should_remove;
                                                _this.should_skip = _should_skip;
                                                _this.should_remove = _should_remove;
                                                _this.replacement = _replacement;
                                                if (skipped) return [
                                                    2,
                                                    node
                                                ];
                                                if (removed) return [
                                                    2,
                                                    null
                                                ];
                                                _state.label = 2;
                                            case 2:
                                                _tmp = [];
                                                for(_tmp1 in node)_tmp.push(_tmp1);
                                                _i = 0;
                                                _state.label = 3;
                                            case 3:
                                                if (!(_i < _tmp.length)) return [
                                                    3,
                                                    12
                                                ];
                                                key = _tmp[_i];
                                                value = node[key];
                                                if (!((typeof value === "undefined" ? "undefined" : _type_of(value)) !== "object")) return [
                                                    3,
                                                    4
                                                ];
                                                return [
                                                    3,
                                                    11
                                                ];
                                            case 4:
                                                if (!Array.isArray(value)) return [
                                                    3,
                                                    9
                                                ];
                                                i = 0;
                                                _state.label = 5;
                                            case 5:
                                                if (!(i < value.length)) return [
                                                    3,
                                                    8
                                                ];
                                                if (!(value[i] !== null && typeof value[i].type === "string")) return [
                                                    3,
                                                    7
                                                ];
                                                return [
                                                    4,
                                                    _this.visit(value[i], node, key, i)
                                                ];
                                            case 6:
                                                if (!_state.sent()) {
                                                    i--;
                                                }
                                                _state.label = 7;
                                            case 7:
                                                i += 1;
                                                return [
                                                    3,
                                                    5
                                                ];
                                            case 8:
                                                return [
                                                    3,
                                                    11
                                                ];
                                            case 9:
                                                if (!(value !== null && typeof value.type === "string")) return [
                                                    3,
                                                    11
                                                ];
                                                return [
                                                    4,
                                                    _this.visit(value, node, key, null)
                                                ];
                                            case 10:
                                                _state.sent();
                                                _state.label = 11;
                                            case 11:
                                                _i++;
                                                return [
                                                    3,
                                                    3
                                                ];
                                            case 12:
                                                if (!_this.leave) return [
                                                    3,
                                                    14
                                                ];
                                                _replacement1 = _this.replacement;
                                                _should_remove1 = _this.should_remove;
                                                _this.replacement = null;
                                                _this.should_remove = false;
                                                return [
                                                    4,
                                                    _this.leave.call(_this.context, node, parent, prop, index)
                                                ];
                                            case 13:
                                                _state.sent();
                                                if (_this.replacement) {
                                                    node = _this.replacement;
                                                    _this.replace(parent, prop, index, node);
                                                }
                                                if (_this.should_remove) {
                                                    _this.remove(parent, prop, index);
                                                }
                                                removed1 = _this.should_remove;
                                                _this.replacement = _replacement1;
                                                _this.should_remove = _should_remove1;
                                                if (removed1) return [
                                                    2,
                                                    null
                                                ];
                                                _state.label = 14;
                                            case 14:
                                                return [
                                                    2,
                                                    node
                                                ];
                                        }
                                    });
                                })();
                            }
                        }
                    ]);
                    return AsyncWalker;
                }(WalkerBase);
                function walk(ast, param) {
                    var enter = param.enter, leave = param.leave;
                    var instance = new SyncWalker(enter, leave);
                    return instance.visit(ast, null);
                }
                function asyncWalk(ast, _) {
                    return _asyncWalk.apply(this, arguments);
                }
                function _asyncWalk() {
                    _asyncWalk = _async_to_generator(function(ast, param) {
                        var enter, leave, instance;
                        return _ts_generator(this, function(_state) {
                            switch(_state.label){
                                case 0:
                                    enter = param.enter, leave = param.leave;
                                    instance = new AsyncWalker(enter, leave);
                                    return [
                                        4,
                                        instance.visit(ast, null)
                                    ];
                                case 1:
                                    return [
                                        2,
                                        _state.sent()
                                    ];
                            }
                        });
                    });
                    return _asyncWalk.apply(this, arguments);
                }
                exports2.asyncWalk = asyncWalk;
                exports2.walk = walk;
                Object.defineProperty(exports2, "__esModule", {
                    value: true
                });
            });
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js
    var require_base64 = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64.js": function(exports) {
            "use strict";
            var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
            exports.encode = function(number) {
                if (0 <= number && number < intToCharMap.length) {
                    return intToCharMap[number];
                }
                throw new TypeError("Must be between 0 and 63: " + number);
            };
            exports.decode = function(charCode) {
                var bigA = 65;
                var bigZ = 90;
                var littleA = 97;
                var littleZ = 122;
                var zero = 48;
                var nine = 57;
                var plus = 43;
                var slash = 47;
                var littleOffset = 26;
                var numberOffset = 52;
                if (bigA <= charCode && charCode <= bigZ) {
                    return charCode - bigA;
                }
                if (littleA <= charCode && charCode <= littleZ) {
                    return charCode - littleA + littleOffset;
                }
                if (zero <= charCode && charCode <= nine) {
                    return charCode - zero + numberOffset;
                }
                if (charCode == plus) {
                    return 62;
                }
                if (charCode == slash) {
                    return 63;
                }
                return -1;
            };
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js
    var require_base64_vlq = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/base64-vlq.js": function(exports) {
            "use strict";
            var base64 = require_base64();
            var VLQ_BASE_SHIFT = 5;
            var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
            var VLQ_BASE_MASK = VLQ_BASE - 1;
            var VLQ_CONTINUATION_BIT = VLQ_BASE;
            function toVLQSigned(aValue) {
                return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
            }
            function fromVLQSigned(aValue) {
                var isNegative = (aValue & 1) === 1;
                var shifted = aValue >> 1;
                return isNegative ? -shifted : shifted;
            }
            exports.encode = function base64VLQ_encode(aValue) {
                var encoded = "";
                var digit;
                var vlq = toVLQSigned(aValue);
                do {
                    digit = vlq & VLQ_BASE_MASK;
                    vlq >>>= VLQ_BASE_SHIFT;
                    if (vlq > 0) {
                        digit |= VLQ_CONTINUATION_BIT;
                    }
                    encoded += base64.encode(digit);
                }while (vlq > 0);
                return encoded;
            };
            exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
                var strLen = aStr.length;
                var result = 0;
                var shift = 0;
                var continuation, digit;
                do {
                    if (aIndex >= strLen) {
                        throw new Error("Expected more digits in base 64 VLQ value.");
                    }
                    digit = base64.decode(aStr.charCodeAt(aIndex++));
                    if (digit === -1) {
                        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
                    }
                    continuation = !!(digit & VLQ_CONTINUATION_BIT);
                    digit &= VLQ_BASE_MASK;
                    result = result + (digit << shift);
                    shift += VLQ_BASE_SHIFT;
                }while (continuation);
                aOutParam.value = fromVLQSigned(result);
                aOutParam.rest = aIndex;
            };
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js
    var require_util = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/util.js": function(exports) {
            "use strict";
            function getArg(aArgs, aName, aDefaultValue) {
                if (aName in aArgs) {
                    return aArgs[aName];
                } else if (arguments.length === 3) {
                    return aDefaultValue;
                } else {
                    throw new Error('"' + aName + '" is a required argument.');
                }
            }
            exports.getArg = getArg;
            var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
            var dataUrlRegexp = /^data:.+\,.+$/;
            function urlParse(aUrl) {
                var match = aUrl.match(urlRegexp);
                if (!match) {
                    return null;
                }
                return {
                    scheme: match[1],
                    auth: match[2],
                    host: match[3],
                    port: match[4],
                    path: match[5]
                };
            }
            exports.urlParse = urlParse;
            function urlGenerate(aParsedUrl) {
                var url = "";
                if (aParsedUrl.scheme) {
                    url += aParsedUrl.scheme + ":";
                }
                url += "//";
                if (aParsedUrl.auth) {
                    url += aParsedUrl.auth + "@";
                }
                if (aParsedUrl.host) {
                    url += aParsedUrl.host;
                }
                if (aParsedUrl.port) {
                    url += ":" + aParsedUrl.port;
                }
                if (aParsedUrl.path) {
                    url += aParsedUrl.path;
                }
                return url;
            }
            exports.urlGenerate = urlGenerate;
            var MAX_CACHED_INPUTS = 32;
            function lruMemoize(f) {
                var cache = [];
                return function(input) {
                    for(var i = 0; i < cache.length; i++){
                        if (cache[i].input === input) {
                            var temp = cache[0];
                            cache[0] = cache[i];
                            cache[i] = temp;
                            return cache[0].result;
                        }
                    }
                    var result = f(input);
                    cache.unshift({
                        input: input,
                        result: result
                    });
                    if (cache.length > MAX_CACHED_INPUTS) {
                        cache.pop();
                    }
                    return result;
                };
            }
            var normalize = lruMemoize(function normalize2(aPath) {
                var path = aPath;
                var url = urlParse(aPath);
                if (url) {
                    if (!url.path) {
                        return aPath;
                    }
                    path = url.path;
                }
                var isAbsolute = exports.isAbsolute(path);
                var parts = [];
                var start = 0;
                var i = 0;
                while(true){
                    start = i;
                    i = path.indexOf("/", start);
                    if (i === -1) {
                        parts.push(path.slice(start));
                        break;
                    } else {
                        parts.push(path.slice(start, i));
                        while(i < path.length && path[i] === "/"){
                            i++;
                        }
                    }
                }
                for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
                    part = parts[i];
                    if (part === ".") {
                        parts.splice(i, 1);
                    } else if (part === "..") {
                        up++;
                    } else if (up > 0) {
                        if (part === "") {
                            parts.splice(i + 1, up);
                            up = 0;
                        } else {
                            parts.splice(i, 2);
                            up--;
                        }
                    }
                }
                path = parts.join("/");
                if (path === "") {
                    path = isAbsolute ? "/" : ".";
                }
                if (url) {
                    url.path = path;
                    return urlGenerate(url);
                }
                return path;
            });
            exports.normalize = normalize;
            function join(aRoot, aPath) {
                if (aRoot === "") {
                    aRoot = ".";
                }
                if (aPath === "") {
                    aPath = ".";
                }
                var aPathUrl = urlParse(aPath);
                var aRootUrl = urlParse(aRoot);
                if (aRootUrl) {
                    aRoot = aRootUrl.path || "/";
                }
                if (aPathUrl && !aPathUrl.scheme) {
                    if (aRootUrl) {
                        aPathUrl.scheme = aRootUrl.scheme;
                    }
                    return urlGenerate(aPathUrl);
                }
                if (aPathUrl || aPath.match(dataUrlRegexp)) {
                    return aPath;
                }
                if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                    aRootUrl.host = aPath;
                    return urlGenerate(aRootUrl);
                }
                var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
                if (aRootUrl) {
                    aRootUrl.path = joined;
                    return urlGenerate(aRootUrl);
                }
                return joined;
            }
            exports.join = join;
            exports.isAbsolute = function(aPath) {
                return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
            };
            function relative(aRoot, aPath) {
                if (aRoot === "") {
                    aRoot = ".";
                }
                aRoot = aRoot.replace(/\/$/, "");
                var level = 0;
                while(aPath.indexOf(aRoot + "/") !== 0){
                    var index = aRoot.lastIndexOf("/");
                    if (index < 0) {
                        return aPath;
                    }
                    aRoot = aRoot.slice(0, index);
                    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                        return aPath;
                    }
                    ++level;
                }
                return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
            }
            exports.relative = relative;
            var supportsNullProto = function() {
                var obj = /* @__PURE__ */ Object.create(null);
                return !("__proto__" in obj);
            }();
            function identity(s) {
                return s;
            }
            function toSetString(aStr) {
                if (isProtoString(aStr)) {
                    return "$" + aStr;
                }
                return aStr;
            }
            exports.toSetString = supportsNullProto ? identity : toSetString;
            function fromSetString(aStr) {
                if (isProtoString(aStr)) {
                    return aStr.slice(1);
                }
                return aStr;
            }
            exports.fromSetString = supportsNullProto ? identity : fromSetString;
            function isProtoString(s) {
                if (!s) {
                    return false;
                }
                var length = s.length;
                if (length < 9) {
                    return false;
                }
                if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
                    return false;
                }
                for(var i = length - 10; i >= 0; i--){
                    if (s.charCodeAt(i) !== 36) {
                        return false;
                    }
                }
                return true;
            }
            function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
                var cmp = strcmp(mappingA.source, mappingB.source);
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalLine - mappingB.originalLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalColumn - mappingB.originalColumn;
                if (cmp !== 0 || onlyCompareOriginal) {
                    return cmp;
                }
                cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.generatedLine - mappingB.generatedLine;
                if (cmp !== 0) {
                    return cmp;
                }
                return strcmp(mappingA.name, mappingB.name);
            }
            exports.compareByOriginalPositions = compareByOriginalPositions;
            function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
                var cmp;
                cmp = mappingA.originalLine - mappingB.originalLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalColumn - mappingB.originalColumn;
                if (cmp !== 0 || onlyCompareOriginal) {
                    return cmp;
                }
                cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.generatedLine - mappingB.generatedLine;
                if (cmp !== 0) {
                    return cmp;
                }
                return strcmp(mappingA.name, mappingB.name);
            }
            exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
            function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
                var cmp = mappingA.generatedLine - mappingB.generatedLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                if (cmp !== 0 || onlyCompareGenerated) {
                    return cmp;
                }
                cmp = strcmp(mappingA.source, mappingB.source);
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalLine - mappingB.originalLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalColumn - mappingB.originalColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                return strcmp(mappingA.name, mappingB.name);
            }
            exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
            function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
                var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                if (cmp !== 0 || onlyCompareGenerated) {
                    return cmp;
                }
                cmp = strcmp(mappingA.source, mappingB.source);
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalLine - mappingB.originalLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalColumn - mappingB.originalColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                return strcmp(mappingA.name, mappingB.name);
            }
            exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
            function strcmp(aStr1, aStr2) {
                if (aStr1 === aStr2) {
                    return 0;
                }
                if (aStr1 === null) {
                    return 1;
                }
                if (aStr2 === null) {
                    return -1;
                }
                if (aStr1 > aStr2) {
                    return 1;
                }
                return -1;
            }
            function compareByGeneratedPositionsInflated(mappingA, mappingB) {
                var cmp = mappingA.generatedLine - mappingB.generatedLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.generatedColumn - mappingB.generatedColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = strcmp(mappingA.source, mappingB.source);
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalLine - mappingB.originalLine;
                if (cmp !== 0) {
                    return cmp;
                }
                cmp = mappingA.originalColumn - mappingB.originalColumn;
                if (cmp !== 0) {
                    return cmp;
                }
                return strcmp(mappingA.name, mappingB.name);
            }
            exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
            function parseSourceMapInput(str) {
                return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
            }
            exports.parseSourceMapInput = parseSourceMapInput;
            function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
                sourceURL = sourceURL || "";
                if (sourceRoot) {
                    if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
                        sourceRoot += "/";
                    }
                    sourceURL = sourceRoot + sourceURL;
                }
                if (sourceMapURL) {
                    var parsed = urlParse(sourceMapURL);
                    if (!parsed) {
                        throw new Error("sourceMapURL could not be parsed");
                    }
                    if (parsed.path) {
                        var index = parsed.path.lastIndexOf("/");
                        if (index >= 0) {
                            parsed.path = parsed.path.substring(0, index + 1);
                        }
                    }
                    sourceURL = join(urlGenerate(parsed), sourceURL);
                }
                return normalize(sourceURL);
            }
            exports.computeSourceURL = computeSourceURL;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js
    var require_array_set = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/array-set.js": function(exports) {
            "use strict";
            var util = require_util();
            var has = Object.prototype.hasOwnProperty;
            var hasNativeMap = typeof Map !== "undefined";
            function ArraySet() {
                this._array = [];
                this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
            }
            ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
                var set = new ArraySet();
                for(var i = 0, len = aArray.length; i < len; i++){
                    set.add(aArray[i], aAllowDuplicates);
                }
                return set;
            };
            ArraySet.prototype.size = function ArraySet_size() {
                return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
            };
            ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
                var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
                var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
                var idx = this._array.length;
                if (!isDuplicate || aAllowDuplicates) {
                    this._array.push(aStr);
                }
                if (!isDuplicate) {
                    if (hasNativeMap) {
                        this._set.set(aStr, idx);
                    } else {
                        this._set[sStr] = idx;
                    }
                }
            };
            ArraySet.prototype.has = function ArraySet_has(aStr) {
                if (hasNativeMap) {
                    return this._set.has(aStr);
                } else {
                    var sStr = util.toSetString(aStr);
                    return has.call(this._set, sStr);
                }
            };
            ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
                if (hasNativeMap) {
                    var idx = this._set.get(aStr);
                    if (idx >= 0) {
                        return idx;
                    }
                } else {
                    var sStr = util.toSetString(aStr);
                    if (has.call(this._set, sStr)) {
                        return this._set[sStr];
                    }
                }
                throw new Error('"' + aStr + '" is not in the set.');
            };
            ArraySet.prototype.at = function ArraySet_at(aIdx) {
                if (aIdx >= 0 && aIdx < this._array.length) {
                    return this._array[aIdx];
                }
                throw new Error("No element indexed by " + aIdx);
            };
            ArraySet.prototype.toArray = function ArraySet_toArray() {
                return this._array.slice();
            };
            exports.ArraySet = ArraySet;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js
    var require_mapping_list = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/mapping-list.js": function(exports) {
            "use strict";
            var util = require_util();
            function generatedPositionAfter(mappingA, mappingB) {
                var lineA = mappingA.generatedLine;
                var lineB = mappingB.generatedLine;
                var columnA = mappingA.generatedColumn;
                var columnB = mappingB.generatedColumn;
                return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
            }
            function MappingList() {
                this._array = [];
                this._sorted = true;
                this._last = {
                    generatedLine: -1,
                    generatedColumn: 0
                };
            }
            MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
                this._array.forEach(aCallback, aThisArg);
            };
            MappingList.prototype.add = function MappingList_add(aMapping) {
                if (generatedPositionAfter(this._last, aMapping)) {
                    this._last = aMapping;
                    this._array.push(aMapping);
                } else {
                    this._sorted = false;
                    this._array.push(aMapping);
                }
            };
            MappingList.prototype.toArray = function MappingList_toArray() {
                if (!this._sorted) {
                    this._array.sort(util.compareByGeneratedPositionsInflated);
                    this._sorted = true;
                }
                return this._array;
            };
            exports.MappingList = MappingList;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js
    var require_source_map_generator = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-generator.js": function(exports) {
            "use strict";
            var base64VLQ = require_base64_vlq();
            var util = require_util();
            var ArraySet = require_array_set().ArraySet;
            var MappingList = require_mapping_list().MappingList;
            function SourceMapGenerator(aArgs) {
                if (!aArgs) {
                    aArgs = {};
                }
                this._file = util.getArg(aArgs, "file", null);
                this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
                this._skipValidation = util.getArg(aArgs, "skipValidation", false);
                this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
                this._sources = new ArraySet();
                this._names = new ArraySet();
                this._mappings = new MappingList();
                this._sourcesContents = null;
            }
            SourceMapGenerator.prototype._version = 3;
            SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
                var sourceRoot = aSourceMapConsumer.sourceRoot;
                var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
                    file: aSourceMapConsumer.file,
                    sourceRoot: sourceRoot
                }));
                aSourceMapConsumer.eachMapping(function(mapping) {
                    var newMapping = {
                        generated: {
                            line: mapping.generatedLine,
                            column: mapping.generatedColumn
                        }
                    };
                    if (mapping.source != null) {
                        newMapping.source = mapping.source;
                        if (sourceRoot != null) {
                            newMapping.source = util.relative(sourceRoot, newMapping.source);
                        }
                        newMapping.original = {
                            line: mapping.originalLine,
                            column: mapping.originalColumn
                        };
                        if (mapping.name != null) {
                            newMapping.name = mapping.name;
                        }
                    }
                    generator.addMapping(newMapping);
                });
                aSourceMapConsumer.sources.forEach(function(sourceFile) {
                    var sourceRelative = sourceFile;
                    if (sourceRoot !== null) {
                        sourceRelative = util.relative(sourceRoot, sourceFile);
                    }
                    if (!generator._sources.has(sourceRelative)) {
                        generator._sources.add(sourceRelative);
                    }
                    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                    if (content != null) {
                        generator.setSourceContent(sourceFile, content);
                    }
                });
                return generator;
            };
            SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
                var generated = util.getArg(aArgs, "generated");
                var original = util.getArg(aArgs, "original", null);
                var source = util.getArg(aArgs, "source", null);
                var name = util.getArg(aArgs, "name", null);
                if (!this._skipValidation) {
                    if (this._validateMapping(generated, original, source, name) === false) {
                        return;
                    }
                }
                if (source != null) {
                    source = String(source);
                    if (!this._sources.has(source)) {
                        this._sources.add(source);
                    }
                }
                if (name != null) {
                    name = String(name);
                    if (!this._names.has(name)) {
                        this._names.add(name);
                    }
                }
                this._mappings.add({
                    generatedLine: generated.line,
                    generatedColumn: generated.column,
                    originalLine: original != null && original.line,
                    originalColumn: original != null && original.column,
                    source: source,
                    name: name
                });
            };
            SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
                var source = aSourceFile;
                if (this._sourceRoot != null) {
                    source = util.relative(this._sourceRoot, source);
                }
                if (aSourceContent != null) {
                    if (!this._sourcesContents) {
                        this._sourcesContents = /* @__PURE__ */ Object.create(null);
                    }
                    this._sourcesContents[util.toSetString(source)] = aSourceContent;
                } else if (this._sourcesContents) {
                    delete this._sourcesContents[util.toSetString(source)];
                    if (Object.keys(this._sourcesContents).length === 0) {
                        this._sourcesContents = null;
                    }
                }
            };
            SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
                var sourceFile = aSourceFile;
                if (aSourceFile == null) {
                    if (aSourceMapConsumer.file == null) {
                        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
                    }
                    sourceFile = aSourceMapConsumer.file;
                }
                var sourceRoot = this._sourceRoot;
                if (sourceRoot != null) {
                    sourceFile = util.relative(sourceRoot, sourceFile);
                }
                var newSources = new ArraySet();
                var newNames = new ArraySet();
                this._mappings.unsortedForEach(function(mapping) {
                    if (mapping.source === sourceFile && mapping.originalLine != null) {
                        var original = aSourceMapConsumer.originalPositionFor({
                            line: mapping.originalLine,
                            column: mapping.originalColumn
                        });
                        if (original.source != null) {
                            mapping.source = original.source;
                            if (aSourceMapPath != null) {
                                mapping.source = util.join(aSourceMapPath, mapping.source);
                            }
                            if (sourceRoot != null) {
                                mapping.source = util.relative(sourceRoot, mapping.source);
                            }
                            mapping.originalLine = original.line;
                            mapping.originalColumn = original.column;
                            if (original.name != null) {
                                mapping.name = original.name;
                            }
                        }
                    }
                    var source = mapping.source;
                    if (source != null && !newSources.has(source)) {
                        newSources.add(source);
                    }
                    var name = mapping.name;
                    if (name != null && !newNames.has(name)) {
                        newNames.add(name);
                    }
                }, this);
                this._sources = newSources;
                this._names = newNames;
                aSourceMapConsumer.sources.forEach(function(sourceFile2) {
                    var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
                    if (content != null) {
                        if (aSourceMapPath != null) {
                            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
                        }
                        if (sourceRoot != null) {
                            sourceFile2 = util.relative(sourceRoot, sourceFile2);
                        }
                        this.setSourceContent(sourceFile2, content);
                    }
                }, this);
            };
            SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
                if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
                    var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
                    if (this._ignoreInvalidMapping) {
                        if (typeof console !== "undefined" && console.warn) {
                            console.warn(message);
                        }
                        return false;
                    } else {
                        throw new Error(message);
                    }
                }
                if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
                    return;
                } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
                    return;
                } else {
                    var message = "Invalid mapping: " + JSON.stringify({
                        generated: aGenerated,
                        source: aSource,
                        original: aOriginal,
                        name: aName
                    });
                    if (this._ignoreInvalidMapping) {
                        if (typeof console !== "undefined" && console.warn) {
                            console.warn(message);
                        }
                        return false;
                    } else {
                        throw new Error(message);
                    }
                }
            };
            SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
                var previousGeneratedColumn = 0;
                var previousGeneratedLine = 1;
                var previousOriginalColumn = 0;
                var previousOriginalLine = 0;
                var previousName = 0;
                var previousSource = 0;
                var result = "";
                var next;
                var mapping;
                var nameIdx;
                var sourceIdx;
                var mappings = this._mappings.toArray();
                for(var i = 0, len = mappings.length; i < len; i++){
                    mapping = mappings[i];
                    next = "";
                    if (mapping.generatedLine !== previousGeneratedLine) {
                        previousGeneratedColumn = 0;
                        while(mapping.generatedLine !== previousGeneratedLine){
                            next += ";";
                            previousGeneratedLine++;
                        }
                    } else {
                        if (i > 0) {
                            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                                continue;
                            }
                            next += ",";
                        }
                    }
                    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
                    previousGeneratedColumn = mapping.generatedColumn;
                    if (mapping.source != null) {
                        sourceIdx = this._sources.indexOf(mapping.source);
                        next += base64VLQ.encode(sourceIdx - previousSource);
                        previousSource = sourceIdx;
                        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
                        previousOriginalLine = mapping.originalLine - 1;
                        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
                        previousOriginalColumn = mapping.originalColumn;
                        if (mapping.name != null) {
                            nameIdx = this._names.indexOf(mapping.name);
                            next += base64VLQ.encode(nameIdx - previousName);
                            previousName = nameIdx;
                        }
                    }
                    result += next;
                }
                return result;
            };
            SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
                return aSources.map(function(source) {
                    if (!this._sourcesContents) {
                        return null;
                    }
                    if (aSourceRoot != null) {
                        source = util.relative(aSourceRoot, source);
                    }
                    var key = util.toSetString(source);
                    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
                }, this);
            };
            SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
                var map = {
                    version: this._version,
                    sources: this._sources.toArray(),
                    names: this._names.toArray(),
                    mappings: this._serializeMappings()
                };
                if (this._file != null) {
                    map.file = this._file;
                }
                if (this._sourceRoot != null) {
                    map.sourceRoot = this._sourceRoot;
                }
                if (this._sourcesContents) {
                    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
                }
                return map;
            };
            SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
                return JSON.stringify(this.toJSON());
            };
            exports.SourceMapGenerator = SourceMapGenerator;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js
    var require_binary_search = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/binary-search.js": function(exports) {
            "use strict";
            exports.GREATEST_LOWER_BOUND = 1;
            exports.LEAST_UPPER_BOUND = 2;
            function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
                var mid = Math.floor((aHigh - aLow) / 2) + aLow;
                var cmp = aCompare(aNeedle, aHaystack[mid], true);
                if (cmp === 0) {
                    return mid;
                } else if (cmp > 0) {
                    if (aHigh - mid > 1) {
                        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                    }
                    if (aBias == exports.LEAST_UPPER_BOUND) {
                        return aHigh < aHaystack.length ? aHigh : -1;
                    } else {
                        return mid;
                    }
                } else {
                    if (mid - aLow > 1) {
                        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
                    }
                    if (aBias == exports.LEAST_UPPER_BOUND) {
                        return mid;
                    } else {
                        return aLow < 0 ? -1 : aLow;
                    }
                }
            }
            exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
                if (aHaystack.length === 0) {
                    return -1;
                }
                var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
                if (index < 0) {
                    return -1;
                }
                while(index - 1 >= 0){
                    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                        break;
                    }
                    --index;
                }
                return index;
            };
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js
    var require_quick_sort = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/quick-sort.js": function(exports) {
            "use strict";
            function SortTemplate(comparator) {
                function swap(ary, x, y) {
                    var temp = ary[x];
                    ary[x] = ary[y];
                    ary[y] = temp;
                }
                function randomIntInRange(low, high) {
                    return Math.round(low + Math.random() * (high - low));
                }
                function doQuickSort(ary, comparator2, p, r) {
                    if (p < r) {
                        var pivotIndex = randomIntInRange(p, r);
                        var i = p - 1;
                        swap(ary, pivotIndex, r);
                        var pivot = ary[r];
                        for(var j = p; j < r; j++){
                            if (comparator2(ary[j], pivot, false) <= 0) {
                                i += 1;
                                swap(ary, i, j);
                            }
                        }
                        swap(ary, i + 1, j);
                        var q = i + 1;
                        doQuickSort(ary, comparator2, p, q - 1);
                        doQuickSort(ary, comparator2, q + 1, r);
                    }
                }
                return doQuickSort;
            }
            function cloneSort(comparator) {
                var template = SortTemplate.toString();
                var templateFn = new Function("return ".concat(template))();
                return templateFn(comparator);
            }
            var sortCache = /* @__PURE__ */ new WeakMap();
            exports.quickSort = function(ary, comparator) {
                var start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                var doQuickSort = sortCache.get(comparator);
                if (doQuickSort === void 0) {
                    doQuickSort = cloneSort(comparator);
                    sortCache.set(comparator, doQuickSort);
                }
                doQuickSort(ary, comparator, start, ary.length - 1);
            };
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js
    var require_source_map_consumer = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-map-consumer.js": function(exports) {
            "use strict";
            var util = require_util();
            var binarySearch = require_binary_search();
            var ArraySet = require_array_set().ArraySet;
            var base64VLQ = require_base64_vlq();
            var quickSort = require_quick_sort().quickSort;
            function SourceMapConsumer(aSourceMap, aSourceMapURL) {
                var sourceMap = aSourceMap;
                if (typeof aSourceMap === "string") {
                    sourceMap = util.parseSourceMapInput(aSourceMap);
                }
                return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
            }
            SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
                return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
            };
            SourceMapConsumer.prototype._version = 3;
            SourceMapConsumer.prototype.__generatedMappings = null;
            Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
                configurable: true,
                enumerable: true,
                get: function get() {
                    if (!this.__generatedMappings) {
                        this._parseMappings(this._mappings, this.sourceRoot);
                    }
                    return this.__generatedMappings;
                }
            });
            SourceMapConsumer.prototype.__originalMappings = null;
            Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
                configurable: true,
                enumerable: true,
                get: function get() {
                    if (!this.__originalMappings) {
                        this._parseMappings(this._mappings, this.sourceRoot);
                    }
                    return this.__originalMappings;
                }
            });
            SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
                var c = aStr.charAt(index);
                return c === ";" || c === ",";
            };
            SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
                throw new Error("Subclasses must implement _parseMappings");
            };
            SourceMapConsumer.GENERATED_ORDER = 1;
            SourceMapConsumer.ORIGINAL_ORDER = 2;
            SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
            SourceMapConsumer.LEAST_UPPER_BOUND = 2;
            SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
                var context = aContext || null;
                var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
                var mappings;
                switch(order){
                    case SourceMapConsumer.GENERATED_ORDER:
                        mappings = this._generatedMappings;
                        break;
                    case SourceMapConsumer.ORIGINAL_ORDER:
                        mappings = this._originalMappings;
                        break;
                    default:
                        throw new Error("Unknown order of iteration.");
                }
                var sourceRoot = this.sourceRoot;
                var boundCallback = aCallback.bind(context);
                var names = this._names;
                var sources = this._sources;
                var sourceMapURL = this._sourceMapURL;
                for(var i = 0, n = mappings.length; i < n; i++){
                    var mapping = mappings[i];
                    var source = mapping.source === null ? null : sources.at(mapping.source);
                    if (source !== null) {
                        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
                    }
                    boundCallback({
                        source: source,
                        generatedLine: mapping.generatedLine,
                        generatedColumn: mapping.generatedColumn,
                        originalLine: mapping.originalLine,
                        originalColumn: mapping.originalColumn,
                        name: mapping.name === null ? null : names.at(mapping.name)
                    });
                }
            };
            SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
                var line = util.getArg(aArgs, "line");
                var needle = {
                    source: util.getArg(aArgs, "source"),
                    originalLine: line,
                    originalColumn: util.getArg(aArgs, "column", 0)
                };
                needle.source = this._findSourceIndex(needle.source);
                if (needle.source < 0) {
                    return [];
                }
                var mappings = [];
                var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
                if (index >= 0) {
                    var mapping = this._originalMappings[index];
                    if (aArgs.column === void 0) {
                        var originalLine = mapping.originalLine;
                        while(mapping && mapping.originalLine === originalLine){
                            mappings.push({
                                line: util.getArg(mapping, "generatedLine", null),
                                column: util.getArg(mapping, "generatedColumn", null),
                                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
                            });
                            mapping = this._originalMappings[++index];
                        }
                    } else {
                        var originalColumn = mapping.originalColumn;
                        while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                            mappings.push({
                                line: util.getArg(mapping, "generatedLine", null),
                                column: util.getArg(mapping, "generatedColumn", null),
                                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
                            });
                            mapping = this._originalMappings[++index];
                        }
                    }
                }
                return mappings;
            };
            exports.SourceMapConsumer = SourceMapConsumer;
            function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
                var sourceMap = aSourceMap;
                if (typeof aSourceMap === "string") {
                    sourceMap = util.parseSourceMapInput(aSourceMap);
                }
                var version = util.getArg(sourceMap, "version");
                var sources = util.getArg(sourceMap, "sources");
                var names = util.getArg(sourceMap, "names", []);
                var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
                var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
                var mappings = util.getArg(sourceMap, "mappings");
                var file = util.getArg(sourceMap, "file", null);
                if (version != this._version) {
                    throw new Error("Unsupported version: " + version);
                }
                if (sourceRoot) {
                    sourceRoot = util.normalize(sourceRoot);
                }
                sources = sources.map(String).map(util.normalize).map(function(source) {
                    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
                });
                this._names = ArraySet.fromArray(names.map(String), true);
                this._sources = ArraySet.fromArray(sources, true);
                this._absoluteSources = this._sources.toArray().map(function(s) {
                    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
                });
                this.sourceRoot = sourceRoot;
                this.sourcesContent = sourcesContent;
                this._mappings = mappings;
                this._sourceMapURL = aSourceMapURL;
                this.file = file;
            }
            BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
            BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
            BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
                var relativeSource = aSource;
                if (this.sourceRoot != null) {
                    relativeSource = util.relative(this.sourceRoot, relativeSource);
                }
                if (this._sources.has(relativeSource)) {
                    return this._sources.indexOf(relativeSource);
                }
                var i;
                for(i = 0; i < this._absoluteSources.length; ++i){
                    if (this._absoluteSources[i] == aSource) {
                        return i;
                    }
                }
                return -1;
            };
            BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
                var smc = Object.create(BasicSourceMapConsumer.prototype);
                var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
                var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
                smc.sourceRoot = aSourceMap._sourceRoot;
                smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
                smc.file = aSourceMap._file;
                smc._sourceMapURL = aSourceMapURL;
                smc._absoluteSources = smc._sources.toArray().map(function(s) {
                    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
                });
                var generatedMappings = aSourceMap._mappings.toArray().slice();
                var destGeneratedMappings = smc.__generatedMappings = [];
                var destOriginalMappings = smc.__originalMappings = [];
                for(var i = 0, length = generatedMappings.length; i < length; i++){
                    var srcMapping = generatedMappings[i];
                    var destMapping = new Mapping();
                    destMapping.generatedLine = srcMapping.generatedLine;
                    destMapping.generatedColumn = srcMapping.generatedColumn;
                    if (srcMapping.source) {
                        destMapping.source = sources.indexOf(srcMapping.source);
                        destMapping.originalLine = srcMapping.originalLine;
                        destMapping.originalColumn = srcMapping.originalColumn;
                        if (srcMapping.name) {
                            destMapping.name = names.indexOf(srcMapping.name);
                        }
                        destOriginalMappings.push(destMapping);
                    }
                    destGeneratedMappings.push(destMapping);
                }
                quickSort(smc.__originalMappings, util.compareByOriginalPositions);
                return smc;
            };
            BasicSourceMapConsumer.prototype._version = 3;
            Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
                get: function get() {
                    return this._absoluteSources.slice();
                }
            });
            function Mapping() {
                this.generatedLine = 0;
                this.generatedColumn = 0;
                this.source = null;
                this.originalLine = null;
                this.originalColumn = null;
                this.name = null;
            }
            var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
            function sortGenerated(array, start) {
                var l = array.length;
                var n = array.length - start;
                if (n <= 1) {
                    return;
                } else if (n == 2) {
                    var a = array[start];
                    var b = array[start + 1];
                    if (compareGenerated(a, b) > 0) {
                        array[start] = b;
                        array[start + 1] = a;
                    }
                } else if (n < 20) {
                    for(var i = start; i < l; i++){
                        for(var j = i; j > start; j--){
                            var a1 = array[j - 1];
                            var b1 = array[j];
                            if (compareGenerated(a1, b1) <= 0) {
                                break;
                            }
                            array[j - 1] = b1;
                            array[j] = a1;
                        }
                    }
                } else {
                    quickSort(array, compareGenerated, start);
                }
            }
            BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
                var _instance;
                var generatedLine = 1;
                var previousGeneratedColumn = 0;
                var previousOriginalLine = 0;
                var previousOriginalColumn = 0;
                var previousSource = 0;
                var previousName = 0;
                var length = aStr.length;
                var index = 0;
                var cachedSegments = {};
                var temp = {};
                var originalMappings = [];
                var generatedMappings = [];
                var mapping, str, segment, end, value;
                var subarrayStart = 0;
                while(index < length){
                    if (aStr.charAt(index) === ";") {
                        generatedLine++;
                        index++;
                        previousGeneratedColumn = 0;
                        sortGenerated(generatedMappings, subarrayStart);
                        subarrayStart = generatedMappings.length;
                    } else if (aStr.charAt(index) === ",") {
                        index++;
                    } else {
                        mapping = new Mapping();
                        mapping.generatedLine = generatedLine;
                        for(end = index; end < length; end++){
                            if (this._charIsMappingSeparator(aStr, end)) {
                                break;
                            }
                        }
                        str = aStr.slice(index, end);
                        segment = [];
                        while(index < end){
                            base64VLQ.decode(aStr, index, temp);
                            value = temp.value;
                            index = temp.rest;
                            segment.push(value);
                        }
                        if (segment.length === 2) {
                            throw new Error("Found a source, but no line and column");
                        }
                        if (segment.length === 3) {
                            throw new Error("Found a source and line, but no column");
                        }
                        mapping.generatedColumn = previousGeneratedColumn + segment[0];
                        previousGeneratedColumn = mapping.generatedColumn;
                        if (segment.length > 1) {
                            mapping.source = previousSource + segment[1];
                            previousSource += segment[1];
                            mapping.originalLine = previousOriginalLine + segment[2];
                            previousOriginalLine = mapping.originalLine;
                            mapping.originalLine += 1;
                            mapping.originalColumn = previousOriginalColumn + segment[3];
                            previousOriginalColumn = mapping.originalColumn;
                            if (segment.length > 4) {
                                mapping.name = previousName + segment[4];
                                previousName += segment[4];
                            }
                        }
                        generatedMappings.push(mapping);
                        if (typeof mapping.originalLine === "number") {
                            var currentSource = mapping.source;
                            while(originalMappings.length <= currentSource){
                                originalMappings.push(null);
                            }
                            if (originalMappings[currentSource] === null) {
                                originalMappings[currentSource] = [];
                            }
                            originalMappings[currentSource].push(mapping);
                        }
                    }
                }
                sortGenerated(generatedMappings, subarrayStart);
                this.__generatedMappings = generatedMappings;
                for(var i = 0; i < originalMappings.length; i++){
                    if (originalMappings[i] != null) {
                        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
                    }
                }
                this.__originalMappings = (_instance = []).concat.apply(_instance, _to_consumable_array(originalMappings));
            };
            BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
                if (aNeedle[aLineName] <= 0) {
                    throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
                }
                if (aNeedle[aColumnName] < 0) {
                    throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
                }
                return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
            };
            BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
                for(var index = 0; index < this._generatedMappings.length; ++index){
                    var mapping = this._generatedMappings[index];
                    if (index + 1 < this._generatedMappings.length) {
                        var nextMapping = this._generatedMappings[index + 1];
                        if (mapping.generatedLine === nextMapping.generatedLine) {
                            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                            continue;
                        }
                    }
                    mapping.lastGeneratedColumn = Infinity;
                }
            };
            BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
                var needle = {
                    generatedLine: util.getArg(aArgs, "line"),
                    generatedColumn: util.getArg(aArgs, "column")
                };
                var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
                if (index >= 0) {
                    var mapping = this._generatedMappings[index];
                    if (mapping.generatedLine === needle.generatedLine) {
                        var source = util.getArg(mapping, "source", null);
                        if (source !== null) {
                            source = this._sources.at(source);
                            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
                        }
                        var name = util.getArg(mapping, "name", null);
                        if (name !== null) {
                            name = this._names.at(name);
                        }
                        return {
                            source: source,
                            line: util.getArg(mapping, "originalLine", null),
                            column: util.getArg(mapping, "originalColumn", null),
                            name: name
                        };
                    }
                }
                return {
                    source: null,
                    line: null,
                    column: null,
                    name: null
                };
            };
            BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
                if (!this.sourcesContent) {
                    return false;
                }
                return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
                    return sc == null;
                });
            };
            BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
                if (!this.sourcesContent) {
                    return null;
                }
                var index = this._findSourceIndex(aSource);
                if (index >= 0) {
                    return this.sourcesContent[index];
                }
                var relativeSource = aSource;
                if (this.sourceRoot != null) {
                    relativeSource = util.relative(this.sourceRoot, relativeSource);
                }
                var url;
                if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
                    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
                    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
                        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
                    }
                    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
                        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
                    }
                }
                if (nullOnMissing) {
                    return null;
                } else {
                    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
                }
            };
            BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
                var source = util.getArg(aArgs, "source");
                source = this._findSourceIndex(source);
                if (source < 0) {
                    return {
                        line: null,
                        column: null,
                        lastColumn: null
                    };
                }
                var needle = {
                    source: source,
                    originalLine: util.getArg(aArgs, "line"),
                    originalColumn: util.getArg(aArgs, "column")
                };
                var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
                if (index >= 0) {
                    var mapping = this._originalMappings[index];
                    if (mapping.source === needle.source) {
                        return {
                            line: util.getArg(mapping, "generatedLine", null),
                            column: util.getArg(mapping, "generatedColumn", null),
                            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
                        };
                    }
                }
                return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
            };
            exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
            function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
                var sourceMap = aSourceMap;
                if (typeof aSourceMap === "string") {
                    sourceMap = util.parseSourceMapInput(aSourceMap);
                }
                var version = util.getArg(sourceMap, "version");
                var sections = util.getArg(sourceMap, "sections");
                if (version != this._version) {
                    throw new Error("Unsupported version: " + version);
                }
                this._sources = new ArraySet();
                this._names = new ArraySet();
                var lastOffset = {
                    line: -1,
                    column: 0
                };
                this._sections = sections.map(function(s) {
                    if (s.url) {
                        throw new Error("Support for url field in sections not implemented.");
                    }
                    var offset = util.getArg(s, "offset");
                    var offsetLine = util.getArg(offset, "line");
                    var offsetColumn = util.getArg(offset, "column");
                    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
                        throw new Error("Section offsets must be ordered and non-overlapping.");
                    }
                    lastOffset = offset;
                    return {
                        generatedOffset: {
                            // The offset fields are 0-based, but we use 1-based indices when
                            // encoding/decoding from VLQ.
                            generatedLine: offsetLine + 1,
                            generatedColumn: offsetColumn + 1
                        },
                        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
                    };
                });
            }
            IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
            IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
            IndexedSourceMapConsumer.prototype._version = 3;
            Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
                get: function get() {
                    var sources = [];
                    for(var i = 0; i < this._sections.length; i++){
                        for(var j = 0; j < this._sections[i].consumer.sources.length; j++){
                            sources.push(this._sections[i].consumer.sources[j]);
                        }
                    }
                    return sources;
                }
            });
            IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
                var needle = {
                    generatedLine: util.getArg(aArgs, "line"),
                    generatedColumn: util.getArg(aArgs, "column")
                };
                var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
                    var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
                    if (cmp) {
                        return cmp;
                    }
                    return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
                });
                var section = this._sections[sectionIndex];
                if (!section) {
                    return {
                        source: null,
                        line: null,
                        column: null,
                        name: null
                    };
                }
                return section.consumer.originalPositionFor({
                    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
                    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                    bias: aArgs.bias
                });
            };
            IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
                return this._sections.every(function(s) {
                    return s.consumer.hasContentsOfAllSources();
                });
            };
            IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
                for(var i = 0; i < this._sections.length; i++){
                    var section = this._sections[i];
                    var content = section.consumer.sourceContentFor(aSource, true);
                    if (content || content === "") {
                        return content;
                    }
                }
                if (nullOnMissing) {
                    return null;
                } else {
                    throw new Error('"' + aSource + '" is not in the SourceMap.');
                }
            };
            IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
                for(var i = 0; i < this._sections.length; i++){
                    var section = this._sections[i];
                    if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
                        continue;
                    }
                    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
                    if (generatedPosition) {
                        var ret = {
                            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
                        };
                        return ret;
                    }
                }
                return {
                    line: null,
                    column: null
                };
            };
            IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
                this.__generatedMappings = [];
                this.__originalMappings = [];
                for(var i = 0; i < this._sections.length; i++){
                    var section = this._sections[i];
                    var sectionMappings = section.consumer._generatedMappings;
                    for(var j = 0; j < sectionMappings.length; j++){
                        var mapping = sectionMappings[j];
                        var source = section.consumer._sources.at(mapping.source);
                        if (source !== null) {
                            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
                        }
                        this._sources.add(source);
                        source = this._sources.indexOf(source);
                        var name = null;
                        if (mapping.name) {
                            name = section.consumer._names.at(mapping.name);
                            this._names.add(name);
                            name = this._names.indexOf(name);
                        }
                        var adjustedMapping = {
                            source: source,
                            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                            originalLine: mapping.originalLine,
                            originalColumn: mapping.originalColumn,
                            name: name
                        };
                        this.__generatedMappings.push(adjustedMapping);
                        if (typeof adjustedMapping.originalLine === "number") {
                            this.__originalMappings.push(adjustedMapping);
                        }
                    }
                }
                quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
                quickSort(this.__originalMappings, util.compareByOriginalPositions);
            };
            exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js
    var require_source_node = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/lib/source-node.js": function(exports) {
            "use strict";
            var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
            var util = require_util();
            var REGEX_NEWLINE = /(\r?\n)/;
            var NEWLINE_CODE = 10;
            var isSourceNode = "$$$isSourceNode$$$";
            function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
                this.children = [];
                this.sourceContents = {};
                this.line = aLine == null ? null : aLine;
                this.column = aColumn == null ? null : aColumn;
                this.source = aSource == null ? null : aSource;
                this.name = aName == null ? null : aName;
                this[isSourceNode] = true;
                if (aChunks != null) this.add(aChunks);
            }
            SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
                var node = new SourceNode();
                var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
                var remainingLinesIndex = 0;
                var shiftNextLine = function shiftNextLine() {
                    var lineContents = getNextLine();
                    var newLine = getNextLine() || "";
                    return lineContents + newLine;
                    function getNextLine() {
                        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
                    }
                };
                var lastGeneratedLine = 1, lastGeneratedColumn = 0;
                var lastMapping = null;
                aSourceMapConsumer.eachMapping(function(mapping) {
                    if (lastMapping !== null) {
                        if (lastGeneratedLine < mapping.generatedLine) {
                            addMappingWithCode(lastMapping, shiftNextLine());
                            lastGeneratedLine++;
                            lastGeneratedColumn = 0;
                        } else {
                            var nextLine = remainingLines[remainingLinesIndex] || "";
                            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                            lastGeneratedColumn = mapping.generatedColumn;
                            addMappingWithCode(lastMapping, code);
                            lastMapping = mapping;
                            return;
                        }
                    }
                    while(lastGeneratedLine < mapping.generatedLine){
                        node.add(shiftNextLine());
                        lastGeneratedLine++;
                    }
                    if (lastGeneratedColumn < mapping.generatedColumn) {
                        var nextLine = remainingLines[remainingLinesIndex] || "";
                        node.add(nextLine.substr(0, mapping.generatedColumn));
                        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
                        lastGeneratedColumn = mapping.generatedColumn;
                    }
                    lastMapping = mapping;
                }, this);
                if (remainingLinesIndex < remainingLines.length) {
                    if (lastMapping) {
                        addMappingWithCode(lastMapping, shiftNextLine());
                    }
                    node.add(remainingLines.splice(remainingLinesIndex).join(""));
                }
                aSourceMapConsumer.sources.forEach(function(sourceFile) {
                    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                    if (content != null) {
                        if (aRelativePath != null) {
                            sourceFile = util.join(aRelativePath, sourceFile);
                        }
                        node.setSourceContent(sourceFile, content);
                    }
                });
                return node;
                function addMappingWithCode(mapping, code) {
                    if (mapping === null || mapping.source === void 0) {
                        node.add(code);
                    } else {
                        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
                        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
                    }
                }
            };
            SourceNode.prototype.add = function SourceNode_add(aChunk) {
                if (Array.isArray(aChunk)) {
                    aChunk.forEach(function(chunk) {
                        this.add(chunk);
                    }, this);
                } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                    if (aChunk) {
                        this.children.push(aChunk);
                    }
                } else {
                    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
                }
                return this;
            };
            SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
                if (Array.isArray(aChunk)) {
                    for(var i = aChunk.length - 1; i >= 0; i--){
                        this.prepend(aChunk[i]);
                    }
                } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                    this.children.unshift(aChunk);
                } else {
                    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
                }
                return this;
            };
            SourceNode.prototype.walk = function SourceNode_walk(aFn) {
                var chunk;
                for(var i = 0, len = this.children.length; i < len; i++){
                    chunk = this.children[i];
                    if (chunk[isSourceNode]) {
                        chunk.walk(aFn);
                    } else {
                        if (chunk !== "") {
                            aFn(chunk, {
                                source: this.source,
                                line: this.line,
                                column: this.column,
                                name: this.name
                            });
                        }
                    }
                }
            };
            SourceNode.prototype.join = function SourceNode_join(aSep) {
                var newChildren;
                var i;
                var len = this.children.length;
                if (len > 0) {
                    newChildren = [];
                    for(i = 0; i < len - 1; i++){
                        newChildren.push(this.children[i]);
                        newChildren.push(aSep);
                    }
                    newChildren.push(this.children[i]);
                    this.children = newChildren;
                }
                return this;
            };
            SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
                var lastChild = this.children[this.children.length - 1];
                if (lastChild[isSourceNode]) {
                    lastChild.replaceRight(aPattern, aReplacement);
                } else if (typeof lastChild === "string") {
                    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
                } else {
                    this.children.push("".replace(aPattern, aReplacement));
                }
                return this;
            };
            SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
                this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
            };
            SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
                for(var i = 0, len = this.children.length; i < len; i++){
                    if (this.children[i][isSourceNode]) {
                        this.children[i].walkSourceContents(aFn);
                    }
                }
                var sources = Object.keys(this.sourceContents);
                for(var i = 0, len = sources.length; i < len; i++){
                    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
                }
            };
            SourceNode.prototype.toString = function SourceNode_toString() {
                var str = "";
                this.walk(function(chunk) {
                    str += chunk;
                });
                return str;
            };
            SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
                var generated = {
                    code: "",
                    line: 1,
                    column: 0
                };
                var map = new SourceMapGenerator(aArgs);
                var sourceMappingActive = false;
                var lastOriginalSource = null;
                var lastOriginalLine = null;
                var lastOriginalColumn = null;
                var lastOriginalName = null;
                this.walk(function(chunk, original) {
                    generated.code += chunk;
                    if (original.source !== null && original.line !== null && original.column !== null) {
                        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                            map.addMapping({
                                source: original.source,
                                original: {
                                    line: original.line,
                                    column: original.column
                                },
                                generated: {
                                    line: generated.line,
                                    column: generated.column
                                },
                                name: original.name
                            });
                        }
                        lastOriginalSource = original.source;
                        lastOriginalLine = original.line;
                        lastOriginalColumn = original.column;
                        lastOriginalName = original.name;
                        sourceMappingActive = true;
                    } else if (sourceMappingActive) {
                        map.addMapping({
                            generated: {
                                line: generated.line,
                                column: generated.column
                            }
                        });
                        lastOriginalSource = null;
                        sourceMappingActive = false;
                    }
                    for(var idx = 0, length = chunk.length; idx < length; idx++){
                        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                            generated.line++;
                            generated.column = 0;
                            if (idx + 1 === length) {
                                lastOriginalSource = null;
                                sourceMappingActive = false;
                            } else if (sourceMappingActive) {
                                map.addMapping({
                                    source: original.source,
                                    original: {
                                        line: original.line,
                                        column: original.column
                                    },
                                    generated: {
                                        line: generated.line,
                                        column: generated.column
                                    },
                                    name: original.name
                                });
                            }
                        } else {
                            generated.column++;
                        }
                    }
                });
                this.walkSourceContents(function(sourceFile, sourceContent) {
                    map.setSourceContent(sourceFile, sourceContent);
                });
                return {
                    code: generated.code,
                    map: map
                };
            };
            exports.SourceNode = SourceNode;
        }
    });
    // ../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js
    var require_source_map = __commonJS({
        "../../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js": function(exports) {
            "use strict";
            exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
            exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
            exports.SourceNode = require_source_node().SourceNode;
        }
    });
    // ../../node_modules/.pnpm/@vue+compiler-core@3.5.13/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js
    var require_compiler_core_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+compiler-core@3.5.13/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var shared = require_shared();
            var decode_js = require_decode();
            var parser = require_lib();
            var estreeWalker = require_estree_walker();
            var sourceMapJs = require_source_map();
            var FRAGMENT = Symbol("Fragment");
            var TELEPORT = Symbol("Teleport");
            var SUSPENSE = Symbol("Suspense");
            var KEEP_ALIVE = Symbol("KeepAlive");
            var BASE_TRANSITION = Symbol("BaseTransition");
            var OPEN_BLOCK = Symbol("openBlock");
            var CREATE_BLOCK = Symbol("createBlock");
            var CREATE_ELEMENT_BLOCK = Symbol("createElementBlock");
            var CREATE_VNODE = Symbol("createVNode");
            var CREATE_ELEMENT_VNODE = Symbol("createElementVNode");
            var CREATE_COMMENT = Symbol("createCommentVNode");
            var CREATE_TEXT = Symbol("createTextVNode");
            var CREATE_STATIC = Symbol("createStaticVNode");
            var RESOLVE_COMPONENT = Symbol("resolveComponent");
            var RESOLVE_DYNAMIC_COMPONENT = Symbol("resolveDynamicComponent");
            var RESOLVE_DIRECTIVE = Symbol("resolveDirective");
            var RESOLVE_FILTER = Symbol("resolveFilter");
            var WITH_DIRECTIVES = Symbol("withDirectives");
            var RENDER_LIST = Symbol("renderList");
            var RENDER_SLOT = Symbol("renderSlot");
            var CREATE_SLOTS = Symbol("createSlots");
            var TO_DISPLAY_STRING = Symbol("toDisplayString");
            var MERGE_PROPS = Symbol("mergeProps");
            var NORMALIZE_CLASS = Symbol("normalizeClass");
            var NORMALIZE_STYLE = Symbol("normalizeStyle");
            var NORMALIZE_PROPS = Symbol("normalizeProps");
            var GUARD_REACTIVE_PROPS = Symbol("guardReactiveProps");
            var TO_HANDLERS = Symbol("toHandlers");
            var CAMELIZE = Symbol("camelize");
            var CAPITALIZE = Symbol("capitalize");
            var TO_HANDLER_KEY = Symbol("toHandlerKey");
            var SET_BLOCK_TRACKING = Symbol("setBlockTracking");
            var PUSH_SCOPE_ID = Symbol("pushScopeId");
            var POP_SCOPE_ID = Symbol("popScopeId");
            var WITH_CTX = Symbol("withCtx");
            var UNREF = Symbol("unref");
            var IS_REF = Symbol("isRef");
            var WITH_MEMO = Symbol("withMemo");
            var IS_MEMO_SAME = Symbol("isMemoSame");
            var _obj;
            var helperNameMap = (_obj = {}, _define_property(_obj, FRAGMENT, "Fragment"), _define_property(_obj, TELEPORT, "Teleport"), _define_property(_obj, SUSPENSE, "Suspense"), _define_property(_obj, KEEP_ALIVE, "KeepAlive"), _define_property(_obj, BASE_TRANSITION, "BaseTransition"), _define_property(_obj, OPEN_BLOCK, "openBlock"), _define_property(_obj, CREATE_BLOCK, "createBlock"), _define_property(_obj, CREATE_ELEMENT_BLOCK, "createElementBlock"), _define_property(_obj, CREATE_VNODE, "createVNode"), _define_property(_obj, CREATE_ELEMENT_VNODE, "createElementVNode"), _define_property(_obj, CREATE_COMMENT, "createCommentVNode"), _define_property(_obj, CREATE_TEXT, "createTextVNode"), _define_property(_obj, CREATE_STATIC, "createStaticVNode"), _define_property(_obj, RESOLVE_COMPONENT, "resolveComponent"), _define_property(_obj, RESOLVE_DYNAMIC_COMPONENT, "resolveDynamicComponent"), _define_property(_obj, RESOLVE_DIRECTIVE, "resolveDirective"), _define_property(_obj, RESOLVE_FILTER, "resolveFilter"), _define_property(_obj, WITH_DIRECTIVES, "withDirectives"), _define_property(_obj, RENDER_LIST, "renderList"), _define_property(_obj, RENDER_SLOT, "renderSlot"), _define_property(_obj, CREATE_SLOTS, "createSlots"), _define_property(_obj, TO_DISPLAY_STRING, "toDisplayString"), _define_property(_obj, MERGE_PROPS, "mergeProps"), _define_property(_obj, NORMALIZE_CLASS, "normalizeClass"), _define_property(_obj, NORMALIZE_STYLE, "normalizeStyle"), _define_property(_obj, NORMALIZE_PROPS, "normalizeProps"), _define_property(_obj, GUARD_REACTIVE_PROPS, "guardReactiveProps"), _define_property(_obj, TO_HANDLERS, "toHandlers"), _define_property(_obj, CAMELIZE, "camelize"), _define_property(_obj, CAPITALIZE, "capitalize"), _define_property(_obj, TO_HANDLER_KEY, "toHandlerKey"), _define_property(_obj, SET_BLOCK_TRACKING, "setBlockTracking"), _define_property(_obj, PUSH_SCOPE_ID, "pushScopeId"), _define_property(_obj, POP_SCOPE_ID, "popScopeId"), _define_property(_obj, WITH_CTX, "withCtx"), _define_property(_obj, UNREF, "unref"), _define_property(_obj, IS_REF, "isRef"), _define_property(_obj, WITH_MEMO, "withMemo"), _define_property(_obj, IS_MEMO_SAME, "isMemoSame"), _obj);
            function registerRuntimeHelpers(helpers) {
                Object.getOwnPropertySymbols(helpers).forEach(function(s) {
                    helperNameMap[s] = helpers[s];
                });
            }
            var Namespaces = {
                "HTML": 0,
                "0": "HTML",
                "SVG": 1,
                "1": "SVG",
                "MATH_ML": 2,
                "2": "MATH_ML"
            };
            var NodeTypes = {
                "ROOT": 0,
                "0": "ROOT",
                "ELEMENT": 1,
                "1": "ELEMENT",
                "TEXT": 2,
                "2": "TEXT",
                "COMMENT": 3,
                "3": "COMMENT",
                "SIMPLE_EXPRESSION": 4,
                "4": "SIMPLE_EXPRESSION",
                "INTERPOLATION": 5,
                "5": "INTERPOLATION",
                "ATTRIBUTE": 6,
                "6": "ATTRIBUTE",
                "DIRECTIVE": 7,
                "7": "DIRECTIVE",
                "COMPOUND_EXPRESSION": 8,
                "8": "COMPOUND_EXPRESSION",
                "IF": 9,
                "9": "IF",
                "IF_BRANCH": 10,
                "10": "IF_BRANCH",
                "FOR": 11,
                "11": "FOR",
                "TEXT_CALL": 12,
                "12": "TEXT_CALL",
                "VNODE_CALL": 13,
                "13": "VNODE_CALL",
                "JS_CALL_EXPRESSION": 14,
                "14": "JS_CALL_EXPRESSION",
                "JS_OBJECT_EXPRESSION": 15,
                "15": "JS_OBJECT_EXPRESSION",
                "JS_PROPERTY": 16,
                "16": "JS_PROPERTY",
                "JS_ARRAY_EXPRESSION": 17,
                "17": "JS_ARRAY_EXPRESSION",
                "JS_FUNCTION_EXPRESSION": 18,
                "18": "JS_FUNCTION_EXPRESSION",
                "JS_CONDITIONAL_EXPRESSION": 19,
                "19": "JS_CONDITIONAL_EXPRESSION",
                "JS_CACHE_EXPRESSION": 20,
                "20": "JS_CACHE_EXPRESSION",
                "JS_BLOCK_STATEMENT": 21,
                "21": "JS_BLOCK_STATEMENT",
                "JS_TEMPLATE_LITERAL": 22,
                "22": "JS_TEMPLATE_LITERAL",
                "JS_IF_STATEMENT": 23,
                "23": "JS_IF_STATEMENT",
                "JS_ASSIGNMENT_EXPRESSION": 24,
                "24": "JS_ASSIGNMENT_EXPRESSION",
                "JS_SEQUENCE_EXPRESSION": 25,
                "25": "JS_SEQUENCE_EXPRESSION",
                "JS_RETURN_STATEMENT": 26,
                "26": "JS_RETURN_STATEMENT"
            };
            var ElementTypes = {
                "ELEMENT": 0,
                "0": "ELEMENT",
                "COMPONENT": 1,
                "1": "COMPONENT",
                "SLOT": 2,
                "2": "SLOT",
                "TEMPLATE": 3,
                "3": "TEMPLATE"
            };
            var ConstantTypes = {
                "NOT_CONSTANT": 0,
                "0": "NOT_CONSTANT",
                "CAN_SKIP_PATCH": 1,
                "1": "CAN_SKIP_PATCH",
                "CAN_CACHE": 2,
                "2": "CAN_CACHE",
                "CAN_STRINGIFY": 3,
                "3": "CAN_STRINGIFY"
            };
            var locStub = {
                start: {
                    line: 1,
                    column: 1,
                    offset: 0
                },
                end: {
                    line: 1,
                    column: 1,
                    offset: 0
                },
                source: ""
            };
            function createRoot(children) {
                var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
                return {
                    type: 0,
                    source: source,
                    children: children,
                    helpers: /* @__PURE__ */ new Set(),
                    components: [],
                    directives: [],
                    hoists: [],
                    imports: [],
                    cached: [],
                    temps: 0,
                    codegenNode: void 0,
                    loc: locStub
                };
            }
            function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives) {
                var isBlock = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false, disableTracking = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false, isComponent2 = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : false, loc = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : locStub;
                if (context) {
                    if (isBlock) {
                        context.helper(OPEN_BLOCK);
                        context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
                    } else {
                        context.helper(getVNodeHelper(context.inSSR, isComponent2));
                    }
                    if (directives) {
                        context.helper(WITH_DIRECTIVES);
                    }
                }
                return {
                    type: 13,
                    tag: tag,
                    props: props,
                    children: children,
                    patchFlag: patchFlag,
                    dynamicProps: dynamicProps,
                    directives: directives,
                    isBlock: isBlock,
                    disableTracking: disableTracking,
                    isComponent: isComponent2,
                    loc: loc
                };
            }
            function createArrayExpression(elements) {
                var loc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : locStub;
                return {
                    type: 17,
                    loc: loc,
                    elements: elements
                };
            }
            function createObjectExpression(properties) {
                var loc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : locStub;
                return {
                    type: 15,
                    loc: loc,
                    properties: properties
                };
            }
            function createObjectProperty(key, value) {
                return {
                    type: 16,
                    loc: locStub,
                    key: shared.isString(key) ? createSimpleExpression(key, true) : key,
                    value: value
                };
            }
            function createSimpleExpression(content) {
                var isStatic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, loc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : locStub, constType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                return {
                    type: 4,
                    loc: loc,
                    content: content,
                    isStatic: isStatic,
                    constType: isStatic ? 3 : constType
                };
            }
            function createInterpolation(content, loc) {
                return {
                    type: 5,
                    loc: loc,
                    content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
                };
            }
            function createCompoundExpression(children) {
                var loc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : locStub;
                return {
                    type: 8,
                    loc: loc,
                    children: children
                };
            }
            function createCallExpression(callee) {
                var args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], loc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : locStub;
                return {
                    type: 14,
                    loc: loc,
                    callee: callee,
                    arguments: args
                };
            }
            function createFunctionExpression(params) {
                var returns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, newline = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, isSlot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, loc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : locStub;
                return {
                    type: 18,
                    params: params,
                    returns: returns,
                    newline: newline,
                    isSlot: isSlot,
                    loc: loc
                };
            }
            function createConditionalExpression(test, consequent, alternate) {
                var newline = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                return {
                    type: 19,
                    test: test,
                    consequent: consequent,
                    alternate: alternate,
                    newline: newline,
                    loc: locStub
                };
            }
            function createCacheExpression(index, value) {
                var needPauseTracking = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, inVOnce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                return {
                    type: 20,
                    index: index,
                    value: value,
                    needPauseTracking: needPauseTracking,
                    inVOnce: inVOnce,
                    needArraySpread: false,
                    loc: locStub
                };
            }
            function createBlockStatement(body) {
                return {
                    type: 21,
                    body: body,
                    loc: locStub
                };
            }
            function createTemplateLiteral(elements) {
                return {
                    type: 22,
                    elements: elements,
                    loc: locStub
                };
            }
            function createIfStatement(test, consequent, alternate) {
                return {
                    type: 23,
                    test: test,
                    consequent: consequent,
                    alternate: alternate,
                    loc: locStub
                };
            }
            function createAssignmentExpression(left, right) {
                return {
                    type: 24,
                    left: left,
                    right: right,
                    loc: locStub
                };
            }
            function createSequenceExpression(expressions) {
                return {
                    type: 25,
                    expressions: expressions,
                    loc: locStub
                };
            }
            function createReturnStatement(returns) {
                return {
                    type: 26,
                    returns: returns,
                    loc: locStub
                };
            }
            function getVNodeHelper(ssr, isComponent2) {
                return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
            }
            function getVNodeBlockHelper(ssr, isComponent2) {
                return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
            }
            function convertToBlock(node, param) {
                var helper = param.helper, removeHelper = param.removeHelper, inSSR = param.inSSR;
                if (!node.isBlock) {
                    node.isBlock = true;
                    removeHelper(getVNodeHelper(inSSR, node.isComponent));
                    helper(OPEN_BLOCK);
                    helper(getVNodeBlockHelper(inSSR, node.isComponent));
                }
            }
            var defaultDelimitersOpen = new Uint8Array([
                123,
                123
            ]);
            var defaultDelimitersClose = new Uint8Array([
                125,
                125
            ]);
            function isTagStartChar(c) {
                return c >= 97 && c <= 122 || c >= 65 && c <= 90;
            }
            function isWhitespace(c) {
                return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
            }
            function isEndOfTagSection(c) {
                return c === 47 || c === 62 || isWhitespace(c);
            }
            function toCharCodes(str) {
                var ret = new Uint8Array(str.length);
                for(var i = 0; i < str.length; i++){
                    ret[i] = str.charCodeAt(i);
                }
                return ret;
            }
            var Sequences = {
                Cdata: new Uint8Array([
                    67,
                    68,
                    65,
                    84,
                    65,
                    91
                ]),
                // CDATA[
                CdataEnd: new Uint8Array([
                    93,
                    93,
                    62
                ]),
                // ]]>
                CommentEnd: new Uint8Array([
                    45,
                    45,
                    62
                ]),
                // `-->`
                ScriptEnd: new Uint8Array([
                    60,
                    47,
                    115,
                    99,
                    114,
                    105,
                    112,
                    116
                ]),
                // `<\/script`
                StyleEnd: new Uint8Array([
                    60,
                    47,
                    115,
                    116,
                    121,
                    108,
                    101
                ]),
                // `</style`
                TitleEnd: new Uint8Array([
                    60,
                    47,
                    116,
                    105,
                    116,
                    108,
                    101
                ]),
                // `</title`
                TextareaEnd: new Uint8Array([
                    60,
                    47,
                    116,
                    101,
                    120,
                    116,
                    97,
                    114,
                    101,
                    97
                ])
            };
            var Tokenizer = /*#__PURE__*/ function() {
                function Tokenizer(stack2, cbs) {
                    var _this = this;
                    _class_call_check(this, Tokenizer);
                    this.stack = stack2;
                    this.cbs = cbs;
                    this.state = 1;
                    this.buffer = "";
                    this.sectionStart = 0;
                    this.index = 0;
                    this.entityStart = 0;
                    this.baseState = 1;
                    this.inRCDATA = false;
                    this.inXML = false;
                    this.inVPre = false;
                    this.newlines = [];
                    this.mode = 0;
                    this.delimiterOpen = defaultDelimitersOpen;
                    this.delimiterClose = defaultDelimitersClose;
                    this.delimiterIndex = -1;
                    this.currentSequence = void 0;
                    this.sequenceIndex = 0;
                    {
                        this.entityDecoder = new decode_js.EntityDecoder(decode_js.htmlDecodeTree, function(cp, consumed) {
                            return _this.emitCodePoint(cp, consumed);
                        });
                    }
                }
                _create_class(Tokenizer, [
                    {
                        key: "inSFCRoot",
                        get: function get() {
                            return this.mode === 2 && this.stack.length === 0;
                        }
                    },
                    {
                        key: "reset",
                        value: function reset() {
                            this.state = 1;
                            this.mode = 0;
                            this.buffer = "";
                            this.sectionStart = 0;
                            this.index = 0;
                            this.baseState = 1;
                            this.inRCDATA = false;
                            this.currentSequence = void 0;
                            this.newlines.length = 0;
                            this.delimiterOpen = defaultDelimitersOpen;
                            this.delimiterClose = defaultDelimitersClose;
                        }
                    },
                    {
                        /**
         * Generate Position object with line / column information using recorded
         * newline positions. We know the index is always going to be an already
         * processed index, so all the newlines up to this index should have been
         * recorded.
         */ key: "getPos",
                        value: function getPos(index) {
                            var line = 1;
                            var column = index + 1;
                            for(var i = this.newlines.length - 1; i >= 0; i--){
                                var newlineIndex = this.newlines[i];
                                if (index > newlineIndex) {
                                    line = i + 2;
                                    column = index - newlineIndex;
                                    break;
                                }
                            }
                            return {
                                column: column,
                                line: line,
                                offset: index
                            };
                        }
                    },
                    {
                        key: "peek",
                        value: function peek() {
                            return this.buffer.charCodeAt(this.index + 1);
                        }
                    },
                    {
                        key: "stateText",
                        value: function stateText(c) {
                            if (c === 60) {
                                if (this.index > this.sectionStart) {
                                    this.cbs.ontext(this.sectionStart, this.index);
                                }
                                this.state = 5;
                                this.sectionStart = this.index;
                            } else if (c === 38) {
                                this.startEntity();
                            } else if (!this.inVPre && c === this.delimiterOpen[0]) {
                                this.state = 2;
                                this.delimiterIndex = 0;
                                this.stateInterpolationOpen(c);
                            }
                        }
                    },
                    {
                        key: "stateInterpolationOpen",
                        value: function stateInterpolationOpen(c) {
                            if (c === this.delimiterOpen[this.delimiterIndex]) {
                                if (this.delimiterIndex === this.delimiterOpen.length - 1) {
                                    var start = this.index + 1 - this.delimiterOpen.length;
                                    if (start > this.sectionStart) {
                                        this.cbs.ontext(this.sectionStart, start);
                                    }
                                    this.state = 3;
                                    this.sectionStart = start;
                                } else {
                                    this.delimiterIndex++;
                                }
                            } else if (this.inRCDATA) {
                                this.state = 32;
                                this.stateInRCDATA(c);
                            } else {
                                this.state = 1;
                                this.stateText(c);
                            }
                        }
                    },
                    {
                        key: "stateInterpolation",
                        value: function stateInterpolation(c) {
                            if (c === this.delimiterClose[0]) {
                                this.state = 4;
                                this.delimiterIndex = 0;
                                this.stateInterpolationClose(c);
                            }
                        }
                    },
                    {
                        key: "stateInterpolationClose",
                        value: function stateInterpolationClose(c) {
                            if (c === this.delimiterClose[this.delimiterIndex]) {
                                if (this.delimiterIndex === this.delimiterClose.length - 1) {
                                    this.cbs.oninterpolation(this.sectionStart, this.index + 1);
                                    if (this.inRCDATA) {
                                        this.state = 32;
                                    } else {
                                        this.state = 1;
                                    }
                                    this.sectionStart = this.index + 1;
                                } else {
                                    this.delimiterIndex++;
                                }
                            } else {
                                this.state = 3;
                                this.stateInterpolation(c);
                            }
                        }
                    },
                    {
                        key: "stateSpecialStartSequence",
                        value: function stateSpecialStartSequence(c) {
                            var isEnd = this.sequenceIndex === this.currentSequence.length;
                            var isMatch = isEnd ? // If we are at the end of the sequence, make sure the tag name has ended
                            isEndOfTagSection(c) : // Otherwise, do a case-insensitive comparison
                            (c | 32) === this.currentSequence[this.sequenceIndex];
                            if (!isMatch) {
                                this.inRCDATA = false;
                            } else if (!isEnd) {
                                this.sequenceIndex++;
                                return;
                            }
                            this.sequenceIndex = 0;
                            this.state = 6;
                            this.stateInTagName(c);
                        }
                    },
                    {
                        /** Look for an end tag. For <title> and <textarea>, also decode entities. */ key: "stateInRCDATA",
                        value: function stateInRCDATA(c) {
                            if (this.sequenceIndex === this.currentSequence.length) {
                                if (c === 62 || isWhitespace(c)) {
                                    var endOfText = this.index - this.currentSequence.length;
                                    if (this.sectionStart < endOfText) {
                                        var actualIndex = this.index;
                                        this.index = endOfText;
                                        this.cbs.ontext(this.sectionStart, endOfText);
                                        this.index = actualIndex;
                                    }
                                    this.sectionStart = endOfText + 2;
                                    this.stateInClosingTagName(c);
                                    this.inRCDATA = false;
                                    return;
                                }
                                this.sequenceIndex = 0;
                            }
                            if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
                                this.sequenceIndex += 1;
                            } else if (this.sequenceIndex === 0) {
                                if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
                                    if (c === 38) {
                                        this.startEntity();
                                    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
                                        this.state = 2;
                                        this.delimiterIndex = 0;
                                        this.stateInterpolationOpen(c);
                                    }
                                } else if (this.fastForwardTo(60)) {
                                    this.sequenceIndex = 1;
                                }
                            } else {
                                this.sequenceIndex = Number(c === 60);
                            }
                        }
                    },
                    {
                        key: "stateCDATASequence",
                        value: function stateCDATASequence(c) {
                            if (c === Sequences.Cdata[this.sequenceIndex]) {
                                if (++this.sequenceIndex === Sequences.Cdata.length) {
                                    this.state = 28;
                                    this.currentSequence = Sequences.CdataEnd;
                                    this.sequenceIndex = 0;
                                    this.sectionStart = this.index + 1;
                                }
                            } else {
                                this.sequenceIndex = 0;
                                this.state = 23;
                                this.stateInDeclaration(c);
                            }
                        }
                    },
                    {
                        /**
         * When we wait for one specific character, we can speed things up
         * by skipping through the buffer until we find it.
         *
         * @returns Whether the character was found.
         */ key: "fastForwardTo",
                        value: function fastForwardTo(c) {
                            while(++this.index < this.buffer.length){
                                var cc = this.buffer.charCodeAt(this.index);
                                if (cc === 10) {
                                    this.newlines.push(this.index);
                                }
                                if (cc === c) {
                                    return true;
                                }
                            }
                            this.index = this.buffer.length - 1;
                            return false;
                        }
                    },
                    {
                        /**
         * Comments and CDATA end with `-->` and `]]>`.
         *
         * Their common qualities are:
         * - Their end sequences have a distinct character they start with.
         * - That character is then repeated, so we have to check multiple repeats.
         * - All characters but the start character of the sequence can be skipped.
         */ key: "stateInCommentLike",
                        value: function stateInCommentLike(c) {
                            if (c === this.currentSequence[this.sequenceIndex]) {
                                if (++this.sequenceIndex === this.currentSequence.length) {
                                    if (this.currentSequence === Sequences.CdataEnd) {
                                        this.cbs.oncdata(this.sectionStart, this.index - 2);
                                    } else {
                                        this.cbs.oncomment(this.sectionStart, this.index - 2);
                                    }
                                    this.sequenceIndex = 0;
                                    this.sectionStart = this.index + 1;
                                    this.state = 1;
                                }
                            } else if (this.sequenceIndex === 0) {
                                if (this.fastForwardTo(this.currentSequence[0])) {
                                    this.sequenceIndex = 1;
                                }
                            } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
                                this.sequenceIndex = 0;
                            }
                        }
                    },
                    {
                        key: "startSpecial",
                        value: function startSpecial(sequence, offset) {
                            this.enterRCDATA(sequence, offset);
                            this.state = 31;
                        }
                    },
                    {
                        key: "enterRCDATA",
                        value: function enterRCDATA(sequence, offset) {
                            this.inRCDATA = true;
                            this.currentSequence = sequence;
                            this.sequenceIndex = offset;
                        }
                    },
                    {
                        key: "stateBeforeTagName",
                        value: function stateBeforeTagName(c) {
                            if (c === 33) {
                                this.state = 22;
                                this.sectionStart = this.index + 1;
                            } else if (c === 63) {
                                this.state = 24;
                                this.sectionStart = this.index + 1;
                            } else if (isTagStartChar(c)) {
                                this.sectionStart = this.index;
                                if (this.mode === 0) {
                                    this.state = 6;
                                } else if (this.inSFCRoot) {
                                    this.state = 34;
                                } else if (!this.inXML) {
                                    if (c === 116) {
                                        this.state = 30;
                                    } else {
                                        this.state = c === 115 ? 29 : 6;
                                    }
                                } else {
                                    this.state = 6;
                                }
                            } else if (c === 47) {
                                this.state = 8;
                            } else {
                                this.state = 1;
                                this.stateText(c);
                            }
                        }
                    },
                    {
                        key: "stateInTagName",
                        value: function stateInTagName(c) {
                            if (isEndOfTagSection(c)) {
                                this.handleTagName(c);
                            }
                        }
                    },
                    {
                        key: "stateInSFCRootTagName",
                        value: function stateInSFCRootTagName(c) {
                            if (isEndOfTagSection(c)) {
                                var tag = this.buffer.slice(this.sectionStart, this.index);
                                if (tag !== "template") {
                                    this.enterRCDATA(toCharCodes("</" + tag), 0);
                                }
                                this.handleTagName(c);
                            }
                        }
                    },
                    {
                        key: "handleTagName",
                        value: function handleTagName(c) {
                            this.cbs.onopentagname(this.sectionStart, this.index);
                            this.sectionStart = -1;
                            this.state = 11;
                            this.stateBeforeAttrName(c);
                        }
                    },
                    {
                        key: "stateBeforeClosingTagName",
                        value: function stateBeforeClosingTagName(c) {
                            if (isWhitespace(c)) ;
                            else if (c === 62) {
                                {
                                    this.cbs.onerr(14, this.index);
                                }
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                            } else {
                                this.state = isTagStartChar(c) ? 9 : 27;
                                this.sectionStart = this.index;
                            }
                        }
                    },
                    {
                        key: "stateInClosingTagName",
                        value: function stateInClosingTagName(c) {
                            if (c === 62 || isWhitespace(c)) {
                                this.cbs.onclosetag(this.sectionStart, this.index);
                                this.sectionStart = -1;
                                this.state = 10;
                                this.stateAfterClosingTagName(c);
                            }
                        }
                    },
                    {
                        key: "stateAfterClosingTagName",
                        value: function stateAfterClosingTagName(c) {
                            if (c === 62) {
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateBeforeAttrName",
                        value: function stateBeforeAttrName(c) {
                            if (c === 62) {
                                this.cbs.onopentagend(this.index);
                                if (this.inRCDATA) {
                                    this.state = 32;
                                } else {
                                    this.state = 1;
                                }
                                this.sectionStart = this.index + 1;
                            } else if (c === 47) {
                                this.state = 7;
                                if (this.peek() !== 62) {
                                    this.cbs.onerr(22, this.index);
                                }
                            } else if (c === 60 && this.peek() === 47) {
                                this.cbs.onopentagend(this.index);
                                this.state = 5;
                                this.sectionStart = this.index;
                            } else if (!isWhitespace(c)) {
                                if (c === 61) {
                                    this.cbs.onerr(19, this.index);
                                }
                                this.handleAttrStart(c);
                            }
                        }
                    },
                    {
                        key: "handleAttrStart",
                        value: function handleAttrStart(c) {
                            if (c === 118 && this.peek() === 45) {
                                this.state = 13;
                                this.sectionStart = this.index;
                            } else if (c === 46 || c === 58 || c === 64 || c === 35) {
                                this.cbs.ondirname(this.index, this.index + 1);
                                this.state = 14;
                                this.sectionStart = this.index + 1;
                            } else {
                                this.state = 12;
                                this.sectionStart = this.index;
                            }
                        }
                    },
                    {
                        key: "stateInSelfClosingTag",
                        value: function stateInSelfClosingTag(c) {
                            if (c === 62) {
                                this.cbs.onselfclosingtag(this.index);
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                                this.inRCDATA = false;
                            } else if (!isWhitespace(c)) {
                                this.state = 11;
                                this.stateBeforeAttrName(c);
                            }
                        }
                    },
                    {
                        key: "stateInAttrName",
                        value: function stateInAttrName(c) {
                            if (c === 61 || isEndOfTagSection(c)) {
                                this.cbs.onattribname(this.sectionStart, this.index);
                                this.handleAttrNameEnd(c);
                            } else if (c === 34 || c === 39 || c === 60) {
                                this.cbs.onerr(17, this.index);
                            }
                        }
                    },
                    {
                        key: "stateInDirName",
                        value: function stateInDirName(c) {
                            if (c === 61 || isEndOfTagSection(c)) {
                                this.cbs.ondirname(this.sectionStart, this.index);
                                this.handleAttrNameEnd(c);
                            } else if (c === 58) {
                                this.cbs.ondirname(this.sectionStart, this.index);
                                this.state = 14;
                                this.sectionStart = this.index + 1;
                            } else if (c === 46) {
                                this.cbs.ondirname(this.sectionStart, this.index);
                                this.state = 16;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateInDirArg",
                        value: function stateInDirArg(c) {
                            if (c === 61 || isEndOfTagSection(c)) {
                                this.cbs.ondirarg(this.sectionStart, this.index);
                                this.handleAttrNameEnd(c);
                            } else if (c === 91) {
                                this.state = 15;
                            } else if (c === 46) {
                                this.cbs.ondirarg(this.sectionStart, this.index);
                                this.state = 16;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateInDynamicDirArg",
                        value: function stateInDynamicDirArg(c) {
                            if (c === 93) {
                                this.state = 14;
                            } else if (c === 61 || isEndOfTagSection(c)) {
                                this.cbs.ondirarg(this.sectionStart, this.index + 1);
                                this.handleAttrNameEnd(c);
                                {
                                    this.cbs.onerr(27, this.index);
                                }
                            }
                        }
                    },
                    {
                        key: "stateInDirModifier",
                        value: function stateInDirModifier(c) {
                            if (c === 61 || isEndOfTagSection(c)) {
                                this.cbs.ondirmodifier(this.sectionStart, this.index);
                                this.handleAttrNameEnd(c);
                            } else if (c === 46) {
                                this.cbs.ondirmodifier(this.sectionStart, this.index);
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "handleAttrNameEnd",
                        value: function handleAttrNameEnd(c) {
                            this.sectionStart = this.index;
                            this.state = 17;
                            this.cbs.onattribnameend(this.index);
                            this.stateAfterAttrName(c);
                        }
                    },
                    {
                        key: "stateAfterAttrName",
                        value: function stateAfterAttrName(c) {
                            if (c === 61) {
                                this.state = 18;
                            } else if (c === 47 || c === 62) {
                                this.cbs.onattribend(0, this.sectionStart);
                                this.sectionStart = -1;
                                this.state = 11;
                                this.stateBeforeAttrName(c);
                            } else if (!isWhitespace(c)) {
                                this.cbs.onattribend(0, this.sectionStart);
                                this.handleAttrStart(c);
                            }
                        }
                    },
                    {
                        key: "stateBeforeAttrValue",
                        value: function stateBeforeAttrValue(c) {
                            if (c === 34) {
                                this.state = 19;
                                this.sectionStart = this.index + 1;
                            } else if (c === 39) {
                                this.state = 20;
                                this.sectionStart = this.index + 1;
                            } else if (!isWhitespace(c)) {
                                this.sectionStart = this.index;
                                this.state = 21;
                                this.stateInAttrValueNoQuotes(c);
                            }
                        }
                    },
                    {
                        key: "handleInAttrValue",
                        value: function handleInAttrValue(c, quote) {
                            if (c === quote || false) {
                                this.cbs.onattribdata(this.sectionStart, this.index);
                                this.sectionStart = -1;
                                this.cbs.onattribend(quote === 34 ? 3 : 2, this.index + 1);
                                this.state = 11;
                            } else if (c === 38) {
                                this.startEntity();
                            }
                        }
                    },
                    {
                        key: "stateInAttrValueDoubleQuotes",
                        value: function stateInAttrValueDoubleQuotes(c) {
                            this.handleInAttrValue(c, 34);
                        }
                    },
                    {
                        key: "stateInAttrValueSingleQuotes",
                        value: function stateInAttrValueSingleQuotes(c) {
                            this.handleInAttrValue(c, 39);
                        }
                    },
                    {
                        key: "stateInAttrValueNoQuotes",
                        value: function stateInAttrValueNoQuotes(c) {
                            if (isWhitespace(c) || c === 62) {
                                this.cbs.onattribdata(this.sectionStart, this.index);
                                this.sectionStart = -1;
                                this.cbs.onattribend(1, this.index);
                                this.state = 11;
                                this.stateBeforeAttrName(c);
                            } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
                                this.cbs.onerr(18, this.index);
                            } else if (c === 38) {
                                this.startEntity();
                            }
                        }
                    },
                    {
                        key: "stateBeforeDeclaration",
                        value: function stateBeforeDeclaration(c) {
                            if (c === 91) {
                                this.state = 26;
                                this.sequenceIndex = 0;
                            } else {
                                this.state = c === 45 ? 25 : 23;
                            }
                        }
                    },
                    {
                        key: "stateInDeclaration",
                        value: function stateInDeclaration(c) {
                            if (c === 62 || this.fastForwardTo(62)) {
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateInProcessingInstruction",
                        value: function stateInProcessingInstruction(c) {
                            if (c === 62 || this.fastForwardTo(62)) {
                                this.cbs.onprocessinginstruction(this.sectionStart, this.index);
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateBeforeComment",
                        value: function stateBeforeComment(c) {
                            if (c === 45) {
                                this.state = 28;
                                this.currentSequence = Sequences.CommentEnd;
                                this.sequenceIndex = 2;
                                this.sectionStart = this.index + 1;
                            } else {
                                this.state = 23;
                            }
                        }
                    },
                    {
                        key: "stateInSpecialComment",
                        value: function stateInSpecialComment(c) {
                            if (c === 62 || this.fastForwardTo(62)) {
                                this.cbs.oncomment(this.sectionStart, this.index);
                                this.state = 1;
                                this.sectionStart = this.index + 1;
                            }
                        }
                    },
                    {
                        key: "stateBeforeSpecialS",
                        value: function stateBeforeSpecialS(c) {
                            if (c === Sequences.ScriptEnd[3]) {
                                this.startSpecial(Sequences.ScriptEnd, 4);
                            } else if (c === Sequences.StyleEnd[3]) {
                                this.startSpecial(Sequences.StyleEnd, 4);
                            } else {
                                this.state = 6;
                                this.stateInTagName(c);
                            }
                        }
                    },
                    {
                        key: "stateBeforeSpecialT",
                        value: function stateBeforeSpecialT(c) {
                            if (c === Sequences.TitleEnd[3]) {
                                this.startSpecial(Sequences.TitleEnd, 4);
                            } else if (c === Sequences.TextareaEnd[3]) {
                                this.startSpecial(Sequences.TextareaEnd, 4);
                            } else {
                                this.state = 6;
                                this.stateInTagName(c);
                            }
                        }
                    },
                    {
                        key: "startEntity",
                        value: function startEntity() {
                            {
                                this.baseState = this.state;
                                this.state = 33;
                                this.entityStart = this.index;
                                this.entityDecoder.startEntity(this.baseState === 1 || this.baseState === 32 ? decode_js.DecodingMode.Legacy : decode_js.DecodingMode.Attribute);
                            }
                        }
                    },
                    {
                        key: "stateInEntity",
                        value: function stateInEntity() {
                            {
                                var length = this.entityDecoder.write(this.buffer, this.index);
                                if (length >= 0) {
                                    this.state = this.baseState;
                                    if (length === 0) {
                                        this.index = this.entityStart;
                                    }
                                } else {
                                    this.index = this.buffer.length - 1;
                                }
                            }
                        }
                    },
                    {
                        /**
         * Iterates through the buffer, calling the function corresponding to the current state.
         *
         * States that are more likely to be hit are higher up, as a performance improvement.
         */ key: "parse",
                        value: function parse(input) {
                            this.buffer = input;
                            while(this.index < this.buffer.length){
                                var c = this.buffer.charCodeAt(this.index);
                                if (c === 10) {
                                    this.newlines.push(this.index);
                                }
                                switch(this.state){
                                    case 1:
                                        {
                                            this.stateText(c);
                                            break;
                                        }
                                    case 2:
                                        {
                                            this.stateInterpolationOpen(c);
                                            break;
                                        }
                                    case 3:
                                        {
                                            this.stateInterpolation(c);
                                            break;
                                        }
                                    case 4:
                                        {
                                            this.stateInterpolationClose(c);
                                            break;
                                        }
                                    case 31:
                                        {
                                            this.stateSpecialStartSequence(c);
                                            break;
                                        }
                                    case 32:
                                        {
                                            this.stateInRCDATA(c);
                                            break;
                                        }
                                    case 26:
                                        {
                                            this.stateCDATASequence(c);
                                            break;
                                        }
                                    case 19:
                                        {
                                            this.stateInAttrValueDoubleQuotes(c);
                                            break;
                                        }
                                    case 12:
                                        {
                                            this.stateInAttrName(c);
                                            break;
                                        }
                                    case 13:
                                        {
                                            this.stateInDirName(c);
                                            break;
                                        }
                                    case 14:
                                        {
                                            this.stateInDirArg(c);
                                            break;
                                        }
                                    case 15:
                                        {
                                            this.stateInDynamicDirArg(c);
                                            break;
                                        }
                                    case 16:
                                        {
                                            this.stateInDirModifier(c);
                                            break;
                                        }
                                    case 28:
                                        {
                                            this.stateInCommentLike(c);
                                            break;
                                        }
                                    case 27:
                                        {
                                            this.stateInSpecialComment(c);
                                            break;
                                        }
                                    case 11:
                                        {
                                            this.stateBeforeAttrName(c);
                                            break;
                                        }
                                    case 6:
                                        {
                                            this.stateInTagName(c);
                                            break;
                                        }
                                    case 34:
                                        {
                                            this.stateInSFCRootTagName(c);
                                            break;
                                        }
                                    case 9:
                                        {
                                            this.stateInClosingTagName(c);
                                            break;
                                        }
                                    case 5:
                                        {
                                            this.stateBeforeTagName(c);
                                            break;
                                        }
                                    case 17:
                                        {
                                            this.stateAfterAttrName(c);
                                            break;
                                        }
                                    case 20:
                                        {
                                            this.stateInAttrValueSingleQuotes(c);
                                            break;
                                        }
                                    case 18:
                                        {
                                            this.stateBeforeAttrValue(c);
                                            break;
                                        }
                                    case 8:
                                        {
                                            this.stateBeforeClosingTagName(c);
                                            break;
                                        }
                                    case 10:
                                        {
                                            this.stateAfterClosingTagName(c);
                                            break;
                                        }
                                    case 29:
                                        {
                                            this.stateBeforeSpecialS(c);
                                            break;
                                        }
                                    case 30:
                                        {
                                            this.stateBeforeSpecialT(c);
                                            break;
                                        }
                                    case 21:
                                        {
                                            this.stateInAttrValueNoQuotes(c);
                                            break;
                                        }
                                    case 7:
                                        {
                                            this.stateInSelfClosingTag(c);
                                            break;
                                        }
                                    case 23:
                                        {
                                            this.stateInDeclaration(c);
                                            break;
                                        }
                                    case 22:
                                        {
                                            this.stateBeforeDeclaration(c);
                                            break;
                                        }
                                    case 25:
                                        {
                                            this.stateBeforeComment(c);
                                            break;
                                        }
                                    case 24:
                                        {
                                            this.stateInProcessingInstruction(c);
                                            break;
                                        }
                                    case 33:
                                        {
                                            this.stateInEntity();
                                            break;
                                        }
                                }
                                this.index++;
                            }
                            this.cleanup();
                            this.finish();
                        }
                    },
                    {
                        /**
         * Remove data that has already been consumed from the buffer.
         */ key: "cleanup",
                        value: function cleanup() {
                            if (this.sectionStart !== this.index) {
                                if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
                                    this.cbs.ontext(this.sectionStart, this.index);
                                    this.sectionStart = this.index;
                                } else if (this.state === 19 || this.state === 20 || this.state === 21) {
                                    this.cbs.onattribdata(this.sectionStart, this.index);
                                    this.sectionStart = this.index;
                                }
                            }
                        }
                    },
                    {
                        key: "finish",
                        value: function finish() {
                            if (this.state === 33) {
                                this.entityDecoder.end();
                                this.state = this.baseState;
                            }
                            this.handleTrailingData();
                            this.cbs.onend();
                        }
                    },
                    {
                        /** Handle any trailing data. */ key: "handleTrailingData",
                        value: function handleTrailingData() {
                            var endIndex = this.buffer.length;
                            if (this.sectionStart >= endIndex) {
                                return;
                            }
                            if (this.state === 28) {
                                if (this.currentSequence === Sequences.CdataEnd) {
                                    this.cbs.oncdata(this.sectionStart, endIndex);
                                } else {
                                    this.cbs.oncomment(this.sectionStart, endIndex);
                                }
                            } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ;
                            else {
                                this.cbs.ontext(this.sectionStart, endIndex);
                            }
                        }
                    },
                    {
                        key: "emitCodePoint",
                        value: function emitCodePoint(cp, consumed) {
                            {
                                if (this.baseState !== 1 && this.baseState !== 32) {
                                    if (this.sectionStart < this.entityStart) {
                                        this.cbs.onattribdata(this.sectionStart, this.entityStart);
                                    }
                                    this.sectionStart = this.entityStart + consumed;
                                    this.index = this.sectionStart - 1;
                                    this.cbs.onattribentity(decode_js.fromCodePoint(cp), this.entityStart, this.sectionStart);
                                } else {
                                    if (this.sectionStart < this.entityStart) {
                                        this.cbs.ontext(this.sectionStart, this.entityStart);
                                    }
                                    this.sectionStart = this.entityStart + consumed;
                                    this.index = this.sectionStart - 1;
                                    this.cbs.ontextentity(decode_js.fromCodePoint(cp), this.entityStart, this.sectionStart);
                                }
                            }
                        }
                    }
                ]);
                return Tokenizer;
            }();
            var CompilerDeprecationTypes = {
                "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
                "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
                "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
                "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
                "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
                "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
                "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
                "COMPILER_FILTERS": "COMPILER_FILTERS"
            };
            var _obj1;
            var deprecationData = (_obj1 = {}, _define_property(_obj1, "COMPILER_IS_ON_ELEMENT", {
                message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
                link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
            }), _define_property(_obj1, "COMPILER_V_BIND_SYNC", {
                message: function(key) {
                    return ".sync modifier for v-bind has been removed. Use v-model with argument instead. `v-bind:".concat(key, ".sync` should be changed to `v-model:").concat(key, "`.");
                },
                link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
            }), _define_property(_obj1, "COMPILER_V_BIND_OBJECT_ORDER", {
                message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
                link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
            }), _define_property(_obj1, "COMPILER_V_ON_NATIVE", {
                message: ".native modifier for v-on has been removed as is no longer necessary.",
                link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
            }), _define_property(_obj1, "COMPILER_V_IF_V_FOR_PRECEDENCE", {
                message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
                link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
            }), _define_property(_obj1, "COMPILER_NATIVE_TEMPLATE", {
                message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
            }), _define_property(_obj1, "COMPILER_INLINE_TEMPLATE", {
                message: '"inline-template" has been removed in Vue 3.',
                link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
            }), _define_property(_obj1, "COMPILER_FILTERS", {
                message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
                link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
            }), _obj1);
            function getCompatValue(key, param) {
                var compatConfig = param.compatConfig;
                var value = compatConfig && compatConfig[key];
                if (key === "MODE") {
                    return value || 3;
                } else {
                    return value;
                }
            }
            function isCompatEnabled(key, context) {
                var mode = getCompatValue("MODE", context);
                var value = getCompatValue(key, context);
                return mode === 3 ? value === true : value !== false;
            }
            function checkCompatEnabled(key, context, loc) {
                for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
                    args[_key - 3] = arguments[_key];
                }
                var enabled = isCompatEnabled(key, context);
                if (enabled) {
                    warnDeprecation.apply(void 0, [
                        key,
                        context,
                        loc
                    ].concat(_to_consumable_array(args)));
                }
                return enabled;
            }
            function warnDeprecation(key, context, loc) {
                for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
                    args[_key - 3] = arguments[_key];
                }
                var val = getCompatValue(key, context);
                if (val === "suppress-warning") {
                    return;
                }
                var _deprecationData_key = deprecationData[key], message = _deprecationData_key.message, link = _deprecationData_key.link;
                var msg = "(deprecation ".concat(key, ") ").concat(typeof message === "function" ? message.apply(void 0, _to_consumable_array(args)) : message).concat(link ? "\n  Details: ".concat(link) : "");
                var err = new SyntaxError(msg);
                err.code = key;
                if (loc) err.loc = loc;
                context.onWarn(err);
            }
            function defaultOnError(error) {
                throw error;
            }
            function defaultOnWarn(msg) {
                console.warn("[Vue warn] ".concat(msg.message));
            }
            function createCompilerError(code, loc, messages, additionalMessage) {
                var msg = (messages || errorMessages)[code] + (additionalMessage || "");
                var error = new SyntaxError(String(msg));
                error.code = code;
                error.loc = loc;
                return error;
            }
            var ErrorCodes = {
                "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
                "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
                "CDATA_IN_HTML_CONTENT": 1,
                "1": "CDATA_IN_HTML_CONTENT",
                "DUPLICATE_ATTRIBUTE": 2,
                "2": "DUPLICATE_ATTRIBUTE",
                "END_TAG_WITH_ATTRIBUTES": 3,
                "3": "END_TAG_WITH_ATTRIBUTES",
                "END_TAG_WITH_TRAILING_SOLIDUS": 4,
                "4": "END_TAG_WITH_TRAILING_SOLIDUS",
                "EOF_BEFORE_TAG_NAME": 5,
                "5": "EOF_BEFORE_TAG_NAME",
                "EOF_IN_CDATA": 6,
                "6": "EOF_IN_CDATA",
                "EOF_IN_COMMENT": 7,
                "7": "EOF_IN_COMMENT",
                "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
                "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
                "EOF_IN_TAG": 9,
                "9": "EOF_IN_TAG",
                "INCORRECTLY_CLOSED_COMMENT": 10,
                "10": "INCORRECTLY_CLOSED_COMMENT",
                "INCORRECTLY_OPENED_COMMENT": 11,
                "11": "INCORRECTLY_OPENED_COMMENT",
                "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
                "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
                "MISSING_ATTRIBUTE_VALUE": 13,
                "13": "MISSING_ATTRIBUTE_VALUE",
                "MISSING_END_TAG_NAME": 14,
                "14": "MISSING_END_TAG_NAME",
                "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
                "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
                "NESTED_COMMENT": 16,
                "16": "NESTED_COMMENT",
                "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
                "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
                "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
                "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
                "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
                "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
                "UNEXPECTED_NULL_CHARACTER": 20,
                "20": "UNEXPECTED_NULL_CHARACTER",
                "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
                "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
                "UNEXPECTED_SOLIDUS_IN_TAG": 22,
                "22": "UNEXPECTED_SOLIDUS_IN_TAG",
                "X_INVALID_END_TAG": 23,
                "23": "X_INVALID_END_TAG",
                "X_MISSING_END_TAG": 24,
                "24": "X_MISSING_END_TAG",
                "X_MISSING_INTERPOLATION_END": 25,
                "25": "X_MISSING_INTERPOLATION_END",
                "X_MISSING_DIRECTIVE_NAME": 26,
                "26": "X_MISSING_DIRECTIVE_NAME",
                "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
                "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
                "X_V_IF_NO_EXPRESSION": 28,
                "28": "X_V_IF_NO_EXPRESSION",
                "X_V_IF_SAME_KEY": 29,
                "29": "X_V_IF_SAME_KEY",
                "X_V_ELSE_NO_ADJACENT_IF": 30,
                "30": "X_V_ELSE_NO_ADJACENT_IF",
                "X_V_FOR_NO_EXPRESSION": 31,
                "31": "X_V_FOR_NO_EXPRESSION",
                "X_V_FOR_MALFORMED_EXPRESSION": 32,
                "32": "X_V_FOR_MALFORMED_EXPRESSION",
                "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
                "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
                "X_V_BIND_NO_EXPRESSION": 34,
                "34": "X_V_BIND_NO_EXPRESSION",
                "X_V_ON_NO_EXPRESSION": 35,
                "35": "X_V_ON_NO_EXPRESSION",
                "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
                "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
                "X_V_SLOT_MIXED_SLOT_USAGE": 37,
                "37": "X_V_SLOT_MIXED_SLOT_USAGE",
                "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
                "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
                "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
                "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
                "X_V_SLOT_MISPLACED": 40,
                "40": "X_V_SLOT_MISPLACED",
                "X_V_MODEL_NO_EXPRESSION": 41,
                "41": "X_V_MODEL_NO_EXPRESSION",
                "X_V_MODEL_MALFORMED_EXPRESSION": 42,
                "42": "X_V_MODEL_MALFORMED_EXPRESSION",
                "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
                "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
                "X_V_MODEL_ON_PROPS": 44,
                "44": "X_V_MODEL_ON_PROPS",
                "X_INVALID_EXPRESSION": 45,
                "45": "X_INVALID_EXPRESSION",
                "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
                "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
                "X_PREFIX_ID_NOT_SUPPORTED": 47,
                "47": "X_PREFIX_ID_NOT_SUPPORTED",
                "X_MODULE_MODE_NOT_SUPPORTED": 48,
                "48": "X_MODULE_MODE_NOT_SUPPORTED",
                "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
                "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
                "X_SCOPE_ID_NOT_SUPPORTED": 50,
                "50": "X_SCOPE_ID_NOT_SUPPORTED",
                "X_VNODE_HOOKS": 51,
                "51": "X_VNODE_HOOKS",
                "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
                "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
                "__EXTEND_POINT__": 53,
                "53": "__EXTEND_POINT__"
            };
            var _obj2;
            var errorMessages = (_obj2 = {}, // parse errors
            _define_property(_obj2, 0, "Illegal comment."), _define_property(_obj2, 1, "CDATA section is allowed only in XML context."), _define_property(_obj2, 2, "Duplicate attribute."), _define_property(_obj2, 3, "End tag cannot have attributes."), _define_property(_obj2, 4, "Illegal '/' in tags."), _define_property(_obj2, 5, "Unexpected EOF in tag."), _define_property(_obj2, 6, "Unexpected EOF in CDATA section."), _define_property(_obj2, 7, "Unexpected EOF in comment."), _define_property(_obj2, 8, "Unexpected EOF in script."), _define_property(_obj2, 9, "Unexpected EOF in tag."), _define_property(_obj2, 10, "Incorrectly closed comment."), _define_property(_obj2, 11, "Incorrectly opened comment."), _define_property(_obj2, 12, "Illegal tag name. Use '&lt;' to print '<'."), _define_property(_obj2, 13, "Attribute value was expected."), _define_property(_obj2, 14, "End tag name was expected."), _define_property(_obj2, 15, "Whitespace was expected."), _define_property(_obj2, 16, "Unexpected '<!--' in comment."), _define_property(_obj2, 17, "Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<)."), _define_property(_obj2, 18, "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`)."), _define_property(_obj2, 19, "Attribute name cannot start with '='."), _define_property(_obj2, 21, "'<?' is allowed only in XML context."), _define_property(_obj2, 20, "Unexpected null character."), _define_property(_obj2, 22, "Illegal '/' in tags."), // Vue-specific parse errors
            _define_property(_obj2, 23, "Invalid end tag."), _define_property(_obj2, 24, "Element is missing end tag."), _define_property(_obj2, 25, "Interpolation end sign was not found."), _define_property(_obj2, 27, "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces."), _define_property(_obj2, 26, "Legal directive name was expected."), // transform errors
            _define_property(_obj2, 28, "v-if/v-else-if is missing expression."), _define_property(_obj2, 29, "v-if/else branches must use unique keys."), _define_property(_obj2, 30, "v-else/v-else-if has no adjacent v-if or v-else-if."), _define_property(_obj2, 31, "v-for is missing expression."), _define_property(_obj2, 32, "v-for has invalid expression."), _define_property(_obj2, 33, "<template v-for> key should be placed on the <template> tag."), _define_property(_obj2, 34, "v-bind is missing expression."), _define_property(_obj2, 52, "v-bind with same-name shorthand only allows static argument."), _define_property(_obj2, 35, "v-on is missing expression."), _define_property(_obj2, 36, "Unexpected custom directive on <slot> outlet."), _define_property(_obj2, 37, "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity."), _define_property(_obj2, 38, "Duplicate slot names found. "), _define_property(_obj2, 39, "Extraneous children found when component already has explicitly named default slot. These children will be ignored."), _define_property(_obj2, 40, "v-slot can only be used on components or <template> tags."), _define_property(_obj2, 41, "v-model is missing expression."), _define_property(_obj2, 42, "v-model value must be a valid JavaScript member expression."), _define_property(_obj2, 43, "v-model cannot be used on v-for or v-slot scope variables because they are not writable."), _define_property(_obj2, 44, "v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead."), _define_property(_obj2, 45, "Error parsing JavaScript expression: "), _define_property(_obj2, 46, "<KeepAlive> expects exactly one child component."), _define_property(_obj2, 51, "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4."), // generic errors
            _define_property(_obj2, 47, '"prefixIdentifiers" option is not supported in this build of compiler.'), _define_property(_obj2, 48, "ES module mode is not supported in this build of compiler."), _define_property(_obj2, 49, '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.'), _define_property(_obj2, 50, '"scopeId" option is only supported in module mode.'), // just to fulfill types
            _define_property(_obj2, 53, ""), _obj2);
            function walkIdentifiers(root, onIdentifier) {
                var includeAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, parentStack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], knownIds = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : /* @__PURE__ */ Object.create(null);
                var rootExp = root.type === "Program" ? root.body[0].type === "ExpressionStatement" && root.body[0].expression : root;
                estreeWalker.walk(root, {
                    enter: function enter(node, parent) {
                        parent && parentStack.push(parent);
                        if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
                            return this.skip();
                        }
                        if (node.type === "Identifier") {
                            var isLocal = !!knownIds[node.name];
                            var isRefed = isReferencedIdentifier(node, parent, parentStack);
                            if (includeAll || isRefed && !isLocal) {
                                onIdentifier(node, parent, parentStack, isRefed, isLocal);
                            }
                        } else if (node.type === "ObjectProperty" && // eslint-disable-next-line no-restricted-syntax
                        (parent == null ? void 0 : parent.type) === "ObjectPattern") {
                            node.inPattern = true;
                        } else if (isFunctionType(node)) {
                            if (node.scopeIds) {
                                node.scopeIds.forEach(function(id) {
                                    return markKnownIds(id, knownIds);
                                });
                            } else {
                                walkFunctionParams(node, function(id) {
                                    return markScopeIdentifier(node, id, knownIds);
                                });
                            }
                        } else if (node.type === "BlockStatement") {
                            if (node.scopeIds) {
                                node.scopeIds.forEach(function(id) {
                                    return markKnownIds(id, knownIds);
                                });
                            } else {
                                walkBlockDeclarations(node, function(id) {
                                    return markScopeIdentifier(node, id, knownIds);
                                });
                            }
                        } else if (node.type === "CatchClause" && node.param) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = extractIdentifiers(node.param)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var id = _step.value;
                                    markScopeIdentifier(node, id, knownIds);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        } else if (isForStatement(node)) {
                            walkForStatement(node, false, function(id) {
                                return markScopeIdentifier(node, id, knownIds);
                            });
                        }
                    },
                    leave: function leave(node, parent) {
                        parent && parentStack.pop();
                        if (node !== rootExp && node.scopeIds) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = node.scopeIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var id = _step.value;
                                    knownIds[id]--;
                                    if (knownIds[id] === 0) {
                                        delete knownIds[id];
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            function isReferencedIdentifier(id, parent, parentStack) {
                if (!parent) {
                    return true;
                }
                if (id.name === "arguments") {
                    return false;
                }
                if (isReferenced(id, parent)) {
                    return true;
                }
                switch(parent.type){
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                        return true;
                    case "ObjectPattern":
                    case "ArrayPattern":
                        return isInDestructureAssignment(parent, parentStack);
                }
                return false;
            }
            function isInDestructureAssignment(parent, parentStack) {
                if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
                    var i = parentStack.length;
                    while(i--){
                        var p = parentStack[i];
                        if (p.type === "AssignmentExpression") {
                            return true;
                        } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
                            break;
                        }
                    }
                }
                return false;
            }
            function isInNewExpression(parentStack) {
                var i = parentStack.length;
                while(i--){
                    var p = parentStack[i];
                    if (p.type === "NewExpression") {
                        return true;
                    } else if (p.type !== "MemberExpression") {
                        break;
                    }
                }
                return false;
            }
            function walkFunctionParams(node, onIdent) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = node.params[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var p = _step.value;
                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                        try {
                            for(var _iterator1 = extractIdentifiers(p)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                var id = _step1.value;
                                onIdent(id);
                            }
                        } catch (err) {
                            _didIteratorError1 = true;
                            _iteratorError1 = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                    _iterator1.return();
                                }
                            } finally{
                                if (_didIteratorError1) {
                                    throw _iteratorError1;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            function walkBlockDeclarations(block, onIdent) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = block.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var stmt = _step.value;
                        if (stmt.type === "VariableDeclaration") {
                            if (stmt.declare) continue;
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = stmt.declarations[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var decl = _step1.value;
                                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
                                    try {
                                        for(var _iterator2 = extractIdentifiers(decl.id)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                                            var id = _step2.value;
                                            onIdent(id);
                                        }
                                    } catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                                                _iterator2.return();
                                            }
                                        } finally{
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
                            if (stmt.declare || !stmt.id) continue;
                            onIdent(stmt.id);
                        } else if (isForStatement(stmt)) {
                            walkForStatement(stmt, true, onIdent);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            function isForStatement(stmt) {
                return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
            }
            function walkForStatement(stmt, isVar, onIdent) {
                var variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
                if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = variable.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var decl = _step.value;
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                for(var _iterator1 = extractIdentifiers(decl.id)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
                                    var id = _step1.value;
                                    onIdent(id);
                                }
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            }
            function extractIdentifiers(param) {
                var nodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                switch(param.type){
                    case "Identifier":
                        nodes.push(param);
                        break;
                    case "MemberExpression":
                        var object = param;
                        while(object.type === "MemberExpression"){
                            object = object.object;
                        }
                        nodes.push(object);
                        break;
                    case "ObjectPattern":
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = param.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var prop = _step.value;
                                if (prop.type === "RestElement") {
                                    extractIdentifiers(prop.argument, nodes);
                                } else {
                                    extractIdentifiers(prop.value, nodes);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                        break;
                    case "ArrayPattern":
                        param.elements.forEach(function(element) {
                            if (element) extractIdentifiers(element, nodes);
                        });
                        break;
                    case "RestElement":
                        extractIdentifiers(param.argument, nodes);
                        break;
                    case "AssignmentPattern":
                        extractIdentifiers(param.left, nodes);
                        break;
                }
                return nodes;
            }
            function markKnownIds(name, knownIds) {
                if (name in knownIds) {
                    knownIds[name]++;
                } else {
                    knownIds[name] = 1;
                }
            }
            function markScopeIdentifier(node, child, knownIds) {
                var name = child.name;
                if (node.scopeIds && node.scopeIds.has(name)) {
                    return;
                }
                markKnownIds(name, knownIds);
                (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
            }
            var isFunctionType = function(node) {
                return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
            };
            var isStaticProperty = function(node) {
                return node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
            };
            var isStaticPropertyKey = function(node, parent) {
                return isStaticProperty(parent) && parent.key === node;
            };
            function isReferenced(node, parent, grandparent) {
                switch(parent.type){
                    // yes: PARENT[NODE]
                    // yes: NODE.child
                    // no: parent.NODE
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        if (parent.property === node) {
                            return !!parent.computed;
                        }
                        return parent.object === node;
                    case "JSXMemberExpression":
                        return parent.object === node;
                    // no: let NODE = init;
                    // yes: let id = NODE;
                    case "VariableDeclarator":
                        return parent.init === node;
                    // yes: () => NODE
                    // no: (NODE) => {}
                    case "ArrowFunctionExpression":
                        return parent.body === node;
                    // no: class { #NODE; }
                    // no: class { get #NODE() {} }
                    // no: class { #NODE() {} }
                    // no: class { fn() { return this.#NODE; } }
                    case "PrivateName":
                        return false;
                    // no: class { NODE() {} }
                    // yes: class { [NODE]() {} }
                    // no: class { foo(NODE) {} }
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "ObjectMethod":
                        if (parent.key === node) {
                            return !!parent.computed;
                        }
                        return false;
                    // yes: { [NODE]: "" }
                    // no: { NODE: "" }
                    // depends: { NODE }
                    // depends: { key: NODE }
                    case "ObjectProperty":
                        if (parent.key === node) {
                            return !!parent.computed;
                        }
                        return !grandparent;
                    // no: class { NODE = value; }
                    // yes: class { [NODE] = value; }
                    // yes: class { key = NODE; }
                    case "ClassProperty":
                        if (parent.key === node) {
                            return !!parent.computed;
                        }
                        return true;
                    case "ClassPrivateProperty":
                        return parent.key !== node;
                    // no: class NODE {}
                    // yes: class Foo extends NODE {}
                    case "ClassDeclaration":
                    case "ClassExpression":
                        return parent.superClass === node;
                    // yes: left = NODE;
                    // no: NODE = right;
                    case "AssignmentExpression":
                        return parent.right === node;
                    // no: [NODE = foo] = [];
                    // yes: [foo = NODE] = [];
                    case "AssignmentPattern":
                        return parent.right === node;
                    // no: NODE: for (;;) {}
                    case "LabeledStatement":
                        return false;
                    // no: try {} catch (NODE) {}
                    case "CatchClause":
                        return false;
                    // no: function foo(...NODE) {}
                    case "RestElement":
                        return false;
                    case "BreakStatement":
                    case "ContinueStatement":
                        return false;
                    // no: function NODE() {}
                    // no: function foo(NODE) {}
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                        return false;
                    // no: export NODE from "foo";
                    // no: export * as NODE from "foo";
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier":
                        return false;
                    // no: export { foo as NODE };
                    // yes: export { NODE as foo };
                    // no: export { NODE as foo } from "foo";
                    case "ExportSpecifier":
                        return parent.local === node;
                    // no: import NODE from "foo";
                    // no: import * as NODE from "foo";
                    // no: import { NODE as foo } from "foo";
                    // no: import { foo as NODE } from "foo";
                    // no: import NODE from "bar";
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                        return false;
                    // no: import "foo" assert { NODE: "json" }
                    case "ImportAttribute":
                        return false;
                    // no: <div NODE="foo" />
                    case "JSXAttribute":
                        return false;
                    // no: [NODE] = [];
                    // no: ({ NODE }) = [];
                    case "ObjectPattern":
                    case "ArrayPattern":
                        return false;
                    // no: new.NODE
                    // no: NODE.target
                    case "MetaProperty":
                        return false;
                    // yes: type X = { someProperty: NODE }
                    // no: type X = { NODE: OtherType }
                    case "ObjectTypeProperty":
                        return parent.key !== node;
                    // yes: enum X { Foo = NODE }
                    // no: enum X { NODE }
                    case "TSEnumMember":
                        return parent.id !== node;
                    // yes: { [NODE]: value }
                    // no: { NODE: value }
                    case "TSPropertySignature":
                        if (parent.key === node) {
                            return !!parent.computed;
                        }
                        return true;
                }
                return true;
            }
            var TS_NODE_TYPES = [
                "TSAsExpression",
                // foo as number
                "TSTypeAssertion",
                // (<number>foo)
                "TSNonNullExpression",
                // foo!
                "TSInstantiationExpression",
                // foo<string>
                "TSSatisfiesExpression"
            ];
            function unwrapTSNode(node) {
                if (TS_NODE_TYPES.includes(node.type)) {
                    return unwrapTSNode(node.expression);
                } else {
                    return node;
                }
            }
            var isStaticExp = function(p) {
                return p.type === 4 && p.isStatic;
            };
            function isCoreComponent(tag) {
                switch(tag){
                    case "Teleport":
                    case "teleport":
                        return TELEPORT;
                    case "Suspense":
                    case "suspense":
                        return SUSPENSE;
                    case "KeepAlive":
                    case "keep-alive":
                        return KEEP_ALIVE;
                    case "BaseTransition":
                    case "base-transition":
                        return BASE_TRANSITION;
                }
            }
            var nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
            var isSimpleIdentifier = function(name) {
                return !nonIdentifierRE.test(name);
            };
            var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
            var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
            var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
            var getExpSource = function(exp) {
                return exp.type === 4 ? exp.content : exp.loc.source;
            };
            var isMemberExpressionBrowser = function(exp) {
                var path = getExpSource(exp).trim().replace(whitespaceRE, function(s) {
                    return s.trim();
                });
                var state = 0;
                var stateStack = [];
                var currentOpenBracketCount = 0;
                var currentOpenParensCount = 0;
                var currentStringType = null;
                for(var i = 0; i < path.length; i++){
                    var char = path.charAt(i);
                    switch(state){
                        case 0:
                            if (char === "[") {
                                stateStack.push(state);
                                state = 1;
                                currentOpenBracketCount++;
                            } else if (char === "(") {
                                stateStack.push(state);
                                state = 2;
                                currentOpenParensCount++;
                            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                                return false;
                            }
                            break;
                        case 1:
                            if (char === "'" || char === '"' || char === "`") {
                                stateStack.push(state);
                                state = 3;
                                currentStringType = char;
                            } else if (char === "[") {
                                currentOpenBracketCount++;
                            } else if (char === "]") {
                                if (!--currentOpenBracketCount) {
                                    state = stateStack.pop();
                                }
                            }
                            break;
                        case 2:
                            if (char === "'" || char === '"' || char === "`") {
                                stateStack.push(state);
                                state = 3;
                                currentStringType = char;
                            } else if (char === "(") {
                                currentOpenParensCount++;
                            } else if (char === ")") {
                                if (i === path.length - 1) {
                                    return false;
                                }
                                if (!--currentOpenParensCount) {
                                    state = stateStack.pop();
                                }
                            }
                            break;
                        case 3:
                            if (char === currentStringType) {
                                state = stateStack.pop();
                                currentStringType = null;
                            }
                            break;
                    }
                }
                return !currentOpenBracketCount && !currentOpenParensCount;
            };
            var isMemberExpressionNode = function(exp, context) {
                try {
                    var ret = exp.ast || parser.parseExpression(getExpSource(exp), {
                        plugins: context.expressionPlugins ? _to_consumable_array(context.expressionPlugins).concat([
                            "typescript"
                        ]) : [
                            "typescript"
                        ]
                    });
                    ret = unwrapTSNode(ret);
                    return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier" && ret.name !== "undefined";
                } catch (e) {
                    return false;
                }
            };
            var isMemberExpression = isMemberExpressionNode;
            var fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
            var isFnExpressionBrowser = function(exp) {
                return fnExpRE.test(getExpSource(exp));
            };
            var isFnExpressionNode = function(exp, context) {
                try {
                    var ret = exp.ast || parser.parseExpression(getExpSource(exp), {
                        plugins: context.expressionPlugins ? _to_consumable_array(context.expressionPlugins).concat([
                            "typescript"
                        ]) : [
                            "typescript"
                        ]
                    });
                    if (ret.type === "Program") {
                        ret = ret.body[0];
                        if (ret.type === "ExpressionStatement") {
                            ret = ret.expression;
                        }
                    }
                    ret = unwrapTSNode(ret);
                    return ret.type === "FunctionExpression" || ret.type === "ArrowFunctionExpression";
                } catch (e) {
                    return false;
                }
            };
            var isFnExpression = isFnExpressionNode;
            function advancePositionWithClone(pos, source) {
                var numberOfCharacters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : source.length;
                return advancePositionWithMutation({
                    offset: pos.offset,
                    line: pos.line,
                    column: pos.column
                }, source, numberOfCharacters);
            }
            function advancePositionWithMutation(pos, source) {
                var numberOfCharacters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : source.length;
                var linesCount = 0;
                var lastNewLinePos = -1;
                for(var i = 0; i < numberOfCharacters; i++){
                    if (source.charCodeAt(i) === 10) {
                        linesCount++;
                        lastNewLinePos = i;
                    }
                }
                pos.offset += numberOfCharacters;
                pos.line += linesCount;
                pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
                return pos;
            }
            function assert(condition, msg) {
                if (!condition) {
                    throw new Error(msg || "unexpected compiler condition");
                }
            }
            function findDir(node, name) {
                var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                for(var i = 0; i < node.props.length; i++){
                    var p = node.props[i];
                    if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {
                        return p;
                    }
                }
            }
            function findProp(node, name) {
                var dynamicOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, allowEmpty = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                for(var i = 0; i < node.props.length; i++){
                    var p = node.props[i];
                    if (p.type === 6) {
                        if (dynamicOnly) continue;
                        if (p.name === name && (p.value || allowEmpty)) {
                            return p;
                        }
                    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
                        return p;
                    }
                }
            }
            function isStaticArgOf(arg, name) {
                return !!(arg && isStaticExp(arg) && arg.content === name);
            }
            function hasDynamicKeyVBind(node) {
                return node.props.some(function(p) {
                    return p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
                    p.arg.type !== 4 || // v-bind:[_ctx.foo]
                    !p.arg.isStatic);
                });
            }
            function isText$1(node) {
                return node.type === 5 || node.type === 2;
            }
            function isVSlot(p) {
                return p.type === 7 && p.name === "slot";
            }
            function isTemplateNode(node) {
                return node.type === 1 && node.tagType === 3;
            }
            function isSlotOutlet(node) {
                return node.type === 1 && node.tagType === 2;
            }
            var propsHelperSet = /* @__PURE__ */ new Set([
                NORMALIZE_PROPS,
                GUARD_REACTIVE_PROPS
            ]);
            function getUnnormalizedProps(props) {
                var callPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                if (props && !shared.isString(props) && props.type === 14) {
                    var callee = props.callee;
                    if (!shared.isString(callee) && propsHelperSet.has(callee)) {
                        return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
                    }
                }
                return [
                    props,
                    callPath
                ];
            }
            function injectProp(node, prop, context) {
                var propsWithInjection;
                var props = node.type === 13 ? node.props : node.arguments[2];
                var callPath = [];
                var parentCall;
                if (props && !shared.isString(props) && props.type === 14) {
                    var ret = getUnnormalizedProps(props);
                    props = ret[0];
                    callPath = ret[1];
                    parentCall = callPath[callPath.length - 1];
                }
                if (props == null || shared.isString(props)) {
                    propsWithInjection = createObjectExpression([
                        prop
                    ]);
                } else if (props.type === 14) {
                    var first = props.arguments[0];
                    if (!shared.isString(first) && first.type === 15) {
                        if (!hasProp(prop, first)) {
                            first.properties.unshift(prop);
                        }
                    } else {
                        if (props.callee === TO_HANDLERS) {
                            propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                                createObjectExpression([
                                    prop
                                ]),
                                props
                            ]);
                        } else {
                            props.arguments.unshift(createObjectExpression([
                                prop
                            ]));
                        }
                    }
                    !propsWithInjection && (propsWithInjection = props);
                } else if (props.type === 15) {
                    if (!hasProp(prop, props)) {
                        props.properties.unshift(prop);
                    }
                    propsWithInjection = props;
                } else {
                    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                        createObjectExpression([
                            prop
                        ]),
                        props
                    ]);
                    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
                        parentCall = callPath[callPath.length - 2];
                    }
                }
                if (node.type === 13) {
                    if (parentCall) {
                        parentCall.arguments[0] = propsWithInjection;
                    } else {
                        node.props = propsWithInjection;
                    }
                } else {
                    if (parentCall) {
                        parentCall.arguments[0] = propsWithInjection;
                    } else {
                        node.arguments[2] = propsWithInjection;
                    }
                }
            }
            function hasProp(prop, props) {
                var result = false;
                if (prop.key.type === 4) {
                    var propKeyName = prop.key.content;
                    result = props.properties.some(function(p) {
                        return p.key.type === 4 && p.key.content === propKeyName;
                    });
                }
                return result;
            }
            function toValidAssetId(name, type) {
                return "_".concat(type, "_").concat(name.replace(/[^\w]/g, function(searchValue, replaceValue) {
                    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
                }));
            }
            function hasScopeRef(node, ids) {
                if (!node || Object.keys(ids).length === 0) {
                    return false;
                }
                switch(node.type){
                    case 1:
                        for(var i = 0; i < node.props.length; i++){
                            var p = node.props[i];
                            if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                                return true;
                            }
                        }
                        return node.children.some(function(c) {
                            return hasScopeRef(c, ids);
                        });
                    case 11:
                        if (hasScopeRef(node.source, ids)) {
                            return true;
                        }
                        return node.children.some(function(c) {
                            return hasScopeRef(c, ids);
                        });
                    case 9:
                        return node.branches.some(function(b) {
                            return hasScopeRef(b, ids);
                        });
                    case 10:
                        if (hasScopeRef(node.condition, ids)) {
                            return true;
                        }
                        return node.children.some(function(c) {
                            return hasScopeRef(c, ids);
                        });
                    case 4:
                        return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
                    case 8:
                        return node.children.some(function(c) {
                            return shared.isObject(c) && hasScopeRef(c, ids);
                        });
                    case 5:
                    case 12:
                        return hasScopeRef(node.content, ids);
                    case 2:
                    case 3:
                    case 20:
                        return false;
                    default:
                        return false;
                }
            }
            function getMemoedVNodeCall(node) {
                if (node.type === 14 && node.callee === WITH_MEMO) {
                    return node.arguments[1].returns;
                } else {
                    return node;
                }
            }
            var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
            var defaultParserOptions = {
                parseMode: "base",
                ns: 0,
                delimiters: [
                    "{{",
                    "}}"
                ],
                getNamespace: function() {
                    return 0;
                },
                isVoidTag: shared.NO,
                isPreTag: shared.NO,
                isIgnoreNewlineTag: shared.NO,
                isCustomElement: shared.NO,
                onError: defaultOnError,
                onWarn: defaultOnWarn,
                comments: true,
                prefixIdentifiers: false
            };
            var currentOptions = defaultParserOptions;
            var currentRoot = null;
            var currentInput = "";
            var currentOpenTag = null;
            var currentProp = null;
            var currentAttrValue = "";
            var currentAttrStartIndex = -1;
            var currentAttrEndIndex = -1;
            var inPre = 0;
            var inVPre = false;
            var currentVPreBoundary = null;
            var stack = [];
            var tokenizer = new Tokenizer(stack, {
                onerr: emitError,
                ontext: function ontext(start, end) {
                    onText(getSlice(start, end), start, end);
                },
                ontextentity: function ontextentity(char, start, end) {
                    onText(char, start, end);
                },
                oninterpolation: function oninterpolation(start, end) {
                    if (inVPre) {
                        return onText(getSlice(start, end), start, end);
                    }
                    var innerStart = start + tokenizer.delimiterOpen.length;
                    var innerEnd = end - tokenizer.delimiterClose.length;
                    while(isWhitespace(currentInput.charCodeAt(innerStart))){
                        innerStart++;
                    }
                    while(isWhitespace(currentInput.charCodeAt(innerEnd - 1))){
                        innerEnd--;
                    }
                    var exp = getSlice(innerStart, innerEnd);
                    if (exp.includes("&")) {
                        {
                            exp = decode_js.decodeHTML(exp);
                        }
                    }
                    addNode({
                        type: 5,
                        content: createExp(exp, false, getLoc(innerStart, innerEnd)),
                        loc: getLoc(start, end)
                    });
                },
                onopentagname: function onopentagname(start, end) {
                    var name = getSlice(start, end);
                    currentOpenTag = {
                        type: 1,
                        tag: name,
                        ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
                        tagType: 0,
                        // will be refined on tag close
                        props: [],
                        children: [],
                        loc: getLoc(start - 1, end),
                        codegenNode: void 0
                    };
                },
                onopentagend: function onopentagend(end) {
                    endOpenTag(end);
                },
                onclosetag: function onclosetag(start, end) {
                    var name = getSlice(start, end);
                    if (!currentOptions.isVoidTag(name)) {
                        var found = false;
                        for(var i = 0; i < stack.length; i++){
                            var e = stack[i];
                            if (e.tag.toLowerCase() === name.toLowerCase()) {
                                found = true;
                                if (i > 0) {
                                    emitError(24, stack[0].loc.start.offset);
                                }
                                for(var j = 0; j <= i; j++){
                                    var el = stack.shift();
                                    onCloseTag(el, end, j < i);
                                }
                                break;
                            }
                        }
                        if (!found) {
                            emitError(23, backTrack(start, 60));
                        }
                    }
                },
                onselfclosingtag: function onselfclosingtag(end) {
                    var name = currentOpenTag.tag;
                    currentOpenTag.isSelfClosing = true;
                    endOpenTag(end);
                    if (stack[0] && stack[0].tag === name) {
                        onCloseTag(stack.shift(), end);
                    }
                },
                onattribname: function onattribname(start, end) {
                    currentProp = {
                        type: 6,
                        name: getSlice(start, end),
                        nameLoc: getLoc(start, end),
                        value: void 0,
                        loc: getLoc(start)
                    };
                },
                ondirname: function ondirname(start, end) {
                    var raw = getSlice(start, end);
                    var name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
                    if (!inVPre && name === "") {
                        emitError(26, start);
                    }
                    if (inVPre || name === "") {
                        currentProp = {
                            type: 6,
                            name: raw,
                            nameLoc: getLoc(start, end),
                            value: void 0,
                            loc: getLoc(start)
                        };
                    } else {
                        currentProp = {
                            type: 7,
                            name: name,
                            rawName: raw,
                            exp: void 0,
                            arg: void 0,
                            modifiers: raw === "." ? [
                                createSimpleExpression("prop")
                            ] : [],
                            loc: getLoc(start)
                        };
                        if (name === "pre") {
                            inVPre = tokenizer.inVPre = true;
                            currentVPreBoundary = currentOpenTag;
                            var props = currentOpenTag.props;
                            for(var i = 0; i < props.length; i++){
                                if (props[i].type === 7) {
                                    props[i] = dirToAttr(props[i]);
                                }
                            }
                        }
                    }
                },
                ondirarg: function ondirarg(start, end) {
                    if (start === end) return;
                    var arg = getSlice(start, end);
                    if (inVPre) {
                        currentProp.name += arg;
                        setLocEnd(currentProp.nameLoc, end);
                    } else {
                        var isStatic = arg[0] !== "[";
                        currentProp.arg = createExp(isStatic ? arg : arg.slice(1, -1), isStatic, getLoc(start, end), isStatic ? 3 : 0);
                    }
                },
                ondirmodifier: function ondirmodifier(start, end) {
                    var mod = getSlice(start, end);
                    if (inVPre) {
                        currentProp.name += "." + mod;
                        setLocEnd(currentProp.nameLoc, end);
                    } else if (currentProp.name === "slot") {
                        var arg = currentProp.arg;
                        if (arg) {
                            arg.content += "." + mod;
                            setLocEnd(arg.loc, end);
                        }
                    } else {
                        var exp = createSimpleExpression(mod, true, getLoc(start, end));
                        currentProp.modifiers.push(exp);
                    }
                },
                onattribdata: function onattribdata(start, end) {
                    currentAttrValue += getSlice(start, end);
                    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
                    currentAttrEndIndex = end;
                },
                onattribentity: function onattribentity(char, start, end) {
                    currentAttrValue += char;
                    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
                    currentAttrEndIndex = end;
                },
                onattribnameend: function onattribnameend(end) {
                    var start = currentProp.loc.start.offset;
                    var name = getSlice(start, end);
                    if (currentProp.type === 7) {
                        currentProp.rawName = name;
                    }
                    if (currentOpenTag.props.some(function(p) {
                        return (p.type === 7 ? p.rawName : p.name) === name;
                    })) {
                        emitError(2, start);
                    }
                },
                onattribend: function onattribend(quote, end) {
                    if (currentOpenTag && currentProp) {
                        setLocEnd(currentProp.loc, end);
                        if (quote !== 0) {
                            if (currentProp.type === 6) {
                                if (currentProp.name === "class") {
                                    currentAttrValue = condense(currentAttrValue).trim();
                                }
                                if (quote === 1 && !currentAttrValue) {
                                    emitError(13, end);
                                }
                                currentProp.value = {
                                    type: 2,
                                    content: currentAttrValue,
                                    loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
                                };
                                if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                                    tokenizer.enterRCDATA(toCharCodes("</template"), 0);
                                }
                            } else {
                                var expParseMode = 0;
                                {
                                    if (currentProp.name === "for") {
                                        expParseMode = 3;
                                    } else if (currentProp.name === "slot") {
                                        expParseMode = 1;
                                    } else if (currentProp.name === "on" && currentAttrValue.includes(";")) {
                                        expParseMode = 2;
                                    }
                                }
                                currentProp.exp = createExp(currentAttrValue, false, getLoc(currentAttrStartIndex, currentAttrEndIndex), 0, expParseMode);
                                if (currentProp.name === "for") {
                                    currentProp.forParseResult = parseForExpression(currentProp.exp);
                                }
                                var syncIndex = -1;
                                if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(function(mod) {
                                    return mod.content === "sync";
                                })) > -1 && checkCompatEnabled("COMPILER_V_BIND_SYNC", currentOptions, currentProp.loc, currentProp.rawName)) {
                                    currentProp.name = "model";
                                    currentProp.modifiers.splice(syncIndex, 1);
                                }
                            }
                        }
                        if (currentProp.type !== 7 || currentProp.name !== "pre") {
                            currentOpenTag.props.push(currentProp);
                        }
                    }
                    currentAttrValue = "";
                    currentAttrStartIndex = currentAttrEndIndex = -1;
                },
                oncomment: function oncomment(start, end) {
                    if (currentOptions.comments) {
                        addNode({
                            type: 3,
                            content: getSlice(start, end),
                            loc: getLoc(start - 4, end + 3)
                        });
                    }
                },
                onend: function onend() {
                    var end = currentInput.length;
                    if (tokenizer.state !== 1) {
                        switch(tokenizer.state){
                            case 5:
                            case 8:
                                emitError(5, end);
                                break;
                            case 3:
                            case 4:
                                emitError(25, tokenizer.sectionStart);
                                break;
                            case 28:
                                if (tokenizer.currentSequence === Sequences.CdataEnd) {
                                    emitError(6, end);
                                } else {
                                    emitError(7, end);
                                }
                                break;
                            case 6:
                            case 7:
                            case 9:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            // "
                            case 20:
                            // '
                            case 21:
                                emitError(9, end);
                                break;
                        }
                    }
                    for(var index = 0; index < stack.length; index++){
                        onCloseTag(stack[index], end - 1);
                        emitError(24, stack[index].loc.start.offset);
                    }
                },
                oncdata: function oncdata(start, end) {
                    if (stack[0].ns !== 0) {
                        onText(getSlice(start, end), start, end);
                    } else {
                        emitError(1, start - 9);
                    }
                },
                onprocessinginstruction: function onprocessinginstruction(start) {
                    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
                        emitError(21, start - 1);
                    }
                }
            });
            var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
            var stripParensRE = /^\(|\)$/g;
            function parseForExpression(input) {
                var loc = input.loc;
                var exp = input.content;
                var inMatch = exp.match(forAliasRE);
                if (!inMatch) return;
                var _inMatch = _sliced_to_array(inMatch, 3), LHS = _inMatch[1], RHS = _inMatch[2];
                var createAliasExpression = function(content, offset) {
                    var asParam = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var start = loc.start.offset + offset;
                    var end = start + content.length;
                    return createExp(content, false, getLoc(start, end), 0, asParam ? 1 : 0);
                };
                var result = {
                    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
                    value: void 0,
                    key: void 0,
                    index: void 0,
                    finalized: false
                };
                var valueContent = LHS.trim().replace(stripParensRE, "").trim();
                var trimmedOffset = LHS.indexOf(valueContent);
                var iteratorMatch = valueContent.match(forIteratorRE);
                if (iteratorMatch) {
                    valueContent = valueContent.replace(forIteratorRE, "").trim();
                    var keyContent = iteratorMatch[1].trim();
                    var keyOffset;
                    if (keyContent) {
                        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
                        result.key = createAliasExpression(keyContent, keyOffset, true);
                    }
                    if (iteratorMatch[2]) {
                        var indexContent = iteratorMatch[2].trim();
                        if (indexContent) {
                            result.index = createAliasExpression(indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length), true);
                        }
                    }
                }
                if (valueContent) {
                    result.value = createAliasExpression(valueContent, trimmedOffset, true);
                }
                return result;
            }
            function getSlice(start, end) {
                return currentInput.slice(start, end);
            }
            function endOpenTag(end) {
                if (tokenizer.inSFCRoot) {
                    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
                }
                addNode(currentOpenTag);
                var tag = currentOpenTag.tag, ns = currentOpenTag.ns;
                if (ns === 0 && currentOptions.isPreTag(tag)) {
                    inPre++;
                }
                if (currentOptions.isVoidTag(tag)) {
                    onCloseTag(currentOpenTag, end);
                } else {
                    stack.unshift(currentOpenTag);
                    if (ns === 1 || ns === 2) {
                        tokenizer.inXML = true;
                    }
                }
                currentOpenTag = null;
            }
            function onText(content, start, end) {
                var parent = stack[0] || currentRoot;
                var lastNode = parent.children[parent.children.length - 1];
                if (lastNode && lastNode.type === 2) {
                    lastNode.content += content;
                    setLocEnd(lastNode.loc, end);
                } else {
                    parent.children.push({
                        type: 2,
                        content: content,
                        loc: getLoc(start, end)
                    });
                }
            }
            function onCloseTag(el, end) {
                var isImplied = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (isImplied) {
                    setLocEnd(el.loc, backTrack(end, 60));
                } else {
                    setLocEnd(el.loc, lookAhead(end, 62) + 1);
                }
                if (tokenizer.inSFCRoot) {
                    if (el.children.length) {
                        el.innerLoc.end = shared.extend({}, el.children[el.children.length - 1].loc.end);
                    } else {
                        el.innerLoc.end = shared.extend({}, el.innerLoc.start);
                    }
                    el.innerLoc.source = getSlice(el.innerLoc.start.offset, el.innerLoc.end.offset);
                }
                var tag = el.tag, ns = el.ns, children = el.children;
                if (!inVPre) {
                    if (tag === "slot") {
                        el.tagType = 2;
                    } else if (isFragmentTemplate(el)) {
                        el.tagType = 3;
                    } else if (isComponent(el)) {
                        el.tagType = 1;
                    }
                }
                if (!tokenizer.inRCDATA) {
                    el.children = condenseWhitespace(children);
                }
                if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
                    var first = children[0];
                    if (first && first.type === 2) {
                        first.content = first.content.replace(/^\r?\n/, "");
                    }
                }
                if (ns === 0 && currentOptions.isPreTag(tag)) {
                    inPre--;
                }
                if (currentVPreBoundary === el) {
                    inVPre = tokenizer.inVPre = false;
                    currentVPreBoundary = null;
                }
                if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
                    tokenizer.inXML = false;
                }
                {
                    var props = el.props;
                    if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", currentOptions)) {
                        var hasIf = false;
                        var hasFor = false;
                        for(var i = 0; i < props.length; i++){
                            var p = props[i];
                            if (p.type === 7) {
                                if (p.name === "if") {
                                    hasIf = true;
                                } else if (p.name === "for") {
                                    hasFor = true;
                                }
                            }
                            if (hasIf && hasFor) {
                                warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", currentOptions, el.loc);
                                break;
                            }
                        }
                    }
                    if (!tokenizer.inSFCRoot && isCompatEnabled("COMPILER_NATIVE_TEMPLATE", currentOptions) && el.tag === "template" && !isFragmentTemplate(el)) {
                        var _parent_children;
                        warnDeprecation("COMPILER_NATIVE_TEMPLATE", currentOptions, el.loc);
                        var parent = stack[0] || currentRoot;
                        var index = parent.children.indexOf(el);
                        (_parent_children = parent.children).splice.apply(_parent_children, [
                            index,
                            1
                        ].concat(_to_consumable_array(el.children)));
                    }
                    var inlineTemplateProp = props.find(function(p) {
                        return p.type === 6 && p.name === "inline-template";
                    });
                    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", currentOptions, inlineTemplateProp.loc) && el.children.length) {
                        inlineTemplateProp.value = {
                            type: 2,
                            content: getSlice(el.children[0].loc.start.offset, el.children[el.children.length - 1].loc.end.offset),
                            loc: inlineTemplateProp.loc
                        };
                    }
                }
            }
            function lookAhead(index, c) {
                var i = index;
                while(currentInput.charCodeAt(i) !== c && i < currentInput.length - 1)i++;
                return i;
            }
            function backTrack(index, c) {
                var i = index;
                while(currentInput.charCodeAt(i) !== c && i >= 0)i--;
                return i;
            }
            var specialTemplateDir = /* @__PURE__ */ new Set([
                "if",
                "else",
                "else-if",
                "for",
                "slot"
            ]);
            function isFragmentTemplate(param) {
                var tag = param.tag, props = param.props;
                if (tag === "template") {
                    for(var i = 0; i < props.length; i++){
                        if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function isComponent(param) {
                var tag = param.tag, props = param.props;
                if (currentOptions.isCustomElement(tag)) {
                    return false;
                }
                if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
                    return true;
                }
                for(var i = 0; i < props.length; i++){
                    var p = props[i];
                    if (p.type === 6) {
                        if (p.name === "is" && p.value) {
                            if (p.value.content.startsWith("vue:")) {
                                return true;
                            } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) {
                                return true;
                            }
                        }
                    } else if (// :is on plain element - only treat as component in compat mode
                    p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", currentOptions, p.loc)) {
                        return true;
                    }
                }
                return false;
            }
            function isUpperCase(c) {
                return c > 64 && c < 91;
            }
            var windowsNewlineRE = /\r\n/g;
            function condenseWhitespace(nodes, tag) {
                var shouldCondense = currentOptions.whitespace !== "preserve";
                var removedWhitespace = false;
                for(var i = 0; i < nodes.length; i++){
                    var node = nodes[i];
                    if (node.type === 2) {
                        if (!inPre) {
                            if (isAllWhitespace(node.content)) {
                                var prev = nodes[i - 1] && nodes[i - 1].type;
                                var next = nodes[i + 1] && nodes[i + 1].type;
                                if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
                                    removedWhitespace = true;
                                    nodes[i] = null;
                                } else {
                                    node.content = " ";
                                }
                            } else if (shouldCondense) {
                                node.content = condense(node.content);
                            }
                        } else {
                            node.content = node.content.replace(windowsNewlineRE, "\n");
                        }
                    }
                }
                return removedWhitespace ? nodes.filter(Boolean) : nodes;
            }
            function isAllWhitespace(str) {
                for(var i = 0; i < str.length; i++){
                    if (!isWhitespace(str.charCodeAt(i))) {
                        return false;
                    }
                }
                return true;
            }
            function hasNewlineChar(str) {
                for(var i = 0; i < str.length; i++){
                    var c = str.charCodeAt(i);
                    if (c === 10 || c === 13) {
                        return true;
                    }
                }
                return false;
            }
            function condense(str) {
                var ret = "";
                var prevCharIsWhitespace = false;
                for(var i = 0; i < str.length; i++){
                    if (isWhitespace(str.charCodeAt(i))) {
                        if (!prevCharIsWhitespace) {
                            ret += " ";
                            prevCharIsWhitespace = true;
                        }
                    } else {
                        ret += str[i];
                        prevCharIsWhitespace = false;
                    }
                }
                return ret;
            }
            function addNode(node) {
                (stack[0] || currentRoot).children.push(node);
            }
            function getLoc(start, end) {
                return {
                    start: tokenizer.getPos(start),
                    // @ts-expect-error allow late attachment
                    end: end == null ? end : tokenizer.getPos(end),
                    // @ts-expect-error allow late attachment
                    source: end == null ? end : getSlice(start, end)
                };
            }
            function cloneLoc(loc) {
                return getLoc(loc.start.offset, loc.end.offset);
            }
            function setLocEnd(loc, end) {
                loc.end = tokenizer.getPos(end);
                loc.source = getSlice(loc.start.offset, end);
            }
            function dirToAttr(dir) {
                var attr = {
                    type: 6,
                    name: dir.rawName,
                    nameLoc: getLoc(dir.loc.start.offset, dir.loc.start.offset + dir.rawName.length),
                    value: void 0,
                    loc: dir.loc
                };
                if (dir.exp) {
                    var loc = dir.exp.loc;
                    if (loc.end.offset < dir.loc.end.offset) {
                        loc.start.offset--;
                        loc.start.column--;
                        loc.end.offset++;
                        loc.end.column++;
                    }
                    attr.value = {
                        type: 2,
                        content: dir.exp.content,
                        loc: loc
                    };
                }
                return attr;
            }
            function createExp(content) {
                var isStatic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, loc = arguments.length > 2 ? arguments[2] : void 0, constType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, parseMode = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
                var exp = createSimpleExpression(content, isStatic, loc, constType);
                if (!isStatic && currentOptions.prefixIdentifiers && parseMode !== 3 && content.trim()) {
                    if (isSimpleIdentifier(content)) {
                        exp.ast = null;
                        return exp;
                    }
                    try {
                        var plugins = currentOptions.expressionPlugins;
                        var options = {
                            plugins: plugins ? _to_consumable_array(plugins).concat([
                                "typescript"
                            ]) : [
                                "typescript"
                            ]
                        };
                        if (parseMode === 2) {
                            exp.ast = parser.parse(" ".concat(content, " "), options).program;
                        } else if (parseMode === 1) {
                            exp.ast = parser.parseExpression("(".concat(content, ")=>{}"), options);
                        } else {
                            exp.ast = parser.parseExpression("(".concat(content, ")"), options);
                        }
                    } catch (e) {
                        exp.ast = false;
                        emitError(45, loc.start.offset, e.message);
                    }
                }
                return exp;
            }
            function emitError(code, index, message) {
                currentOptions.onError(createCompilerError(code, getLoc(index, index), void 0, message));
            }
            function reset() {
                tokenizer.reset();
                currentOpenTag = null;
                currentProp = null;
                currentAttrValue = "";
                currentAttrStartIndex = -1;
                currentAttrEndIndex = -1;
                stack.length = 0;
            }
            function baseParse(input, options) {
                reset();
                currentInput = input;
                currentOptions = shared.extend({}, defaultParserOptions);
                if (options) {
                    var key;
                    for(key in options){
                        if (options[key] != null) {
                            currentOptions[key] = options[key];
                        }
                    }
                }
                {
                    if (currentOptions.decodeEntities) {
                        console.warn("[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds.");
                    }
                }
                tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
                tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
                var delimiters = options && options.delimiters;
                if (delimiters) {
                    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
                    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
                }
                var root = currentRoot = createRoot([], input);
                tokenizer.parse(currentInput);
                root.loc = getLoc(0, input.length);
                root.children = condenseWhitespace(root.children);
                currentRoot = null;
                return root;
            }
            function cacheStatic(root, context) {
                walk(root, void 0, context, // Root node is unfortunately non-hoistable due to potential parent
                // fallthrough attributes.
                isSingleElementRoot(root, root.children[0]));
            }
            function isSingleElementRoot(root, child) {
                var children = root.children;
                return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
            }
            function walk(node, parent, context) {
                var doNotHoistNode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, inFor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                var children = node.children;
                var toCache = [];
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    if (child.type === 1 && child.tagType === 0) {
                        var constantType = doNotHoistNode ? 0 : getConstantType(child, context);
                        if (constantType > 0) {
                            if (constantType >= 2) {
                                child.codegenNode.patchFlag = -1;
                                toCache.push(child);
                                continue;
                            }
                        } else {
                            var codegenNode = child.codegenNode;
                            if (codegenNode.type === 13) {
                                var flag = codegenNode.patchFlag;
                                if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                                    var props = getNodeProps(child);
                                    if (props) {
                                        codegenNode.props = context.hoist(props);
                                    }
                                }
                                if (codegenNode.dynamicProps) {
                                    codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                                }
                            }
                        }
                    } else if (child.type === 12) {
                        var constantType1 = doNotHoistNode ? 0 : getConstantType(child, context);
                        if (constantType1 >= 2) {
                            toCache.push(child);
                            continue;
                        }
                    }
                    if (child.type === 1) {
                        var isComponent2 = child.tagType === 1;
                        if (isComponent2) {
                            context.scopes.vSlot++;
                        }
                        walk(child, node, context, false, inFor);
                        if (isComponent2) {
                            context.scopes.vSlot--;
                        }
                    } else if (child.type === 11) {
                        walk(child, node, context, child.children.length === 1, true);
                    } else if (child.type === 9) {
                        for(var i2 = 0; i2 < child.branches.length; i2++){
                            walk(child.branches[i2], node, context, child.branches[i2].children.length === 1, inFor);
                        }
                    }
                }
                var cachedAsArray = false;
                if (toCache.length === children.length && node.type === 1) {
                    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
                        node.codegenNode.children = getCacheExpression(createArrayExpression(node.codegenNode.children));
                        cachedAsArray = true;
                    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !shared.isArray(node.codegenNode.children) && node.codegenNode.children.type === 15) {
                        var slot = getSlotNode(node.codegenNode, "default");
                        if (slot) {
                            slot.returns = getCacheExpression(createArrayExpression(slot.returns));
                            cachedAsArray = true;
                        }
                    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !shared.isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
                        var slotName = findDir(node, "slot", true);
                        var slot1 = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
                        if (slot1) {
                            slot1.returns = getCacheExpression(createArrayExpression(slot1.returns));
                            cachedAsArray = true;
                        }
                    }
                }
                if (!cachedAsArray) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = toCache[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var child1 = _step.value;
                            child1.codegenNode = context.cache(child1.codegenNode);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                function getCacheExpression(value) {
                    var exp = context.cache(value);
                    if (inFor && context.hmr) {
                        exp.needArraySpread = true;
                    }
                    return exp;
                }
                function getSlotNode(node2, name) {
                    if (node2.children && !shared.isArray(node2.children) && node2.children.type === 15) {
                        var slot = node2.children.properties.find(function(p) {
                            return p.key === name || p.key.content === name;
                        });
                        return slot && slot.value;
                    }
                }
                if (toCache.length && context.transformHoist) {
                    context.transformHoist(children, context, node);
                }
            }
            function getConstantType(node, context) {
                var constantCache = context.constantCache;
                switch(node.type){
                    case 1:
                        if (node.tagType !== 0) {
                            return 0;
                        }
                        var cached = constantCache.get(node);
                        if (cached !== void 0) {
                            return cached;
                        }
                        var codegenNode = node.codegenNode;
                        if (codegenNode.type !== 13) {
                            return 0;
                        }
                        if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
                            return 0;
                        }
                        if (codegenNode.patchFlag === void 0) {
                            var returnType2 = 3;
                            var generatedPropsType = getGeneratedPropsConstantType(node, context);
                            if (generatedPropsType === 0) {
                                constantCache.set(node, 0);
                                return 0;
                            }
                            if (generatedPropsType < returnType2) {
                                returnType2 = generatedPropsType;
                            }
                            for(var i = 0; i < node.children.length; i++){
                                var childType = getConstantType(node.children[i], context);
                                if (childType === 0) {
                                    constantCache.set(node, 0);
                                    return 0;
                                }
                                if (childType < returnType2) {
                                    returnType2 = childType;
                                }
                            }
                            if (returnType2 > 1) {
                                for(var i1 = 0; i1 < node.props.length; i1++){
                                    var p = node.props[i1];
                                    if (p.type === 7 && p.name === "bind" && p.exp) {
                                        var expType = getConstantType(p.exp, context);
                                        if (expType === 0) {
                                            constantCache.set(node, 0);
                                            return 0;
                                        }
                                        if (expType < returnType2) {
                                            returnType2 = expType;
                                        }
                                    }
                                }
                            }
                            if (codegenNode.isBlock) {
                                for(var i2 = 0; i2 < node.props.length; i2++){
                                    var p1 = node.props[i2];
                                    if (p1.type === 7) {
                                        constantCache.set(node, 0);
                                        return 0;
                                    }
                                }
                                context.removeHelper(OPEN_BLOCK);
                                context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                                codegenNode.isBlock = false;
                                context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                            }
                            constantCache.set(node, returnType2);
                            return returnType2;
                        } else {
                            constantCache.set(node, 0);
                            return 0;
                        }
                    case 2:
                    case 3:
                        return 3;
                    case 9:
                    case 11:
                    case 10:
                        return 0;
                    case 5:
                    case 12:
                        return getConstantType(node.content, context);
                    case 4:
                        return node.constType;
                    case 8:
                        var returnType = 3;
                        for(var i3 = 0; i3 < node.children.length; i3++){
                            var child = node.children[i3];
                            if (shared.isString(child) || shared.isSymbol(child)) {
                                continue;
                            }
                            var childType1 = getConstantType(child, context);
                            if (childType1 === 0) {
                                return 0;
                            } else if (childType1 < returnType) {
                                returnType = childType1;
                            }
                        }
                        return returnType;
                    case 20:
                        return 2;
                    default:
                        return 0;
                }
            }
            var allowHoistedHelperSet = /* @__PURE__ */ new Set([
                NORMALIZE_CLASS,
                NORMALIZE_STYLE,
                NORMALIZE_PROPS,
                GUARD_REACTIVE_PROPS
            ]);
            function getConstantTypeOfHelperCall(value, context) {
                if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
                    var arg = value.arguments[0];
                    if (arg.type === 4) {
                        return getConstantType(arg, context);
                    } else if (arg.type === 14) {
                        return getConstantTypeOfHelperCall(arg, context);
                    }
                }
                return 0;
            }
            function getGeneratedPropsConstantType(node, context) {
                var returnType = 3;
                var props = getNodeProps(node);
                if (props && props.type === 15) {
                    var properties = props.properties;
                    for(var i = 0; i < properties.length; i++){
                        var _properties_i = properties[i], key = _properties_i.key, value = _properties_i.value;
                        var keyType = getConstantType(key, context);
                        if (keyType === 0) {
                            return keyType;
                        }
                        if (keyType < returnType) {
                            returnType = keyType;
                        }
                        var valueType = void 0;
                        if (value.type === 4) {
                            valueType = getConstantType(value, context);
                        } else if (value.type === 14) {
                            valueType = getConstantTypeOfHelperCall(value, context);
                        } else {
                            valueType = 0;
                        }
                        if (valueType === 0) {
                            return valueType;
                        }
                        if (valueType < returnType) {
                            returnType = valueType;
                        }
                    }
                }
                return returnType;
            }
            function getNodeProps(node) {
                var codegenNode = node.codegenNode;
                if (codegenNode.type === 13) {
                    return codegenNode.props;
                }
            }
            function createTransformContext(root, param) {
                var _param_filename = param.filename, filename = _param_filename === void 0 ? "" : _param_filename, _param_prefixIdentifiers = param.prefixIdentifiers, prefixIdentifiers = _param_prefixIdentifiers === void 0 ? false : _param_prefixIdentifiers, _param_hoistStatic = param.hoistStatic, hoistStatic = _param_hoistStatic === void 0 ? false : _param_hoistStatic, _param_hmr = param.hmr, hmr = _param_hmr === void 0 ? false : _param_hmr, _param_cacheHandlers = param.cacheHandlers, cacheHandlers = _param_cacheHandlers === void 0 ? false : _param_cacheHandlers, _param_nodeTransforms = param.nodeTransforms, nodeTransforms = _param_nodeTransforms === void 0 ? [] : _param_nodeTransforms, _param_directiveTransforms = param.directiveTransforms, directiveTransforms = _param_directiveTransforms === void 0 ? {} : _param_directiveTransforms, _param_transformHoist = param.transformHoist, transformHoist = _param_transformHoist === void 0 ? null : _param_transformHoist, _param_isBuiltInComponent = param.isBuiltInComponent, isBuiltInComponent = _param_isBuiltInComponent === void 0 ? shared.NOOP : _param_isBuiltInComponent, _param_isCustomElement = param.isCustomElement, isCustomElement = _param_isCustomElement === void 0 ? shared.NOOP : _param_isCustomElement, _param_expressionPlugins = param.expressionPlugins, expressionPlugins = _param_expressionPlugins === void 0 ? [] : _param_expressionPlugins, _param_scopeId = param.scopeId, scopeId = _param_scopeId === void 0 ? null : _param_scopeId, _param_slotted = param.slotted, slotted = _param_slotted === void 0 ? true : _param_slotted, _param_ssr = param.ssr, ssr = _param_ssr === void 0 ? false : _param_ssr, _param_inSSR = param.inSSR, inSSR = _param_inSSR === void 0 ? false : _param_inSSR, _param_ssrCssVars = param.ssrCssVars, ssrCssVars = _param_ssrCssVars === void 0 ? "" : _param_ssrCssVars, _param_bindingMetadata = param.bindingMetadata, bindingMetadata = _param_bindingMetadata === void 0 ? shared.EMPTY_OBJ : _param_bindingMetadata, _param_inline = param.inline, inline = _param_inline === void 0 ? false : _param_inline, _param_isTS = param.isTS, isTS = _param_isTS === void 0 ? false : _param_isTS, _param_onError = param.onError, onError = _param_onError === void 0 ? defaultOnError : _param_onError, _param_onWarn = param.onWarn, onWarn = _param_onWarn === void 0 ? defaultOnWarn : _param_onWarn, compatConfig = param.compatConfig;
                var nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
                var context = {
                    // options
                    filename: filename,
                    selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
                    prefixIdentifiers: prefixIdentifiers,
                    hoistStatic: hoistStatic,
                    hmr: hmr,
                    cacheHandlers: cacheHandlers,
                    nodeTransforms: nodeTransforms,
                    directiveTransforms: directiveTransforms,
                    transformHoist: transformHoist,
                    isBuiltInComponent: isBuiltInComponent,
                    isCustomElement: isCustomElement,
                    expressionPlugins: expressionPlugins,
                    scopeId: scopeId,
                    slotted: slotted,
                    ssr: ssr,
                    inSSR: inSSR,
                    ssrCssVars: ssrCssVars,
                    bindingMetadata: bindingMetadata,
                    inline: inline,
                    isTS: isTS,
                    onError: onError,
                    onWarn: onWarn,
                    compatConfig: compatConfig,
                    // state
                    root: root,
                    helpers: /* @__PURE__ */ new Map(),
                    components: /* @__PURE__ */ new Set(),
                    directives: /* @__PURE__ */ new Set(),
                    hoists: [],
                    imports: [],
                    cached: [],
                    constantCache: /* @__PURE__ */ new WeakMap(),
                    temps: 0,
                    identifiers: /* @__PURE__ */ Object.create(null),
                    scopes: {
                        vFor: 0,
                        vSlot: 0,
                        vPre: 0,
                        vOnce: 0
                    },
                    parent: null,
                    grandParent: null,
                    currentNode: root,
                    childIndex: 0,
                    inVOnce: false,
                    // methods
                    helper: function helper(name) {
                        var count = context.helpers.get(name) || 0;
                        context.helpers.set(name, count + 1);
                        return name;
                    },
                    removeHelper: function removeHelper(name) {
                        var count = context.helpers.get(name);
                        if (count) {
                            var currentCount = count - 1;
                            if (!currentCount) {
                                context.helpers.delete(name);
                            } else {
                                context.helpers.set(name, currentCount);
                            }
                        }
                    },
                    helperString: function helperString(name) {
                        return "_".concat(helperNameMap[context.helper(name)]);
                    },
                    replaceNode: function replaceNode(node) {
                        {
                            if (!context.currentNode) {
                                throw new Error("Node being replaced is already removed.");
                            }
                            if (!context.parent) {
                                throw new Error("Cannot replace root node.");
                            }
                        }
                        context.parent.children[context.childIndex] = context.currentNode = node;
                    },
                    removeNode: function removeNode(node) {
                        if (!context.parent) {
                            throw new Error("Cannot remove root node.");
                        }
                        var list = context.parent.children;
                        var removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
                        if (removalIndex < 0) {
                            throw new Error("node being removed is not a child of current parent");
                        }
                        if (!node || node === context.currentNode) {
                            context.currentNode = null;
                            context.onNodeRemoved();
                        } else {
                            if (context.childIndex > removalIndex) {
                                context.childIndex--;
                                context.onNodeRemoved();
                            }
                        }
                        context.parent.children.splice(removalIndex, 1);
                    },
                    onNodeRemoved: shared.NOOP,
                    addIdentifiers: function addIdentifiers(exp) {
                        {
                            if (shared.isString(exp)) {
                                addId(exp);
                            } else if (exp.identifiers) {
                                exp.identifiers.forEach(addId);
                            } else if (exp.type === 4) {
                                addId(exp.content);
                            }
                        }
                    },
                    removeIdentifiers: function removeIdentifiers(exp) {
                        {
                            if (shared.isString(exp)) {
                                removeId(exp);
                            } else if (exp.identifiers) {
                                exp.identifiers.forEach(removeId);
                            } else if (exp.type === 4) {
                                removeId(exp.content);
                            }
                        }
                    },
                    hoist: function hoist(exp) {
                        if (shared.isString(exp)) exp = createSimpleExpression(exp);
                        context.hoists.push(exp);
                        var identifier = createSimpleExpression("_hoisted_".concat(context.hoists.length), false, exp.loc, 2);
                        identifier.hoisted = exp;
                        return identifier;
                    },
                    cache: function cache(exp) {
                        var isVNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, inVOnce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                        var cacheExp = createCacheExpression(context.cached.length, exp, isVNode, inVOnce);
                        context.cached.push(cacheExp);
                        return cacheExp;
                    }
                };
                {
                    context.filters = /* @__PURE__ */ new Set();
                }
                function addId(id) {
                    var identifiers = context.identifiers;
                    if (identifiers[id] === void 0) {
                        identifiers[id] = 0;
                    }
                    identifiers[id]++;
                }
                function removeId(id) {
                    context.identifiers[id]--;
                }
                return context;
            }
            function transform(root, options) {
                var context = createTransformContext(root, options);
                traverseNode(root, context);
                if (options.hoistStatic) {
                    cacheStatic(root, context);
                }
                if (!options.ssr) {
                    createRootCodegen(root, context);
                }
                root.helpers = /* @__PURE__ */ new Set(_to_consumable_array(context.helpers.keys()));
                root.components = _to_consumable_array(context.components);
                root.directives = _to_consumable_array(context.directives);
                root.imports = context.imports;
                root.hoists = context.hoists;
                root.temps = context.temps;
                root.cached = context.cached;
                root.transformed = true;
                {
                    root.filters = _to_consumable_array(context.filters);
                }
            }
            function createRootCodegen(root, context) {
                var helper = context.helper;
                var children = root.children;
                if (children.length === 1) {
                    var child = children[0];
                    if (isSingleElementRoot(root, child) && child.codegenNode) {
                        var codegenNode = child.codegenNode;
                        if (codegenNode.type === 13) {
                            convertToBlock(codegenNode, context);
                        }
                        root.codegenNode = codegenNode;
                    } else {
                        root.codegenNode = child;
                    }
                } else if (children.length > 1) {
                    var patchFlag = 64;
                    if (children.filter(function(c) {
                        return c.type !== 3;
                    }).length === 1) {
                        patchFlag |= 2048;
                    }
                    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag, void 0, void 0, true, void 0, false);
                } else ;
            }
            function traverseChildren(parent, context) {
                var i = 0;
                var nodeRemoved = function() {
                    i--;
                };
                for(; i < parent.children.length; i++){
                    var child = parent.children[i];
                    if (shared.isString(child)) continue;
                    context.grandParent = context.parent;
                    context.parent = parent;
                    context.childIndex = i;
                    context.onNodeRemoved = nodeRemoved;
                    traverseNode(child, context);
                }
            }
            function traverseNode(node, context) {
                context.currentNode = node;
                var nodeTransforms = context.nodeTransforms;
                var exitFns = [];
                for(var i2 = 0; i2 < nodeTransforms.length; i2++){
                    var onExit = nodeTransforms[i2](node, context);
                    if (onExit) {
                        if (shared.isArray(onExit)) {
                            var _exitFns;
                            (_exitFns = exitFns).push.apply(_exitFns, _to_consumable_array(onExit));
                        } else {
                            exitFns.push(onExit);
                        }
                    }
                    if (!context.currentNode) {
                        return;
                    } else {
                        node = context.currentNode;
                    }
                }
                switch(node.type){
                    case 3:
                        if (!context.ssr) {
                            context.helper(CREATE_COMMENT);
                        }
                        break;
                    case 5:
                        if (!context.ssr) {
                            context.helper(TO_DISPLAY_STRING);
                        }
                        break;
                    // for container types, further traverse downwards
                    case 9:
                        for(var i21 = 0; i21 < node.branches.length; i21++){
                            traverseNode(node.branches[i21], context);
                        }
                        break;
                    case 10:
                    case 11:
                    case 1:
                    case 0:
                        traverseChildren(node, context);
                        break;
                }
                context.currentNode = node;
                var i = exitFns.length;
                while(i--){
                    exitFns[i]();
                }
            }
            function createStructuralDirectiveTransform(name, fn) {
                var matches = shared.isString(name) ? function(n) {
                    return n === name;
                } : function(n) {
                    return name.test(n);
                };
                return function(node, context) {
                    if (node.type === 1) {
                        var props = node.props;
                        if (node.tagType === 3 && props.some(isVSlot)) {
                            return;
                        }
                        var exitFns = [];
                        for(var i = 0; i < props.length; i++){
                            var prop = props[i];
                            if (prop.type === 7 && matches(prop.name)) {
                                props.splice(i, 1);
                                i--;
                                var onExit = fn(node, prop, context);
                                if (onExit) exitFns.push(onExit);
                            }
                        }
                        return exitFns;
                    }
                };
            }
            var PURE_ANNOTATION = "/*@__PURE__*/";
            var aliasHelper = function(s) {
                return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
            };
            function createCodegenContext(ast, param) {
                var _param_mode = param.mode, mode = _param_mode === void 0 ? "function" : _param_mode, _param_prefixIdentifiers = param.prefixIdentifiers, prefixIdentifiers = _param_prefixIdentifiers === void 0 ? mode === "module" : _param_prefixIdentifiers, _param_sourceMap = param.sourceMap, sourceMap = _param_sourceMap === void 0 ? false : _param_sourceMap, _param_filename = param.filename, filename = _param_filename === void 0 ? "template.vue.html" : _param_filename, _param_scopeId = param.scopeId, scopeId = _param_scopeId === void 0 ? null : _param_scopeId, _param_optimizeImports = param.optimizeImports, optimizeImports = _param_optimizeImports === void 0 ? false : _param_optimizeImports, _param_runtimeGlobalName = param.runtimeGlobalName, runtimeGlobalName = _param_runtimeGlobalName === void 0 ? "Vue" : _param_runtimeGlobalName, _param_runtimeModuleName = param.runtimeModuleName, runtimeModuleName = _param_runtimeModuleName === void 0 ? "vue" : _param_runtimeModuleName, _param_ssrRuntimeModuleName = param.ssrRuntimeModuleName, ssrRuntimeModuleName = _param_ssrRuntimeModuleName === void 0 ? "vue/server-renderer" : _param_ssrRuntimeModuleName, _param_ssr = param.ssr, ssr = _param_ssr === void 0 ? false : _param_ssr, _param_isTS = param.isTS, isTS = _param_isTS === void 0 ? false : _param_isTS, _param_inSSR = param.inSSR, inSSR = _param_inSSR === void 0 ? false : _param_inSSR;
                var context = {
                    mode: mode,
                    prefixIdentifiers: prefixIdentifiers,
                    sourceMap: sourceMap,
                    filename: filename,
                    scopeId: scopeId,
                    optimizeImports: optimizeImports,
                    runtimeGlobalName: runtimeGlobalName,
                    runtimeModuleName: runtimeModuleName,
                    ssrRuntimeModuleName: ssrRuntimeModuleName,
                    ssr: ssr,
                    isTS: isTS,
                    inSSR: inSSR,
                    source: ast.source,
                    code: "",
                    column: 1,
                    line: 1,
                    offset: 0,
                    indentLevel: 0,
                    pure: false,
                    map: void 0,
                    helper: function helper(key) {
                        return "_".concat(helperNameMap[key]);
                    },
                    push: function push(code) {
                        var newlineIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -2, node = arguments.length > 2 ? arguments[2] : void 0;
                        context.code += code;
                        if (context.map) {
                            if (node) {
                                var name;
                                if (node.type === 4 && !node.isStatic) {
                                    var content = node.content.replace(/^_ctx\./, "");
                                    if (content !== node.content && isSimpleIdentifier(content)) {
                                        name = content;
                                    }
                                }
                                addMapping(node.loc.start, name);
                            }
                            if (newlineIndex === -3) {
                                advancePositionWithMutation(context, code);
                            } else {
                                context.offset += code.length;
                                if (newlineIndex === -2) {
                                    context.column += code.length;
                                } else {
                                    if (newlineIndex === -1) {
                                        newlineIndex = code.length - 1;
                                    }
                                    context.line++;
                                    context.column = code.length - newlineIndex;
                                }
                            }
                            if (node && node.loc !== locStub) {
                                addMapping(node.loc.end);
                            }
                        }
                    },
                    indent: function indent() {
                        newline(++context.indentLevel);
                    },
                    deindent: function deindent() {
                        var withoutNewLine = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                        if (withoutNewLine) {
                            --context.indentLevel;
                        } else {
                            newline(--context.indentLevel);
                        }
                    },
                    newline: function newline1() {
                        newline(context.indentLevel);
                    }
                };
                function newline(n) {
                    context.push("\n" + "  ".repeat(n), 0);
                }
                function addMapping(loc) {
                    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    var _context_map = context.map, _names = _context_map._names, _mappings = _context_map._mappings;
                    if (name !== null && !_names.has(name)) _names.add(name);
                    _mappings.add({
                        originalLine: loc.line,
                        originalColumn: loc.column - 1,
                        // source-map column is 0 based
                        generatedLine: context.line,
                        generatedColumn: context.column - 1,
                        source: filename,
                        name: name
                    });
                }
                if (sourceMap) {
                    context.map = new sourceMapJs.SourceMapGenerator();
                    context.map.setSourceContent(filename, context.source);
                    context.map._sources.add(filename);
                }
                return context;
            }
            function generate(ast) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var context = createCodegenContext(ast, options);
                if (options.onContextCreated) options.onContextCreated(context);
                var mode = context.mode, push = context.push, prefixIdentifiers = context.prefixIdentifiers, indent = context.indent, deindent = context.deindent, newline = context.newline, scopeId = context.scopeId, ssr = context.ssr;
                var helpers = Array.from(ast.helpers);
                var hasHelpers = helpers.length > 0;
                var useWithBlock = !prefixIdentifiers && mode !== "module";
                var genScopeId = scopeId != null && mode === "module";
                var isSetupInlined = !!options.inline;
                var preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
                if (mode === "module") {
                    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
                } else {
                    genFunctionPreamble(ast, preambleContext);
                }
                var functionName = ssr ? "ssrRender" : "render";
                var args = ssr ? [
                    "_ctx",
                    "_push",
                    "_parent",
                    "_attrs"
                ] : [
                    "_ctx",
                    "_cache"
                ];
                if (options.bindingMetadata && !options.inline) {
                    args.push("$props", "$setup", "$data", "$options");
                }
                var signature = options.isTS ? args.map(function(arg) {
                    return "".concat(arg, ": any");
                }).join(",") : args.join(", ");
                if (isSetupInlined) {
                    push("(".concat(signature, ") => {"));
                } else {
                    push("function ".concat(functionName, "(").concat(signature, ") {"));
                }
                indent();
                if (useWithBlock) {
                    push("with (_ctx) {");
                    indent();
                    if (hasHelpers) {
                        push("const { ".concat(helpers.map(aliasHelper).join(", "), " } = _Vue\n"), -1);
                        newline();
                    }
                }
                if (ast.components.length) {
                    genAssets(ast.components, "component", context);
                    if (ast.directives.length || ast.temps > 0) {
                        newline();
                    }
                }
                if (ast.directives.length) {
                    genAssets(ast.directives, "directive", context);
                    if (ast.temps > 0) {
                        newline();
                    }
                }
                if (ast.filters && ast.filters.length) {
                    newline();
                    genAssets(ast.filters, "filter", context);
                    newline();
                }
                if (ast.temps > 0) {
                    push("let ");
                    for(var i = 0; i < ast.temps; i++){
                        push("".concat(i > 0 ? ", " : "", "_temp").concat(i));
                    }
                }
                if (ast.components.length || ast.directives.length || ast.temps) {
                    push("\n", 0);
                    newline();
                }
                if (!ssr) {
                    push("return ");
                }
                if (ast.codegenNode) {
                    genNode(ast.codegenNode, context);
                } else {
                    push("null");
                }
                if (useWithBlock) {
                    deindent();
                    push("}");
                }
                deindent();
                push("}");
                return {
                    ast: ast,
                    code: context.code,
                    preamble: isSetupInlined ? preambleContext.code : "",
                    map: context.map ? context.map.toJSON() : void 0
                };
            }
            function genFunctionPreamble(ast, context) {
                var ssr = context.ssr, prefixIdentifiers = context.prefixIdentifiers, push = context.push, newline = context.newline, runtimeModuleName = context.runtimeModuleName, runtimeGlobalName = context.runtimeGlobalName, ssrRuntimeModuleName = context.ssrRuntimeModuleName;
                var VueBinding = ssr ? "require(".concat(JSON.stringify(runtimeModuleName), ")") : runtimeGlobalName;
                var helpers = Array.from(ast.helpers);
                if (helpers.length > 0) {
                    if (prefixIdentifiers) {
                        push("const { ".concat(helpers.map(aliasHelper).join(", "), " } = ").concat(VueBinding, "\n"), -1);
                    } else {
                        push("const _Vue = ".concat(VueBinding, "\n"), -1);
                        if (ast.hoists.length) {
                            var staticHelpers = [
                                CREATE_VNODE,
                                CREATE_ELEMENT_VNODE,
                                CREATE_COMMENT,
                                CREATE_TEXT,
                                CREATE_STATIC
                            ].filter(function(helper) {
                                return helpers.includes(helper);
                            }).map(aliasHelper).join(", ");
                            push("const { ".concat(staticHelpers, " } = _Vue\n"), -1);
                        }
                    }
                }
                if (ast.ssrHelpers && ast.ssrHelpers.length) {
                    push("const { ".concat(ast.ssrHelpers.map(aliasHelper).join(", "), ' } = require("').concat(ssrRuntimeModuleName, '")\n'), -1);
                }
                genHoists(ast.hoists, context);
                newline();
                push("return ");
            }
            function genModulePreamble(ast, context, genScopeId, inline) {
                var push = context.push, newline = context.newline, optimizeImports = context.optimizeImports, runtimeModuleName = context.runtimeModuleName, ssrRuntimeModuleName = context.ssrRuntimeModuleName;
                if (ast.helpers.size) {
                    var helpers = Array.from(ast.helpers);
                    if (optimizeImports) {
                        push("import { ".concat(helpers.map(function(s) {
                            return helperNameMap[s];
                        }).join(", "), " } from ").concat(JSON.stringify(runtimeModuleName), "\n"), -1);
                        push("\n// Binding optimization for webpack code-split\nconst ".concat(helpers.map(function(s) {
                            return "_".concat(helperNameMap[s], " = ").concat(helperNameMap[s]);
                        }).join(", "), "\n"), -1);
                    } else {
                        push("import { ".concat(helpers.map(function(s) {
                            return "".concat(helperNameMap[s], " as _").concat(helperNameMap[s]);
                        }).join(", "), " } from ").concat(JSON.stringify(runtimeModuleName), "\n"), -1);
                    }
                }
                if (ast.ssrHelpers && ast.ssrHelpers.length) {
                    push("import { ".concat(ast.ssrHelpers.map(function(s) {
                        return "".concat(helperNameMap[s], " as _").concat(helperNameMap[s]);
                    }).join(", "), ' } from "').concat(ssrRuntimeModuleName, '"\n'), -1);
                }
                if (ast.imports.length) {
                    genImports(ast.imports, context);
                    newline();
                }
                genHoists(ast.hoists, context);
                newline();
                if (!inline) {
                    push("export ");
                }
            }
            function genAssets(assets, type, param) {
                var helper = param.helper, push = param.push, newline = param.newline, isTS = param.isTS;
                var resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
                for(var i = 0; i < assets.length; i++){
                    var id = assets[i];
                    var maybeSelfReference = id.endsWith("__self");
                    if (maybeSelfReference) {
                        id = id.slice(0, -6);
                    }
                    push("const ".concat(toValidAssetId(id, type), " = ").concat(resolver, "(").concat(JSON.stringify(id)).concat(maybeSelfReference ? ", true" : "", ")").concat(isTS ? "!" : ""));
                    if (i < assets.length - 1) {
                        newline();
                    }
                }
            }
            function genHoists(hoists, context) {
                if (!hoists.length) {
                    return;
                }
                context.pure = true;
                var push = context.push, newline = context.newline;
                newline();
                for(var i = 0; i < hoists.length; i++){
                    var exp = hoists[i];
                    if (exp) {
                        push("const _hoisted_".concat(i + 1, " = "));
                        genNode(exp, context);
                        newline();
                    }
                }
                context.pure = false;
            }
            function genImports(importsOptions, context) {
                if (!importsOptions.length) {
                    return;
                }
                importsOptions.forEach(function(imports) {
                    context.push("import ");
                    genNode(imports.exp, context);
                    context.push(" from '".concat(imports.path, "'"));
                    context.newline();
                });
            }
            function isText(n) {
                return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
            }
            function genNodeListAsArray(nodes, context) {
                var multilines = nodes.length > 3 || nodes.some(function(n) {
                    return shared.isArray(n) || !isText(n);
                });
                context.push("[");
                multilines && context.indent();
                genNodeList(nodes, context, multilines);
                multilines && context.deindent();
                context.push("]");
            }
            function genNodeList(nodes, context) {
                var multilines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, comma = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                var push = context.push, newline = context.newline;
                for(var i = 0; i < nodes.length; i++){
                    var node = nodes[i];
                    if (shared.isString(node)) {
                        push(node, -3);
                    } else if (shared.isArray(node)) {
                        genNodeListAsArray(node, context);
                    } else {
                        genNode(node, context);
                    }
                    if (i < nodes.length - 1) {
                        if (multilines) {
                            comma && push(",");
                            newline();
                        } else {
                            comma && push(", ");
                        }
                    }
                }
            }
            function genNode(node, context) {
                if (shared.isString(node)) {
                    context.push(node, -3);
                    return;
                }
                if (shared.isSymbol(node)) {
                    context.push(context.helper(node));
                    return;
                }
                switch(node.type){
                    case 1:
                    case 9:
                    case 11:
                        assert(node.codegenNode != null, "Codegen node is missing for element/if/for node. Apply appropriate transforms first.");
                        genNode(node.codegenNode, context);
                        break;
                    case 2:
                        genText(node, context);
                        break;
                    case 4:
                        genExpression(node, context);
                        break;
                    case 5:
                        genInterpolation(node, context);
                        break;
                    case 12:
                        genNode(node.codegenNode, context);
                        break;
                    case 8:
                        genCompoundExpression(node, context);
                        break;
                    case 3:
                        genComment(node, context);
                        break;
                    case 13:
                        genVNodeCall(node, context);
                        break;
                    case 14:
                        genCallExpression(node, context);
                        break;
                    case 15:
                        genObjectExpression(node, context);
                        break;
                    case 17:
                        genArrayExpression(node, context);
                        break;
                    case 18:
                        genFunctionExpression(node, context);
                        break;
                    case 19:
                        genConditionalExpression(node, context);
                        break;
                    case 20:
                        genCacheExpression(node, context);
                        break;
                    case 21:
                        genNodeList(node.body, context, true, false);
                        break;
                    // SSR only types
                    case 22:
                        genTemplateLiteral(node, context);
                        break;
                    case 23:
                        genIfStatement(node, context);
                        break;
                    case 24:
                        genAssignmentExpression(node, context);
                        break;
                    case 25:
                        genSequenceExpression(node, context);
                        break;
                    case 26:
                        genReturnStatement(node, context);
                        break;
                    /* v8 ignore start */ case 10:
                        break;
                    default:
                        {
                            assert(false, "unhandled codegen node type: ".concat(node.type));
                            var exhaustiveCheck = node;
                            return exhaustiveCheck;
                        }
                }
            }
            function genText(node, context) {
                context.push(JSON.stringify(node.content), -3, node);
            }
            function genExpression(node, context) {
                var content = node.content, isStatic = node.isStatic;
                context.push(isStatic ? JSON.stringify(content) : content, -3, node);
            }
            function genInterpolation(node, context) {
                var push = context.push, helper = context.helper, pure = context.pure;
                if (pure) push(PURE_ANNOTATION);
                push("".concat(helper(TO_DISPLAY_STRING), "("));
                genNode(node.content, context);
                push(")");
            }
            function genCompoundExpression(node, context) {
                for(var i = 0; i < node.children.length; i++){
                    var child = node.children[i];
                    if (shared.isString(child)) {
                        context.push(child, -3);
                    } else {
                        genNode(child, context);
                    }
                }
            }
            function genExpressionAsPropertyKey(node, context) {
                var push = context.push;
                if (node.type === 8) {
                    push("[");
                    genCompoundExpression(node, context);
                    push("]");
                } else if (node.isStatic) {
                    var text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
                    push(text, -2, node);
                } else {
                    push("[".concat(node.content, "]"), -3, node);
                }
            }
            function genComment(node, context) {
                var push = context.push, helper = context.helper, pure = context.pure;
                if (pure) {
                    push(PURE_ANNOTATION);
                }
                push("".concat(helper(CREATE_COMMENT), "(").concat(JSON.stringify(node.content), ")"), -3, node);
            }
            function genVNodeCall(node, context) {
                var push = context.push, helper = context.helper, pure = context.pure;
                var tag = node.tag, props = node.props, children = node.children, patchFlag = node.patchFlag, dynamicProps = node.dynamicProps, directives = node.directives, isBlock = node.isBlock, disableTracking = node.disableTracking, isComponent2 = node.isComponent;
                var patchFlagString;
                if (patchFlag) {
                    {
                        if (patchFlag < 0) {
                            patchFlagString = patchFlag + " /* ".concat(shared.PatchFlagNames[patchFlag], " */");
                        } else {
                            var flagNames = Object.keys(shared.PatchFlagNames).map(Number).filter(function(n) {
                                return n > 0 && patchFlag & n;
                            }).map(function(n) {
                                return shared.PatchFlagNames[n];
                            }).join(", ");
                            patchFlagString = patchFlag + " /* ".concat(flagNames, " */");
                        }
                    }
                }
                if (directives) {
                    push(helper(WITH_DIRECTIVES) + "(");
                }
                if (isBlock) {
                    push("(".concat(helper(OPEN_BLOCK), "(").concat(disableTracking ? "true" : "", "), "));
                }
                if (pure) {
                    push(PURE_ANNOTATION);
                }
                var callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
                push(helper(callHelper) + "(", -2, node);
                genNodeList(genNullableArgs([
                    tag,
                    props,
                    children,
                    patchFlagString,
                    dynamicProps
                ]), context);
                push(")");
                if (isBlock) {
                    push(")");
                }
                if (directives) {
                    push(", ");
                    genNode(directives, context);
                    push(")");
                }
            }
            function genNullableArgs(args) {
                var i = args.length;
                while(i--){
                    if (args[i] != null) break;
                }
                return args.slice(0, i + 1).map(function(arg) {
                    return arg || "null";
                });
            }
            function genCallExpression(node, context) {
                var push = context.push, helper = context.helper, pure = context.pure;
                var callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
                if (pure) {
                    push(PURE_ANNOTATION);
                }
                push(callee + "(", -2, node);
                genNodeList(node.arguments, context);
                push(")");
            }
            function genObjectExpression(node, context) {
                var push = context.push, indent = context.indent, deindent = context.deindent, newline = context.newline;
                var properties = node.properties;
                if (!properties.length) {
                    push("{}", -2, node);
                    return;
                }
                var multilines = properties.length > 1 || properties.some(function(p) {
                    return p.value.type !== 4;
                });
                push(multilines ? "{" : "{ ");
                multilines && indent();
                for(var i = 0; i < properties.length; i++){
                    var _properties_i = properties[i], key = _properties_i.key, value = _properties_i.value;
                    genExpressionAsPropertyKey(key, context);
                    push(": ");
                    genNode(value, context);
                    if (i < properties.length - 1) {
                        push(",");
                        newline();
                    }
                }
                multilines && deindent();
                push(multilines ? "}" : " }");
            }
            function genArrayExpression(node, context) {
                genNodeListAsArray(node.elements, context);
            }
            function genFunctionExpression(node, context) {
                var push = context.push, indent = context.indent, deindent = context.deindent;
                var params = node.params, returns = node.returns, body = node.body, newline = node.newline, isSlot = node.isSlot;
                if (isSlot) {
                    push("_".concat(helperNameMap[WITH_CTX], "("));
                }
                push("(", -2, node);
                if (shared.isArray(params)) {
                    genNodeList(params, context);
                } else if (params) {
                    genNode(params, context);
                }
                push(") => ");
                if (newline || body) {
                    push("{");
                    indent();
                }
                if (returns) {
                    if (newline) {
                        push("return ");
                    }
                    if (shared.isArray(returns)) {
                        genNodeListAsArray(returns, context);
                    } else {
                        genNode(returns, context);
                    }
                } else if (body) {
                    genNode(body, context);
                }
                if (newline || body) {
                    deindent();
                    push("}");
                }
                if (isSlot) {
                    if (node.isNonScopedSlot) {
                        push(", undefined, true");
                    }
                    push(")");
                }
            }
            function genConditionalExpression(node, context) {
                var test = node.test, consequent = node.consequent, alternate = node.alternate, needNewline = node.newline;
                var push = context.push, indent = context.indent, deindent = context.deindent, newline = context.newline;
                if (test.type === 4) {
                    var needsParens = !isSimpleIdentifier(test.content);
                    needsParens && push("(");
                    genExpression(test, context);
                    needsParens && push(")");
                } else {
                    push("(");
                    genNode(test, context);
                    push(")");
                }
                needNewline && indent();
                context.indentLevel++;
                needNewline || push(" ");
                push("? ");
                genNode(consequent, context);
                context.indentLevel--;
                needNewline && newline();
                needNewline || push(" ");
                push(": ");
                var isNested = alternate.type === 19;
                if (!isNested) {
                    context.indentLevel++;
                }
                genNode(alternate, context);
                if (!isNested) {
                    context.indentLevel--;
                }
                needNewline && deindent(true);
            }
            function genCacheExpression(node, context) {
                var push = context.push, helper = context.helper, indent = context.indent, deindent = context.deindent, newline = context.newline;
                var needPauseTracking = node.needPauseTracking, needArraySpread = node.needArraySpread;
                if (needArraySpread) {
                    push("[...(");
                }
                push("_cache[".concat(node.index, "] || ("));
                if (needPauseTracking) {
                    indent();
                    push("".concat(helper(SET_BLOCK_TRACKING), "(-1"));
                    if (node.inVOnce) push(", true");
                    push("),");
                    newline();
                    push("(");
                }
                push("_cache[".concat(node.index, "] = "));
                genNode(node.value, context);
                if (needPauseTracking) {
                    push(").cacheIndex = ".concat(node.index, ","));
                    newline();
                    push("".concat(helper(SET_BLOCK_TRACKING), "(1),"));
                    newline();
                    push("_cache[".concat(node.index, "]"));
                    deindent();
                }
                push(")");
                if (needArraySpread) {
                    push(")]");
                }
            }
            function genTemplateLiteral(node, context) {
                var push = context.push, indent = context.indent, deindent = context.deindent;
                push("`");
                var l = node.elements.length;
                var multilines = l > 3;
                for(var i = 0; i < l; i++){
                    var e = node.elements[i];
                    if (shared.isString(e)) {
                        push(e.replace(/(`|\$|\\)/g, "\\$1"), -3);
                    } else {
                        push("${");
                        if (multilines) indent();
                        genNode(e, context);
                        if (multilines) deindent();
                        push("}");
                    }
                }
                push("`");
            }
            function genIfStatement(node, context) {
                var push = context.push, indent = context.indent, deindent = context.deindent;
                var test = node.test, consequent = node.consequent, alternate = node.alternate;
                push("if (");
                genNode(test, context);
                push(") {");
                indent();
                genNode(consequent, context);
                deindent();
                push("}");
                if (alternate) {
                    push(" else ");
                    if (alternate.type === 23) {
                        genIfStatement(alternate, context);
                    } else {
                        push("{");
                        indent();
                        genNode(alternate, context);
                        deindent();
                        push("}");
                    }
                }
            }
            function genAssignmentExpression(node, context) {
                genNode(node.left, context);
                context.push(" = ");
                genNode(node.right, context);
            }
            function genSequenceExpression(node, context) {
                context.push("(");
                genNodeList(node.expressions, context);
                context.push(")");
            }
            function genReturnStatement(param, context) {
                var returns = param.returns;
                context.push("return ");
                if (shared.isArray(returns)) {
                    genNodeListAsArray(returns, context);
                } else {
                    genNode(returns, context);
                }
            }
            var isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap("true,false,null,this");
            var transformExpression = function(node, context) {
                if (node.type === 5) {
                    node.content = processExpression(node.content, context);
                } else if (node.type === 1) {
                    var memo = findDir(node, "memo");
                    for(var i = 0; i < node.props.length; i++){
                        var dir = node.props[i];
                        if (dir.type === 7 && dir.name !== "for") {
                            var exp = dir.exp;
                            var arg = dir.arg;
                            if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
                            !(memo && arg && arg.type === 4 && arg.content === "key")) {
                                dir.exp = processExpression(exp, context, // slot args must be processed as function params
                                dir.name === "slot");
                            }
                            if (arg && arg.type === 4 && !arg.isStatic) {
                                dir.arg = processExpression(arg, context);
                            }
                        }
                    }
                }
            };
            function processExpression(node, context) {
                var asParams = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, asRawStatements = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, localVars = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Object.create(context.identifiers);
                if (!context.prefixIdentifiers || !node.content.trim()) {
                    return node;
                }
                var inline = context.inline, bindingMetadata = context.bindingMetadata;
                var rewriteIdentifier = function(raw, parent, id) {
                    var type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
                    if (inline) {
                        var isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
                        var isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
                        var isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
                        var isNewExpression = parent && isInNewExpression(parentStack);
                        var wrapWithUnref = function(raw2) {
                            var wrapped = "".concat(context.helperString(UNREF), "(").concat(raw2, ")");
                            return isNewExpression ? "(".concat(wrapped, ")") : wrapped;
                        };
                        if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) {
                            return raw;
                        } else if (type === "setup-ref") {
                            return "".concat(raw, ".value");
                        } else if (type === "setup-maybe-ref") {
                            return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? "".concat(raw, ".value") : wrapWithUnref(raw);
                        } else if (type === "setup-let") {
                            if (isAssignmentLVal) {
                                var rVal = parent.right, operator = parent.operator;
                                var rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
                                var rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds));
                                return "".concat(context.helperString(IS_REF), "(").concat(raw, ")").concat(context.isTS ? " //@ts-ignore\n" : "", " ? ").concat(raw, ".value ").concat(operator, " ").concat(rExpString, " : ").concat(raw);
                            } else if (isUpdateArg) {
                                id.start = parent.start;
                                id.end = parent.end;
                                var isPrefix = parent.prefix, operator1 = parent.operator;
                                var prefix = isPrefix ? operator1 : "";
                                var postfix = isPrefix ? "" : operator1;
                                return "".concat(context.helperString(IS_REF), "(").concat(raw, ")").concat(context.isTS ? " //@ts-ignore\n" : "", " ? ").concat(prefix).concat(raw, ".value").concat(postfix, " : ").concat(prefix).concat(raw).concat(postfix);
                            } else if (isDestructureAssignment) {
                                return raw;
                            } else {
                                return wrapWithUnref(raw);
                            }
                        } else if (type === "props") {
                            return shared.genPropsAccessExp(raw);
                        } else if (type === "props-aliased") {
                            return shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
                        }
                    } else {
                        if (type && type.startsWith("setup") || type === "literal-const") {
                            return "$setup.".concat(raw);
                        } else if (type === "props-aliased") {
                            return "$props['".concat(bindingMetadata.__propsAliases[raw], "']");
                        } else if (type) {
                            return "$".concat(type, ".").concat(raw);
                        }
                    }
                    return "_ctx.".concat(raw);
                };
                var rawExp = node.content;
                var ast = node.ast;
                if (ast === false) {
                    return node;
                }
                if (ast === null || !ast && isSimpleIdentifier(rawExp)) {
                    var isScopeVarReference = context.identifiers[rawExp];
                    var isAllowedGlobal = shared.isGloballyAllowed(rawExp);
                    var isLiteral = isLiteralWhitelisted(rawExp);
                    if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
                        if (isConst(bindingMetadata[rawExp])) {
                            node.constType = 1;
                        }
                        node.content = rewriteIdentifier(rawExp);
                    } else if (!isScopeVarReference) {
                        if (isLiteral) {
                            node.constType = 3;
                        } else {
                            node.constType = 2;
                        }
                    }
                    return node;
                }
                if (!ast) {
                    var source = asRawStatements ? " ".concat(rawExp, " ") : "(".concat(rawExp, ")").concat(asParams ? "=>{}" : "");
                    try {
                        ast = parser.parseExpression(source, {
                            sourceType: "module",
                            plugins: context.expressionPlugins
                        });
                    } catch (e) {
                        context.onError(createCompilerError(45, node.loc, void 0, e.message));
                        return node;
                    }
                }
                var ids = [];
                var parentStack = [];
                var knownIds = Object.create(context.identifiers);
                walkIdentifiers(ast, function(node2, parent, _, isReferenced2, isLocal) {
                    if (isStaticPropertyKey(node2, parent)) {
                        return;
                    }
                    if (node2.name.startsWith("_filter_")) {
                        return;
                    }
                    var needPrefix = isReferenced2 && canPrefix(node2);
                    if (needPrefix && !isLocal) {
                        if (isStaticProperty(parent) && parent.shorthand) {
                            node2.prefix = "".concat(node2.name, ": ");
                        }
                        node2.name = rewriteIdentifier(node2.name, parent, node2);
                        ids.push(node2);
                    } else {
                        if (!(needPrefix && isLocal) && (!parent || parent.type !== "CallExpression" && parent.type !== "NewExpression" && parent.type !== "MemberExpression")) {
                            node2.isConstant = true;
                        }
                        ids.push(node2);
                    }
                }, true, // invoke on ALL identifiers
                parentStack, knownIds);
                var children = [];
                ids.sort(function(a, b) {
                    return a.start - b.start;
                });
                ids.forEach(function(id, i) {
                    var start = id.start - 1;
                    var end = id.end - 1;
                    var last = ids[i - 1];
                    var leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
                    if (leadingText.length || id.prefix) {
                        children.push(leadingText + (id.prefix || ""));
                    }
                    var source = rawExp.slice(start, end);
                    children.push(createSimpleExpression(id.name, false, {
                        start: advancePositionWithClone(node.loc.start, source, start),
                        end: advancePositionWithClone(node.loc.start, source, end),
                        source: source
                    }, id.isConstant ? 3 : 0));
                    if (i === ids.length - 1 && end < rawExp.length) {
                        children.push(rawExp.slice(end));
                    }
                });
                var ret;
                if (children.length) {
                    ret = createCompoundExpression(children, node.loc);
                    ret.ast = ast;
                } else {
                    ret = node;
                    ret.constType = 3;
                }
                ret.identifiers = Object.keys(knownIds);
                return ret;
            }
            function canPrefix(id) {
                if (shared.isGloballyAllowed(id.name)) {
                    return false;
                }
                if (id.name === "require") {
                    return false;
                }
                return true;
            }
            function stringifyExpression(exp) {
                if (shared.isString(exp)) {
                    return exp;
                } else if (exp.type === 4) {
                    return exp.content;
                } else {
                    return exp.children.map(stringifyExpression).join("");
                }
            }
            function isConst(type) {
                return type === "setup-const" || type === "literal-const";
            }
            var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, function(node, dir, context) {
                return processIf(node, dir, context, function(ifNode, branch, isRoot) {
                    var siblings = context.parent.children;
                    var i = siblings.indexOf(ifNode);
                    var key = 0;
                    while(i-- >= 0){
                        var sibling = siblings[i];
                        if (sibling && sibling.type === 9) {
                            key += sibling.branches.length;
                        }
                    }
                    return function() {
                        if (isRoot) {
                            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
                        } else {
                            var parentCondition = getParentCondition(ifNode.codegenNode);
                            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
                        }
                    };
                });
            });
            function processIf(node, dir, context, processCodegen) {
                if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
                    var loc = dir.exp ? dir.exp.loc : node.loc;
                    context.onError(createCompilerError(28, dir.loc));
                    dir.exp = createSimpleExpression("true", false, loc);
                }
                if (context.prefixIdentifiers && dir.exp) {
                    dir.exp = processExpression(dir.exp, context);
                }
                if (dir.name === "if") {
                    var branch = createIfBranch(node, dir);
                    var ifNode = {
                        type: 9,
                        loc: cloneLoc(node.loc),
                        branches: [
                            branch
                        ]
                    };
                    context.replaceNode(ifNode);
                    if (processCodegen) {
                        return processCodegen(ifNode, branch, true);
                    }
                } else {
                    var _loop = function() {
                        var sibling = siblings[i];
                        if (sibling && sibling.type === 3) {
                            context.removeNode(sibling);
                            comments.unshift(sibling);
                            return "continue";
                        }
                        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
                            context.removeNode(sibling);
                            return "continue";
                        }
                        if (sibling && sibling.type === 9) {
                            if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
                                context.onError(createCompilerError(30, node.loc));
                            }
                            context.removeNode();
                            var branch = createIfBranch(node, dir);
                            if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
                            !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
                                branch.children = _to_consumable_array(comments).concat(_to_consumable_array(branch.children));
                            }
                            {
                                var key = branch.userKey;
                                if (key) {
                                    sibling.branches.forEach(function(param) {
                                        var userKey = param.userKey;
                                        if (isSameKey(userKey, key)) {
                                            context.onError(createCompilerError(29, branch.userKey.loc));
                                        }
                                    });
                                }
                            }
                            sibling.branches.push(branch);
                            var onExit = processCodegen && processCodegen(sibling, branch, false);
                            traverseNode(branch, context);
                            if (onExit) onExit();
                            context.currentNode = null;
                        } else {
                            context.onError(createCompilerError(30, node.loc));
                        }
                        return "break";
                    };
                    var siblings = context.parent.children;
                    var comments = [];
                    var i = siblings.indexOf(node);
                    while(i-- >= -1){
                        var _ret = _loop();
                        if (_ret === "break") break;
                    }
                }
            }
            function createIfBranch(node, dir) {
                var isTemplateIf = node.tagType === 3;
                return {
                    type: 10,
                    loc: node.loc,
                    condition: dir.name === "else" ? void 0 : dir.exp,
                    children: isTemplateIf && !findDir(node, "for") ? node.children : [
                        node
                    ],
                    userKey: findProp(node, "key"),
                    isTemplateIf: isTemplateIf
                };
            }
            function createCodegenNodeForBranch(branch, keyIndex, context) {
                if (branch.condition) {
                    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), // make sure to pass in asBlock: true so that the comment node call
                    // closes the current block.
                    createCallExpression(context.helper(CREATE_COMMENT), [
                        '"v-if"',
                        "true"
                    ]));
                } else {
                    return createChildrenCodegenNode(branch, keyIndex, context);
                }
            }
            function createChildrenCodegenNode(branch, keyIndex, context) {
                var helper = context.helper;
                var keyProperty = createObjectProperty("key", createSimpleExpression("".concat(keyIndex), false, locStub, 2));
                var children = branch.children;
                var firstChild = children[0];
                var needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
                if (needFragmentWrapper) {
                    if (children.length === 1 && firstChild.type === 11) {
                        var vnodeCall = firstChild.codegenNode;
                        injectProp(vnodeCall, keyProperty, context);
                        return vnodeCall;
                    } else {
                        var patchFlag = 64;
                        if (!branch.isTemplateIf && children.filter(function(c) {
                            return c.type !== 3;
                        }).length === 1) {
                            patchFlag |= 2048;
                        }
                        return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([
                            keyProperty
                        ]), children, patchFlag, void 0, void 0, true, false, false, branch.loc);
                    }
                } else {
                    var ret = firstChild.codegenNode;
                    var vnodeCall1 = getMemoedVNodeCall(ret);
                    if (vnodeCall1.type === 13) {
                        convertToBlock(vnodeCall1, context);
                    }
                    injectProp(vnodeCall1, keyProperty, context);
                    return ret;
                }
            }
            function isSameKey(a, b) {
                if (!a || a.type !== b.type) {
                    return false;
                }
                if (a.type === 6) {
                    if (a.value.content !== b.value.content) {
                        return false;
                    }
                } else {
                    var exp = a.exp;
                    var branchExp = b.exp;
                    if (exp.type !== branchExp.type) {
                        return false;
                    }
                    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
                        return false;
                    }
                }
                return true;
            }
            function getParentCondition(node) {
                while(true){
                    if (node.type === 19) {
                        if (node.alternate.type === 19) {
                            node = node.alternate;
                        } else {
                            return node;
                        }
                    } else if (node.type === 20) {
                        node = node.value;
                    }
                }
            }
            var transformBind = function(dir, _node, context) {
                var modifiers = dir.modifiers, loc = dir.loc;
                var arg = dir.arg;
                var exp = dir.exp;
                if (exp && exp.type === 4 && !exp.content.trim()) {
                    {
                        context.onError(createCompilerError(34, loc));
                        return {
                            props: [
                                createObjectProperty(arg, createSimpleExpression("", true, loc))
                            ]
                        };
                    }
                }
                if (!exp) {
                    if (arg.type !== 4 || !arg.isStatic) {
                        context.onError(createCompilerError(52, arg.loc));
                        return {
                            props: [
                                createObjectProperty(arg, createSimpleExpression("", true, loc))
                            ]
                        };
                    }
                    transformBindShorthand(dir, context);
                    exp = dir.exp;
                }
                if (arg.type !== 4) {
                    arg.children.unshift("(");
                    arg.children.push(') || ""');
                } else if (!arg.isStatic) {
                    arg.content = "".concat(arg.content, ' || ""');
                }
                if (modifiers.some(function(mod) {
                    return mod.content === "camel";
                })) {
                    if (arg.type === 4) {
                        if (arg.isStatic) {
                            arg.content = shared.camelize(arg.content);
                        } else {
                            arg.content = "".concat(context.helperString(CAMELIZE), "(").concat(arg.content, ")");
                        }
                    } else {
                        arg.children.unshift("".concat(context.helperString(CAMELIZE), "("));
                        arg.children.push(")");
                    }
                }
                if (!context.inSSR) {
                    if (modifiers.some(function(mod) {
                        return mod.content === "prop";
                    })) {
                        injectPrefix(arg, ".");
                    }
                    if (modifiers.some(function(mod) {
                        return mod.content === "attr";
                    })) {
                        injectPrefix(arg, "^");
                    }
                }
                return {
                    props: [
                        createObjectProperty(arg, exp)
                    ]
                };
            };
            var transformBindShorthand = function(dir, context) {
                var arg = dir.arg;
                var propName = shared.camelize(arg.content);
                dir.exp = createSimpleExpression(propName, false, arg.loc);
                {
                    dir.exp = processExpression(dir.exp, context);
                }
            };
            var injectPrefix = function(arg, prefix) {
                if (arg.type === 4) {
                    if (arg.isStatic) {
                        arg.content = prefix + arg.content;
                    } else {
                        arg.content = "`".concat(prefix, "${").concat(arg.content, "}`");
                    }
                } else {
                    arg.children.unshift("'".concat(prefix, "' + ("));
                    arg.children.push(")");
                }
            };
            var transformFor = createStructuralDirectiveTransform("for", function(node, dir, context) {
                var helper = context.helper, removeHelper = context.removeHelper;
                return processFor(node, dir, context, function(forNode) {
                    var renderExp = createCallExpression(helper(RENDER_LIST), [
                        forNode.source
                    ]);
                    var isTemplate = isTemplateNode(node);
                    var memo = findDir(node, "memo");
                    var keyProp = findProp(node, "key", false, true);
                    var isDirKey = keyProp && keyProp.type === 7;
                    if (isDirKey && !keyProp.exp) {
                        transformBindShorthand(keyProp, context);
                    }
                    var keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
                    if (memo && keyExp && isDirKey) {
                        {
                            keyProp.exp = keyExp = processExpression(keyExp, context);
                        }
                    }
                    var keyProperty = keyProp && keyExp ? createObjectProperty("key", keyExp) : null;
                    if (isTemplate) {
                        if (memo) {
                            memo.exp = processExpression(memo.exp, context);
                        }
                        if (keyProperty && keyProp.type !== 6) {
                            keyProperty.value = processExpression(keyProperty.value, context);
                        }
                    }
                    var isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
                    var fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
                    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag, void 0, void 0, true, !isStableFragment, false, node.loc);
                    return function() {
                        var childBlock;
                        var children = forNode.children;
                        if (isTemplate) {
                            node.children.some(function(c) {
                                if (c.type === 1) {
                                    var key = findProp(c, "key");
                                    if (key) {
                                        context.onError(createCompilerError(33, key.loc));
                                        return true;
                                    }
                                }
                            });
                        }
                        var needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
                        var slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
                        if (slotOutlet) {
                            childBlock = slotOutlet.codegenNode;
                            if (isTemplate && keyProperty) {
                                injectProp(childBlock, keyProperty, context);
                            }
                        } else if (needFragmentWrapper) {
                            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([
                                keyProperty
                            ]) : void 0, node.children, 64, void 0, void 0, true, void 0, false);
                        } else {
                            childBlock = children[0].codegenNode;
                            if (isTemplate && keyProperty) {
                                injectProp(childBlock, keyProperty, context);
                            }
                            if (childBlock.isBlock !== !isStableFragment) {
                                if (childBlock.isBlock) {
                                    removeHelper(OPEN_BLOCK);
                                    removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                                } else {
                                    removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                                }
                            }
                            childBlock.isBlock = !isStableFragment;
                            if (childBlock.isBlock) {
                                helper(OPEN_BLOCK);
                                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                            } else {
                                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                            }
                        }
                        if (memo) {
                            var loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                                createSimpleExpression("_cached")
                            ]));
                            loop.body = createBlockStatement([
                                createCompoundExpression([
                                    "const _memo = (",
                                    memo.exp,
                                    ")"
                                ]),
                                createCompoundExpression([
                                    "if (_cached"
                                ].concat(_to_consumable_array(keyExp ? [
                                    " && _cached.key === ",
                                    keyExp
                                ] : []), [
                                    " && ".concat(context.helperString(IS_MEMO_SAME), "(_cached, _memo)) return _cached")
                                ])),
                                createCompoundExpression([
                                    "const _item = ",
                                    childBlock
                                ]),
                                createSimpleExpression("_item.memo = _memo"),
                                createSimpleExpression("return _item")
                            ]);
                            renderExp.arguments.push(loop, createSimpleExpression("_cache"), createSimpleExpression(String(context.cached.length)));
                            context.cached.push(null);
                        } else {
                            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
                        }
                    };
                });
            });
            function processFor(node, dir, context, processCodegen) {
                if (!dir.exp) {
                    context.onError(createCompilerError(31, dir.loc));
                    return;
                }
                var parseResult = dir.forParseResult;
                if (!parseResult) {
                    context.onError(createCompilerError(32, dir.loc));
                    return;
                }
                finalizeForParseResult(parseResult, context);
                var addIdentifiers = context.addIdentifiers, removeIdentifiers = context.removeIdentifiers, scopes = context.scopes;
                var source = parseResult.source, value = parseResult.value, key = parseResult.key, index = parseResult.index;
                var forNode = {
                    type: 11,
                    loc: dir.loc,
                    source: source,
                    valueAlias: value,
                    keyAlias: key,
                    objectIndexAlias: index,
                    parseResult: parseResult,
                    children: isTemplateNode(node) ? node.children : [
                        node
                    ]
                };
                context.replaceNode(forNode);
                scopes.vFor++;
                if (context.prefixIdentifiers) {
                    value && addIdentifiers(value);
                    key && addIdentifiers(key);
                    index && addIdentifiers(index);
                }
                var onExit = processCodegen && processCodegen(forNode);
                return function() {
                    scopes.vFor--;
                    if (context.prefixIdentifiers) {
                        value && removeIdentifiers(value);
                        key && removeIdentifiers(key);
                        index && removeIdentifiers(index);
                    }
                    if (onExit) onExit();
                };
            }
            function finalizeForParseResult(result, context) {
                if (result.finalized) return;
                if (context.prefixIdentifiers) {
                    result.source = processExpression(result.source, context);
                    if (result.key) {
                        result.key = processExpression(result.key, context, true);
                    }
                    if (result.index) {
                        result.index = processExpression(result.index, context, true);
                    }
                    if (result.value) {
                        result.value = processExpression(result.value, context, true);
                    }
                }
                result.finalized = true;
            }
            function createForLoopParams(param) {
                var value = param.value, key = param.key, index = param.index, memoArgs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                return createParamsList([
                    value,
                    key,
                    index
                ].concat(_to_consumable_array(memoArgs)));
            }
            function createParamsList(args) {
                var i = args.length;
                while(i--){
                    if (args[i]) break;
                }
                return args.slice(0, i + 1).map(function(arg, i2) {
                    return arg || createSimpleExpression("_".repeat(i2 + 1), false);
                });
            }
            var defaultFallback = createSimpleExpression("undefined", false);
            var trackSlotScopes = function(node, context) {
                if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
                    var vSlot = findDir(node, "slot");
                    if (vSlot) {
                        var slotProps = vSlot.exp;
                        if (context.prefixIdentifiers) {
                            slotProps && context.addIdentifiers(slotProps);
                        }
                        context.scopes.vSlot++;
                        return function() {
                            if (context.prefixIdentifiers) {
                                slotProps && context.removeIdentifiers(slotProps);
                            }
                            context.scopes.vSlot--;
                        };
                    }
                }
            };
            var trackVForSlotScopes = function(node, context) {
                var vFor;
                if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
                    var result = vFor.forParseResult;
                    if (result) {
                        finalizeForParseResult(result, context);
                        var value = result.value, key = result.key, index = result.index;
                        var addIdentifiers = context.addIdentifiers, removeIdentifiers = context.removeIdentifiers;
                        value && addIdentifiers(value);
                        key && addIdentifiers(key);
                        index && addIdentifiers(index);
                        return function() {
                            value && removeIdentifiers(value);
                            key && removeIdentifiers(key);
                            index && removeIdentifiers(index);
                        };
                    }
                }
            };
            var buildClientSlotFn = function(props, _vForExp, children, loc) {
                return createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
            };
            function buildSlots(node, context) {
                var buildSlotFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buildClientSlotFn;
                context.helper(WITH_CTX);
                var children = node.children, loc = node.loc;
                var slotsProperties = [];
                var dynamicSlots = [];
                var hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
                if (!context.ssr && context.prefixIdentifiers) {
                    hasDynamicSlots = hasScopeRef(node, context.identifiers);
                }
                var onComponentSlot = findDir(node, "slot", true);
                if (onComponentSlot) {
                    var arg = onComponentSlot.arg, exp = onComponentSlot.exp;
                    if (arg && !isStaticExp(arg)) {
                        hasDynamicSlots = true;
                    }
                    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, void 0, children, loc)));
                }
                var hasTemplateSlots = false;
                var hasNamedDefaultSlot = false;
                var implicitDefaultChildren = [];
                var seenSlotNames = /* @__PURE__ */ new Set();
                var conditionalBranchIndex = 0;
                for(var i = 0; i < children.length; i++){
                    var slotElement = children[i];
                    var slotDir = void 0;
                    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
                        if (slotElement.type !== 3) {
                            implicitDefaultChildren.push(slotElement);
                        }
                        continue;
                    }
                    if (onComponentSlot) {
                        context.onError(createCompilerError(37, slotDir.loc));
                        break;
                    }
                    hasTemplateSlots = true;
                    var slotChildren = slotElement.children, slotLoc = slotElement.loc;
                    var tmp = slotDir.arg, slotName = tmp === void 0 ? createSimpleExpression("default", true) : tmp, slotProps = slotDir.exp, dirLoc = slotDir.loc;
                    var staticSlotName = void 0;
                    if (isStaticExp(slotName)) {
                        staticSlotName = slotName ? slotName.content : "default";
                    } else {
                        hasDynamicSlots = true;
                    }
                    var vFor = findDir(slotElement, "for");
                    var slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
                    var vIf = void 0;
                    var vElse = void 0;
                    if (vIf = findDir(slotElement, "if")) {
                        hasDynamicSlots = true;
                        dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
                    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
                        var j = i;
                        var prev = void 0;
                        while(j--){
                            prev = children[j];
                            if (prev.type !== 3) {
                                break;
                            }
                        }
                        if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
                            var conditional = dynamicSlots[dynamicSlots.length - 1];
                            while(conditional.alternate.type === 19){
                                conditional = conditional.alternate;
                            }
                            conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
                        } else {
                            context.onError(createCompilerError(30, vElse.loc));
                        }
                    } else if (vFor) {
                        hasDynamicSlots = true;
                        var parseResult = vFor.forParseResult;
                        if (parseResult) {
                            finalizeForParseResult(parseResult, context);
                            dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                                parseResult.source,
                                createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
                            ]));
                        } else {
                            context.onError(createCompilerError(32, vFor.loc));
                        }
                    } else {
                        if (staticSlotName) {
                            if (seenSlotNames.has(staticSlotName)) {
                                context.onError(createCompilerError(38, dirLoc));
                                continue;
                            }
                            seenSlotNames.add(staticSlotName);
                            if (staticSlotName === "default") {
                                hasNamedDefaultSlot = true;
                            }
                        }
                        slotsProperties.push(createObjectProperty(slotName, slotFunction));
                    }
                }
                if (!onComponentSlot) {
                    var buildDefaultSlotProperty = function(props, children2) {
                        var fn = buildSlotFn(props, void 0, children2, loc);
                        if (context.compatConfig) {
                            fn.isNonScopedSlot = true;
                        }
                        return createObjectProperty("default", fn);
                    };
                    if (!hasTemplateSlots) {
                        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
                    } else if (implicitDefaultChildren.length && // #3766
                    // with whitespace: 'preserve', whitespaces between slots will end up in
                    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
                    implicitDefaultChildren.some(function(node2) {
                        return isNonWhitespaceContent(node2);
                    })) {
                        if (hasNamedDefaultSlot) {
                            context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
                        } else {
                            slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
                        }
                    }
                }
                var slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
                var slots = createObjectExpression(slotsProperties.concat(createObjectProperty("_", // 2 = compiled but dynamic = can skip normalization, but must run diff
                // 1 = compiled and static = can skip normalization AND diff as optimized
                createSimpleExpression(slotFlag + " /* ".concat(shared.slotFlagsText[slotFlag], " */"), false))), loc);
                if (dynamicSlots.length) {
                    slots = createCallExpression(context.helper(CREATE_SLOTS), [
                        slots,
                        createArrayExpression(dynamicSlots)
                    ]);
                }
                return {
                    slots: slots,
                    hasDynamicSlots: hasDynamicSlots
                };
            }
            function buildDynamicSlot(name, fn, index) {
                var props = [
                    createObjectProperty("name", name),
                    createObjectProperty("fn", fn)
                ];
                if (index != null) {
                    props.push(createObjectProperty("key", createSimpleExpression(String(index), true)));
                }
                return createObjectExpression(props);
            }
            function hasForwardedSlots(children) {
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    switch(child.type){
                        case 1:
                            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
                                return true;
                            }
                            break;
                        case 9:
                            if (hasForwardedSlots(child.branches)) return true;
                            break;
                        case 10:
                        case 11:
                            if (hasForwardedSlots(child.children)) return true;
                            break;
                    }
                }
                return false;
            }
            function isNonWhitespaceContent(node) {
                if (node.type !== 2 && node.type !== 12) return true;
                return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
            }
            var directiveImportMap = /* @__PURE__ */ new WeakMap();
            var transformElement = function(node, context) {
                return function postTransformElement() {
                    node = context.currentNode;
                    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
                        return;
                    }
                    var tag = node.tag, props = node.props;
                    var isComponent2 = node.tagType === 1;
                    var vnodeTag = isComponent2 ? resolveComponentType(node, context) : '"'.concat(tag, '"');
                    var isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
                    var vnodeProps;
                    var vnodeChildren;
                    var patchFlag = 0;
                    var vnodeDynamicProps;
                    var dynamicPropNames;
                    var vnodeDirectives;
                    var shouldUseBlock = // dynamic component may resolve to plain elements
                    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
                    // updates inside get proper isSVG flag at runtime. (#639, #643)
                    // This is technically web-specific, but splitting the logic out of core
                    // leads to too much unnecessary complexity.
                    (tag === "svg" || tag === "foreignObject" || tag === "math");
                    if (props.length > 0) {
                        var propsBuildResult = buildProps(node, context, void 0, isComponent2, isDynamicComponent);
                        vnodeProps = propsBuildResult.props;
                        patchFlag = propsBuildResult.patchFlag;
                        dynamicPropNames = propsBuildResult.dynamicPropNames;
                        var directives = propsBuildResult.directives;
                        vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(function(dir) {
                            return buildDirectiveArgs(dir, context);
                        })) : void 0;
                        if (propsBuildResult.shouldUseBlock) {
                            shouldUseBlock = true;
                        }
                    }
                    if (node.children.length > 0) {
                        if (vnodeTag === KEEP_ALIVE) {
                            shouldUseBlock = true;
                            patchFlag |= 1024;
                            if (node.children.length > 1) {
                                context.onError(createCompilerError(46, {
                                    start: node.children[0].loc.start,
                                    end: node.children[node.children.length - 1].loc.end,
                                    source: ""
                                }));
                            }
                        }
                        var shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
                        vnodeTag !== TELEPORT && // explained above.
                        vnodeTag !== KEEP_ALIVE;
                        if (shouldBuildAsSlots) {
                            var _buildSlots = buildSlots(node, context), slots = _buildSlots.slots, hasDynamicSlots = _buildSlots.hasDynamicSlots;
                            vnodeChildren = slots;
                            if (hasDynamicSlots) {
                                patchFlag |= 1024;
                            }
                        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                            var child = node.children[0];
                            var type = child.type;
                            var hasDynamicTextChild = type === 5 || type === 8;
                            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
                                patchFlag |= 1;
                            }
                            if (hasDynamicTextChild || type === 2) {
                                vnodeChildren = child;
                            } else {
                                vnodeChildren = node.children;
                            }
                        } else {
                            vnodeChildren = node.children;
                        }
                    }
                    if (dynamicPropNames && dynamicPropNames.length) {
                        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
                    }
                    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, patchFlag === 0 ? void 0 : patchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
                };
            };
            function resolveComponentType(node, context) {
                var ssr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var tag = node.tag;
                var isExplicitDynamic = isComponentTag(tag);
                var isProp = findProp(node, "is", false, true);
                if (isProp) {
                    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
                        var exp;
                        if (isProp.type === 6) {
                            exp = isProp.value && createSimpleExpression(isProp.value.content, true);
                        } else {
                            exp = isProp.exp;
                            if (!exp) {
                                exp = createSimpleExpression("is", false, isProp.arg.loc);
                                {
                                    exp = isProp.exp = processExpression(exp, context);
                                }
                            }
                        }
                        if (exp) {
                            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                                exp
                            ]);
                        }
                    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
                        tag = isProp.value.content.slice(4);
                    }
                }
                var builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
                if (builtIn) {
                    if (!ssr) context.helper(builtIn);
                    return builtIn;
                }
                {
                    var fromSetup = resolveSetupReference(tag, context);
                    if (fromSetup) {
                        return fromSetup;
                    }
                    var dotIndex = tag.indexOf(".");
                    if (dotIndex > 0) {
                        var ns = resolveSetupReference(tag.slice(0, dotIndex), context);
                        if (ns) {
                            return ns + tag.slice(dotIndex);
                        }
                    }
                }
                if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {
                    context.helper(RESOLVE_COMPONENT);
                    context.components.add(tag + "__self");
                    return toValidAssetId(tag, "component");
                }
                context.helper(RESOLVE_COMPONENT);
                context.components.add(tag);
                return toValidAssetId(tag, "component");
            }
            function resolveSetupReference(name, context) {
                var bindings = context.bindingMetadata;
                if (!bindings || bindings.__isScriptSetup === false) {
                    return;
                }
                var camelName = shared.camelize(name);
                var PascalName = shared.capitalize(camelName);
                var checkType = function(type) {
                    if (bindings[name] === type) {
                        return name;
                    }
                    if (bindings[camelName] === type) {
                        return camelName;
                    }
                    if (bindings[PascalName] === type) {
                        return PascalName;
                    }
                };
                var fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
                if (fromConst) {
                    return context.inline ? // in inline mode, const setup bindings (e.g. imports) can be used as-is
                    fromConst : "$setup[".concat(JSON.stringify(fromConst), "]");
                }
                var fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
                if (fromMaybeRef) {
                    return context.inline ? // setup scope bindings that may be refs need to be unrefed
                    "".concat(context.helperString(UNREF), "(").concat(fromMaybeRef, ")") : "$setup[".concat(JSON.stringify(fromMaybeRef), "]");
                }
                var fromProps = checkType("props");
                if (fromProps) {
                    return "".concat(context.helperString(UNREF), "(").concat(context.inline ? "__props" : "$props", "[").concat(JSON.stringify(fromProps), "])");
                }
            }
            function buildProps(node, context) {
                var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : node.props, isComponent2 = arguments.length > 3 ? arguments[3] : void 0, isDynamicComponent = arguments.length > 4 ? arguments[4] : void 0, ssr = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                var tag = node.tag, elementLoc = node.loc, children = node.children;
                var properties = [];
                var mergeArgs = [];
                var runtimeDirectives = [];
                var hasChildren = children.length > 0;
                var shouldUseBlock = false;
                var patchFlag = 0;
                var hasRef = false;
                var hasClassBinding = false;
                var hasStyleBinding = false;
                var hasHydrationEventBinding = false;
                var hasDynamicKeys = false;
                var hasVnodeHook = false;
                var dynamicPropNames = [];
                var pushMergeArg = function(arg) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (arg) mergeArgs.push(arg);
                };
                var pushRefVForMarker = function() {
                    if (context.scopes.vFor > 0) {
                        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
                    }
                };
                var analyzePatchFlag = function(param) {
                    var key = param.key, value = param.value;
                    if (isStaticExp(key)) {
                        var name = key.content;
                        var isEventHandler = shared.isOn(name);
                        if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
                        // dedicated fast path.
                        name.toLowerCase() !== "onclick" && // omit v-model handlers
                        name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
                        !shared.isReservedProp(name)) {
                            hasHydrationEventBinding = true;
                        }
                        if (isEventHandler && shared.isReservedProp(name)) {
                            hasVnodeHook = true;
                        }
                        if (isEventHandler && value.type === 14) {
                            value = value.arguments[0];
                        }
                        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
                            return;
                        }
                        if (name === "ref") {
                            hasRef = true;
                        } else if (name === "class") {
                            hasClassBinding = true;
                        } else if (name === "style") {
                            hasStyleBinding = true;
                        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
                            dynamicPropNames.push(name);
                        }
                        if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
                            dynamicPropNames.push(name);
                        }
                    } else {
                        hasDynamicKeys = true;
                    }
                };
                for(var i = 0; i < props.length; i++){
                    var prop = props[i];
                    if (prop.type === 6) {
                        var loc = prop.loc, name = prop.name, nameLoc = prop.nameLoc, value = prop.value;
                        var isStatic = true;
                        if (name === "ref") {
                            hasRef = true;
                            pushRefVForMarker();
                            if (value && context.inline) {
                                var binding = context.bindingMetadata[value.content];
                                if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
                                    isStatic = false;
                                    properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
                                }
                            }
                        }
                        if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
                            continue;
                        }
                        properties.push(createObjectProperty(createSimpleExpression(name, true, nameLoc), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
                    } else {
                        var name1 = prop.name, arg = prop.arg, exp = prop.exp, loc1 = prop.loc, modifiers = prop.modifiers;
                        var isVBind = name1 === "bind";
                        var isVOn = name1 === "on";
                        if (name1 === "slot") {
                            if (!isComponent2) {
                                context.onError(createCompilerError(40, loc1));
                            }
                            continue;
                        }
                        if (name1 === "once" || name1 === "memo") {
                            continue;
                        }
                        if (name1 === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
                            continue;
                        }
                        if (isVOn && ssr) {
                            continue;
                        }
                        if (// #938: elements with dynamic keys should be forced into blocks
                        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
                        // before children
                        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
                            shouldUseBlock = true;
                        }
                        if (isVBind && isStaticArgOf(arg, "ref")) {
                            pushRefVForMarker();
                        }
                        if (!arg && (isVBind || isVOn)) {
                            hasDynamicKeys = true;
                            if (exp) {
                                if (isVBind) {
                                    pushRefVForMarker();
                                    pushMergeArg();
                                    {
                                        {
                                            var hasOverridableKeys = mergeArgs.some(function(arg2) {
                                                if (arg2.type === 15) {
                                                    return arg2.properties.some(function(param) {
                                                        var key = param.key;
                                                        if (key.type !== 4 || !key.isStatic) {
                                                            return true;
                                                        }
                                                        return key.content !== "class" && key.content !== "style" && !shared.isOn(key.content);
                                                    });
                                                } else {
                                                    return true;
                                                }
                                            });
                                            if (hasOverridableKeys) {
                                                checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc1);
                                            }
                                        }
                                        if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                                            mergeArgs.unshift(exp);
                                            continue;
                                        }
                                    }
                                    mergeArgs.push(exp);
                                } else {
                                    pushMergeArg({
                                        type: 14,
                                        loc: loc1,
                                        callee: context.helper(TO_HANDLERS),
                                        arguments: isComponent2 ? [
                                            exp
                                        ] : [
                                            exp,
                                            "true"
                                        ]
                                    });
                                }
                            } else {
                                context.onError(createCompilerError(isVBind ? 34 : 35, loc1));
                            }
                            continue;
                        }
                        if (isVBind && modifiers.some(function(mod) {
                            return mod.content === "prop";
                        })) {
                            patchFlag |= 32;
                        }
                        var directiveTransform = context.directiveTransforms[name1];
                        if (directiveTransform) {
                            var _directiveTransform = directiveTransform(prop, node, context), props2 = _directiveTransform.props, needRuntime = _directiveTransform.needRuntime;
                            !ssr && props2.forEach(analyzePatchFlag);
                            if (isVOn && arg && !isStaticExp(arg)) {
                                pushMergeArg(createObjectExpression(props2, elementLoc));
                            } else {
                                var _properties;
                                (_properties = properties).push.apply(_properties, _to_consumable_array(props2));
                            }
                            if (needRuntime) {
                                runtimeDirectives.push(prop);
                                if (shared.isSymbol(needRuntime)) {
                                    directiveImportMap.set(prop, needRuntime);
                                }
                            }
                        } else if (!shared.isBuiltInDirective(name1)) {
                            runtimeDirectives.push(prop);
                            if (hasChildren) {
                                shouldUseBlock = true;
                            }
                        }
                    }
                }
                var propsExpression = void 0;
                if (mergeArgs.length) {
                    pushMergeArg();
                    if (mergeArgs.length > 1) {
                        propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
                    } else {
                        propsExpression = mergeArgs[0];
                    }
                } else if (properties.length) {
                    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
                }
                if (hasDynamicKeys) {
                    patchFlag |= 16;
                } else {
                    if (hasClassBinding && !isComponent2) {
                        patchFlag |= 2;
                    }
                    if (hasStyleBinding && !isComponent2) {
                        patchFlag |= 4;
                    }
                    if (dynamicPropNames.length) {
                        patchFlag |= 8;
                    }
                    if (hasHydrationEventBinding) {
                        patchFlag |= 32;
                    }
                }
                if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
                    patchFlag |= 512;
                }
                if (!context.inSSR && propsExpression) {
                    switch(propsExpression.type){
                        case 15:
                            var classKeyIndex = -1;
                            var styleKeyIndex = -1;
                            var hasDynamicKey = false;
                            for(var i1 = 0; i1 < propsExpression.properties.length; i1++){
                                var key = propsExpression.properties[i1].key;
                                if (isStaticExp(key)) {
                                    if (key.content === "class") {
                                        classKeyIndex = i1;
                                    } else if (key.content === "style") {
                                        styleKeyIndex = i1;
                                    }
                                } else if (!key.isHandlerKey) {
                                    hasDynamicKey = true;
                                }
                            }
                            var classProp = propsExpression.properties[classKeyIndex];
                            var styleProp = propsExpression.properties[styleKeyIndex];
                            if (!hasDynamicKey) {
                                if (classProp && !isStaticExp(classProp.value)) {
                                    classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [
                                        classProp.value
                                    ]);
                                }
                                if (styleProp && // the static style is compiled into an object,
                                // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                                (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
                                // v-bind:style with static literal object
                                styleProp.value.type === 17)) {
                                    styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [
                                        styleProp.value
                                    ]);
                                }
                            } else {
                                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                                    propsExpression
                                ]);
                            }
                            break;
                        case 14:
                            break;
                        default:
                            propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                                createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                                    propsExpression
                                ])
                            ]);
                            break;
                    }
                }
                return {
                    props: propsExpression,
                    directives: runtimeDirectives,
                    patchFlag: patchFlag,
                    dynamicPropNames: dynamicPropNames,
                    shouldUseBlock: shouldUseBlock
                };
            }
            function dedupeProperties(properties) {
                var knownProps = /* @__PURE__ */ new Map();
                var deduped = [];
                for(var i = 0; i < properties.length; i++){
                    var prop = properties[i];
                    if (prop.key.type === 8 || !prop.key.isStatic) {
                        deduped.push(prop);
                        continue;
                    }
                    var name = prop.key.content;
                    var existing = knownProps.get(name);
                    if (existing) {
                        if (name === "style" || name === "class" || shared.isOn(name)) {
                            mergeAsArray(existing, prop);
                        }
                    } else {
                        knownProps.set(name, prop);
                        deduped.push(prop);
                    }
                }
                return deduped;
            }
            function mergeAsArray(existing, incoming) {
                if (existing.value.type === 17) {
                    existing.value.elements.push(incoming.value);
                } else {
                    existing.value = createArrayExpression([
                        existing.value,
                        incoming.value
                    ], existing.loc);
                }
            }
            function buildDirectiveArgs(dir, context) {
                var dirArgs = [];
                var runtime = directiveImportMap.get(dir);
                if (runtime) {
                    dirArgs.push(context.helperString(runtime));
                } else {
                    var fromSetup = resolveSetupReference("v-" + dir.name, context);
                    if (fromSetup) {
                        dirArgs.push(fromSetup);
                    } else {
                        context.helper(RESOLVE_DIRECTIVE);
                        context.directives.add(dir.name);
                        dirArgs.push(toValidAssetId(dir.name, "directive"));
                    }
                }
                var loc = dir.loc;
                if (dir.exp) dirArgs.push(dir.exp);
                if (dir.arg) {
                    if (!dir.exp) {
                        dirArgs.push("void 0");
                    }
                    dirArgs.push(dir.arg);
                }
                if (Object.keys(dir.modifiers).length) {
                    if (!dir.arg) {
                        if (!dir.exp) {
                            dirArgs.push("void 0");
                        }
                        dirArgs.push("void 0");
                    }
                    var trueExpression = createSimpleExpression("true", false, loc);
                    dirArgs.push(createObjectExpression(dir.modifiers.map(function(modifier) {
                        return createObjectProperty(modifier, trueExpression);
                    }), loc));
                }
                return createArrayExpression(dirArgs, dir.loc);
            }
            function stringifyDynamicPropNames(props) {
                var propsNamesString = "[";
                for(var i = 0, l = props.length; i < l; i++){
                    propsNamesString += JSON.stringify(props[i]);
                    if (i < l - 1) propsNamesString += ", ";
                }
                return propsNamesString + "]";
            }
            function isComponentTag(tag) {
                return tag === "component" || tag === "Component";
            }
            var transformSlotOutlet = function(node, context) {
                if (isSlotOutlet(node)) {
                    var children = node.children, loc = node.loc;
                    var _processSlotOutlet = processSlotOutlet(node, context), slotName = _processSlotOutlet.slotName, slotProps = _processSlotOutlet.slotProps;
                    var slotArgs = [
                        context.prefixIdentifiers ? "_ctx.$slots" : "$slots",
                        slotName,
                        "{}",
                        "undefined",
                        "true"
                    ];
                    var expectedLen = 2;
                    if (slotProps) {
                        slotArgs[2] = slotProps;
                        expectedLen = 3;
                    }
                    if (children.length) {
                        slotArgs[3] = createFunctionExpression([], children, false, false, loc);
                        expectedLen = 4;
                    }
                    if (context.scopeId && !context.slotted) {
                        expectedLen = 5;
                    }
                    slotArgs.splice(expectedLen);
                    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
                }
            };
            function processSlotOutlet(node, context) {
                var slotName = '"default"';
                var slotProps = void 0;
                var nonNameProps = [];
                for(var i = 0; i < node.props.length; i++){
                    var p = node.props[i];
                    if (p.type === 6) {
                        if (p.value) {
                            if (p.name === "name") {
                                slotName = JSON.stringify(p.value.content);
                            } else {
                                p.name = shared.camelize(p.name);
                                nonNameProps.push(p);
                            }
                        }
                    } else {
                        if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
                            if (p.exp) {
                                slotName = p.exp;
                            } else if (p.arg && p.arg.type === 4) {
                                var name = shared.camelize(p.arg.content);
                                slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
                                {
                                    slotName = p.exp = processExpression(p.exp, context);
                                }
                            }
                        } else {
                            if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
                                p.arg.content = shared.camelize(p.arg.content);
                            }
                            nonNameProps.push(p);
                        }
                    }
                }
                if (nonNameProps.length > 0) {
                    var _buildProps = buildProps(node, context, nonNameProps, false, false), props = _buildProps.props, directives = _buildProps.directives;
                    slotProps = props;
                    if (directives.length) {
                        context.onError(createCompilerError(36, directives[0].loc));
                    }
                }
                return {
                    slotName: slotName,
                    slotProps: slotProps
                };
            }
            var transformOn = function(dir, node, context, augmentor) {
                var loc = dir.loc, modifiers = dir.modifiers, arg = dir.arg;
                if (!dir.exp && !modifiers.length) {
                    context.onError(createCompilerError(35, loc));
                }
                var eventName;
                if (arg.type === 4) {
                    if (arg.isStatic) {
                        var rawName = arg.content;
                        if (rawName.startsWith("vnode")) {
                            context.onError(createCompilerError(51, arg.loc));
                        }
                        if (rawName.startsWith("vue:")) {
                            rawName = "vnode-".concat(rawName.slice(4));
                        }
                        var eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? // for non-element and vnode lifecycle event listeners, auto convert
                        // it to camelCase. See issue #2249
                        shared.toHandlerKey(shared.camelize(rawName)) : // preserve case for plain element listeners that have uppercase
                        // letters, as these may be custom elements' custom events
                        "on:".concat(rawName);
                        eventName = createSimpleExpression(eventString, true, arg.loc);
                    } else {
                        eventName = createCompoundExpression([
                            "".concat(context.helperString(TO_HANDLER_KEY), "("),
                            arg,
                            ")"
                        ]);
                    }
                } else {
                    eventName = arg;
                    eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY), "("));
                    eventName.children.push(")");
                }
                var exp = dir.exp;
                if (exp && !exp.content.trim()) {
                    exp = void 0;
                }
                var shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
                if (exp) {
                    var isMemberExp = isMemberExpression(exp, context);
                    var isInlineStatement = !(isMemberExp || isFnExpression(exp, context));
                    var hasMultipleStatements = exp.content.includes(";");
                    if (context.prefixIdentifiers) {
                        isInlineStatement && context.addIdentifiers("$event");
                        exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
                        isInlineStatement && context.removeIdentifiers("$event");
                        shouldCache = context.cacheHandlers && // unnecessary to cache inside v-once
                        !context.inVOnce && // runtime constants don't need to be cached
                        // (this is analyzed by compileScript in SFC <script setup>)
                        !(exp.type === 4 && exp.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
                        // we need to use the original function to preserve arity,
                        // e.g. <transition> relies on checking cb.length to determine
                        // transition end handling. Inline function is ok since its arity
                        // is preserved even when cached.
                        !(isMemberExp && node.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
                        // it must be passed fresh to avoid stale values.
                        !hasScopeRef(exp, context.identifiers);
                        if (shouldCache && isMemberExp) {
                            if (exp.type === 4) {
                                exp.content = "".concat(exp.content, " && ").concat(exp.content, "(...args)");
                            } else {
                                exp.children = _to_consumable_array(exp.children).concat([
                                    " && "
                                ], _to_consumable_array(exp.children), [
                                    "(...args)"
                                ]);
                            }
                        }
                    }
                    if (isInlineStatement || shouldCache && isMemberExp) {
                        exp = createCompoundExpression([
                            "".concat(isInlineStatement ? context.isTS ? "($event: any)" : "$event" : "".concat(context.isTS ? "\n//@ts-ignore\n" : "", "(...args)"), " => ").concat(hasMultipleStatements ? "{" : "("),
                            exp,
                            hasMultipleStatements ? "}" : ")"
                        ]);
                    }
                }
                var ret = {
                    props: [
                        createObjectProperty(eventName, exp || createSimpleExpression("() => {}", false, loc))
                    ]
                };
                if (augmentor) {
                    ret = augmentor(ret);
                }
                if (shouldCache) {
                    ret.props[0].value = context.cache(ret.props[0].value);
                }
                ret.props.forEach(function(p) {
                    return p.key.isHandlerKey = true;
                });
                return ret;
            };
            var transformText = function(node, context) {
                if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
                    return function() {
                        var children = node.children;
                        var currentContainer = void 0;
                        var hasText = false;
                        for(var i = 0; i < children.length; i++){
                            var child = children[i];
                            if (isText$1(child)) {
                                hasText = true;
                                for(var j = i + 1; j < children.length; j++){
                                    var next = children[j];
                                    if (isText$1(next)) {
                                        if (!currentContainer) {
                                            currentContainer = children[i] = createCompoundExpression([
                                                child
                                            ], child.loc);
                                        }
                                        currentContainer.children.push(" + ", next);
                                        children.splice(j, 1);
                                        j--;
                                    } else {
                                        currentContainer = void 0;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!hasText || // if this is a plain element with a single text child, leave it
                        // as-is since the runtime has dedicated fast path for this by directly
                        // setting textContent of the element.
                        // for component root it's always normalized anyway.
                        children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
                        // custom directives can potentially add DOM elements arbitrarily,
                        // we need to avoid setting textContent of the element at runtime
                        // to avoid accidentally overwriting the DOM elements added
                        // by the user through custom directives.
                        !node.props.find(function(p) {
                            return p.type === 7 && !context.directiveTransforms[p.name];
                        }) && // in compat mode, <template> tags with no special directives
                        // will be rendered as a fragment so its children must be
                        // converted into vnodes.
                        !(node.tag === "template"))) {
                            return;
                        }
                        for(var i1 = 0; i1 < children.length; i1++){
                            var child1 = children[i1];
                            if (isText$1(child1) || child1.type === 8) {
                                var callArgs = [];
                                if (child1.type !== 2 || child1.content !== " ") {
                                    callArgs.push(child1);
                                }
                                if (!context.ssr && getConstantType(child1, context) === 0) {
                                    callArgs.push("1 /* ".concat(shared.PatchFlagNames[1], " */"));
                                }
                                children[i1] = {
                                    type: 12,
                                    content: child1,
                                    loc: child1.loc,
                                    codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                                };
                            }
                        }
                    };
                }
            };
            var seen$1 = /* @__PURE__ */ new WeakSet();
            var transformOnce = function(node, context) {
                if (node.type === 1 && findDir(node, "once", true)) {
                    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
                        return;
                    }
                    seen$1.add(node);
                    context.inVOnce = true;
                    context.helper(SET_BLOCK_TRACKING);
                    return function() {
                        context.inVOnce = false;
                        var cur = context.currentNode;
                        if (cur.codegenNode) {
                            cur.codegenNode = context.cache(cur.codegenNode, true, true);
                        }
                    };
                }
            };
            var transformModel = function(dir, node, context) {
                var exp = dir.exp, arg = dir.arg;
                if (!exp) {
                    context.onError(createCompilerError(41, dir.loc));
                    return createTransformProps();
                }
                var rawExp = exp.loc.source.trim();
                var expString = exp.type === 4 ? exp.content : rawExp;
                var bindingType = context.bindingMetadata[rawExp];
                if (bindingType === "props" || bindingType === "props-aliased") {
                    context.onError(createCompilerError(44, exp.loc));
                    return createTransformProps();
                }
                var maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
                if (!expString.trim() || !isMemberExpression(exp, context) && !maybeRef) {
                    context.onError(createCompilerError(42, exp.loc));
                    return createTransformProps();
                }
                if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
                    context.onError(createCompilerError(43, exp.loc));
                    return createTransformProps();
                }
                var propName = arg ? arg : createSimpleExpression("modelValue", true);
                var eventName = arg ? isStaticExp(arg) ? "onUpdate:".concat(shared.camelize(arg.content)) : createCompoundExpression([
                    '"onUpdate:" + ',
                    arg
                ]) : "onUpdate:modelValue";
                var assignmentExp;
                var eventArg = context.isTS ? "($event: any)" : "$event";
                if (maybeRef) {
                    if (bindingType === "setup-ref") {
                        assignmentExp = createCompoundExpression([
                            "".concat(eventArg, " => (("),
                            createSimpleExpression(rawExp, false, exp.loc),
                            ").value = $event)"
                        ]);
                    } else {
                        var altAssignment = bindingType === "setup-let" ? "".concat(rawExp, " = $event") : "null";
                        assignmentExp = createCompoundExpression([
                            "".concat(eventArg, " => (").concat(context.helperString(IS_REF), "(").concat(rawExp, ") ? ("),
                            createSimpleExpression(rawExp, false, exp.loc),
                            ").value = $event : ".concat(altAssignment, ")")
                        ]);
                    }
                } else {
                    assignmentExp = createCompoundExpression([
                        "".concat(eventArg, " => (("),
                        exp,
                        ") = $event)"
                    ]);
                }
                var props = [
                    // modelValue: foo
                    createObjectProperty(propName, dir.exp),
                    // "onUpdate:modelValue": $event => (foo = $event)
                    createObjectProperty(eventName, assignmentExp)
                ];
                if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
                    props[1].value = context.cache(props[1].value);
                }
                if (dir.modifiers.length && node.tagType === 1) {
                    var modifiers = dir.modifiers.map(function(m) {
                        return m.content;
                    }).map(function(m) {
                        return (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + ": true";
                    }).join(", ");
                    var modifiersKey = arg ? isStaticExp(arg) ? "".concat(arg.content, "Modifiers") : createCompoundExpression([
                        arg,
                        ' + "Modifiers"'
                    ]) : "modelModifiers";
                    props.push(createObjectProperty(modifiersKey, createSimpleExpression("{ ".concat(modifiers, " }"), false, dir.loc, 2)));
                }
                return createTransformProps(props);
            };
            function createTransformProps() {
                var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                return {
                    props: props
                };
            }
            var validDivisionCharRE = /[\w).+\-_$\]]/;
            var transformFilter = function(node, context) {
                if (!isCompatEnabled("COMPILER_FILTERS", context)) {
                    return;
                }
                if (node.type === 5) {
                    rewriteFilter(node.content, context);
                } else if (node.type === 1) {
                    node.props.forEach(function(prop) {
                        if (prop.type === 7 && prop.name !== "for" && prop.exp) {
                            rewriteFilter(prop.exp, context);
                        }
                    });
                }
            };
            function rewriteFilter(node, context) {
                if (node.type === 4) {
                    parseFilter(node, context);
                } else {
                    for(var i = 0; i < node.children.length; i++){
                        var child = node.children[i];
                        if ((typeof child === "undefined" ? "undefined" : _type_of(child)) !== "object") continue;
                        if (child.type === 4) {
                            parseFilter(child, context);
                        } else if (child.type === 8) {
                            rewriteFilter(node, context);
                        } else if (child.type === 5) {
                            rewriteFilter(child.content, context);
                        }
                    }
                }
            }
            function parseFilter(node, context) {
                var exp = node.content;
                var inSingle = false;
                var inDouble = false;
                var inTemplateString = false;
                var inRegex = false;
                var curly = 0;
                var square = 0;
                var paren = 0;
                var lastFilterIndex = 0;
                var c, prev, i, expression, filters = [];
                for(i = 0; i < exp.length; i++){
                    prev = c;
                    c = exp.charCodeAt(i);
                    if (inSingle) {
                        if (c === 39 && prev !== 92) inSingle = false;
                    } else if (inDouble) {
                        if (c === 34 && prev !== 92) inDouble = false;
                    } else if (inTemplateString) {
                        if (c === 96 && prev !== 92) inTemplateString = false;
                    } else if (inRegex) {
                        if (c === 47 && prev !== 92) inRegex = false;
                    } else if (c === 124 && // pipe
                    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
                        if (expression === void 0) {
                            lastFilterIndex = i + 1;
                            expression = exp.slice(0, i).trim();
                        } else {
                            pushFilter();
                        }
                    } else {
                        switch(c){
                            case 34:
                                inDouble = true;
                                break;
                            // "
                            case 39:
                                inSingle = true;
                                break;
                            // '
                            case 96:
                                inTemplateString = true;
                                break;
                            // `
                            case 40:
                                paren++;
                                break;
                            // (
                            case 41:
                                paren--;
                                break;
                            // )
                            case 91:
                                square++;
                                break;
                            // [
                            case 93:
                                square--;
                                break;
                            // ]
                            case 123:
                                curly++;
                                break;
                            // {
                            case 125:
                                curly--;
                                break;
                        }
                        if (c === 47) {
                            var j = i - 1;
                            var p = void 0;
                            for(; j >= 0; j--){
                                p = exp.charAt(j);
                                if (p !== " ") break;
                            }
                            if (!p || !validDivisionCharRE.test(p)) {
                                inRegex = true;
                            }
                        }
                    }
                }
                if (expression === void 0) {
                    expression = exp.slice(0, i).trim();
                } else if (lastFilterIndex !== 0) {
                    pushFilter();
                }
                function pushFilter() {
                    filters.push(exp.slice(lastFilterIndex, i).trim());
                    lastFilterIndex = i + 1;
                }
                if (filters.length) {
                    warnDeprecation("COMPILER_FILTERS", context, node.loc);
                    for(i = 0; i < filters.length; i++){
                        expression = wrapFilter(expression, filters[i], context);
                    }
                    node.content = expression;
                    node.ast = void 0;
                }
            }
            function wrapFilter(exp, filter, context) {
                context.helper(RESOLVE_FILTER);
                var i = filter.indexOf("(");
                if (i < 0) {
                    context.filters.add(filter);
                    return "".concat(toValidAssetId(filter, "filter"), "(").concat(exp, ")");
                } else {
                    var name = filter.slice(0, i);
                    var args = filter.slice(i + 1);
                    context.filters.add(name);
                    return "".concat(toValidAssetId(name, "filter"), "(").concat(exp).concat(args !== ")" ? "," + args : args);
                }
            }
            var seen = /* @__PURE__ */ new WeakSet();
            var transformMemo = function(node, context) {
                if (node.type === 1) {
                    var dir = findDir(node, "memo");
                    if (!dir || seen.has(node)) {
                        return;
                    }
                    seen.add(node);
                    return function() {
                        var codegenNode = node.codegenNode || context.currentNode.codegenNode;
                        if (codegenNode && codegenNode.type === 13) {
                            if (node.tagType !== 1) {
                                convertToBlock(codegenNode, context);
                            }
                            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                                dir.exp,
                                createFunctionExpression(void 0, codegenNode),
                                "_cache",
                                String(context.cached.length)
                            ]);
                            context.cached.push(null);
                        }
                    };
                }
            };
            function getBaseTransformPreset(prefixIdentifiers) {
                return [
                    [
                        transformOnce,
                        transformIf,
                        transformMemo,
                        transformFor
                    ].concat(_to_consumable_array([
                        transformFilter
                    ]), _to_consumable_array(prefixIdentifiers ? [
                        // order is important
                        trackVForSlotScopes,
                        transformExpression
                    ] : []), [
                        transformSlotOutlet,
                        transformElement,
                        trackSlotScopes,
                        transformText
                    ]),
                    {
                        on: transformOn,
                        bind: transformBind,
                        model: transformModel
                    }
                ];
            }
            function baseCompile(source) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var onError = options.onError || defaultOnError;
                var isModuleMode = options.mode === "module";
                var prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
                if (!prefixIdentifiers && options.cacheHandlers) {
                    onError(createCompilerError(49));
                }
                if (options.scopeId && !isModuleMode) {
                    onError(createCompilerError(50));
                }
                var resolvedOptions = shared.extend({}, options, {
                    prefixIdentifiers: prefixIdentifiers
                });
                var ast = shared.isString(source) ? baseParse(source, resolvedOptions) : source;
                var _getBaseTransformPreset = _sliced_to_array(getBaseTransformPreset(prefixIdentifiers), 2), nodeTransforms = _getBaseTransformPreset[0], directiveTransforms = _getBaseTransformPreset[1];
                if (options.isTS) {
                    var expressionPlugins = options.expressionPlugins;
                    if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
                        options.expressionPlugins = _to_consumable_array(expressionPlugins || []).concat([
                            "typescript"
                        ]);
                    }
                }
                transform(ast, shared.extend({}, resolvedOptions, {
                    nodeTransforms: _to_consumable_array(nodeTransforms).concat(_to_consumable_array(options.nodeTransforms || [])),
                    directiveTransforms: shared.extend({}, directiveTransforms, options.directiveTransforms || {})
                }));
                return generate(ast, resolvedOptions);
            }
            var BindingTypes = {
                "DATA": "data",
                "PROPS": "props",
                "PROPS_ALIASED": "props-aliased",
                "SETUP_LET": "setup-let",
                "SETUP_CONST": "setup-const",
                "SETUP_REACTIVE_CONST": "setup-reactive-const",
                "SETUP_MAYBE_REF": "setup-maybe-ref",
                "SETUP_REF": "setup-ref",
                "OPTIONS": "options",
                "LITERAL_CONST": "literal-const"
            };
            var noopDirectiveTransform = function() {
                return {
                    props: []
                };
            };
            exports.generateCodeFrame = shared.generateCodeFrame;
            exports.BASE_TRANSITION = BASE_TRANSITION;
            exports.BindingTypes = BindingTypes;
            exports.CAMELIZE = CAMELIZE;
            exports.CAPITALIZE = CAPITALIZE;
            exports.CREATE_BLOCK = CREATE_BLOCK;
            exports.CREATE_COMMENT = CREATE_COMMENT;
            exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
            exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
            exports.CREATE_SLOTS = CREATE_SLOTS;
            exports.CREATE_STATIC = CREATE_STATIC;
            exports.CREATE_TEXT = CREATE_TEXT;
            exports.CREATE_VNODE = CREATE_VNODE;
            exports.CompilerDeprecationTypes = CompilerDeprecationTypes;
            exports.ConstantTypes = ConstantTypes;
            exports.ElementTypes = ElementTypes;
            exports.ErrorCodes = ErrorCodes;
            exports.FRAGMENT = FRAGMENT;
            exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
            exports.IS_MEMO_SAME = IS_MEMO_SAME;
            exports.IS_REF = IS_REF;
            exports.KEEP_ALIVE = KEEP_ALIVE;
            exports.MERGE_PROPS = MERGE_PROPS;
            exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
            exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
            exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
            exports.Namespaces = Namespaces;
            exports.NodeTypes = NodeTypes;
            exports.OPEN_BLOCK = OPEN_BLOCK;
            exports.POP_SCOPE_ID = POP_SCOPE_ID;
            exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
            exports.RENDER_LIST = RENDER_LIST;
            exports.RENDER_SLOT = RENDER_SLOT;
            exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
            exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
            exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
            exports.RESOLVE_FILTER = RESOLVE_FILTER;
            exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
            exports.SUSPENSE = SUSPENSE;
            exports.TELEPORT = TELEPORT;
            exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
            exports.TO_HANDLERS = TO_HANDLERS;
            exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
            exports.TS_NODE_TYPES = TS_NODE_TYPES;
            exports.UNREF = UNREF;
            exports.WITH_CTX = WITH_CTX;
            exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
            exports.WITH_MEMO = WITH_MEMO;
            exports.advancePositionWithClone = advancePositionWithClone;
            exports.advancePositionWithMutation = advancePositionWithMutation;
            exports.assert = assert;
            exports.baseCompile = baseCompile;
            exports.baseParse = baseParse;
            exports.buildDirectiveArgs = buildDirectiveArgs;
            exports.buildProps = buildProps;
            exports.buildSlots = buildSlots;
            exports.checkCompatEnabled = checkCompatEnabled;
            exports.convertToBlock = convertToBlock;
            exports.createArrayExpression = createArrayExpression;
            exports.createAssignmentExpression = createAssignmentExpression;
            exports.createBlockStatement = createBlockStatement;
            exports.createCacheExpression = createCacheExpression;
            exports.createCallExpression = createCallExpression;
            exports.createCompilerError = createCompilerError;
            exports.createCompoundExpression = createCompoundExpression;
            exports.createConditionalExpression = createConditionalExpression;
            exports.createForLoopParams = createForLoopParams;
            exports.createFunctionExpression = createFunctionExpression;
            exports.createIfStatement = createIfStatement;
            exports.createInterpolation = createInterpolation;
            exports.createObjectExpression = createObjectExpression;
            exports.createObjectProperty = createObjectProperty;
            exports.createReturnStatement = createReturnStatement;
            exports.createRoot = createRoot;
            exports.createSequenceExpression = createSequenceExpression;
            exports.createSimpleExpression = createSimpleExpression;
            exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
            exports.createTemplateLiteral = createTemplateLiteral;
            exports.createTransformContext = createTransformContext;
            exports.createVNodeCall = createVNodeCall;
            exports.errorMessages = errorMessages;
            exports.extractIdentifiers = extractIdentifiers;
            exports.findDir = findDir;
            exports.findProp = findProp;
            exports.forAliasRE = forAliasRE;
            exports.generate = generate;
            exports.getBaseTransformPreset = getBaseTransformPreset;
            exports.getConstantType = getConstantType;
            exports.getMemoedVNodeCall = getMemoedVNodeCall;
            exports.getVNodeBlockHelper = getVNodeBlockHelper;
            exports.getVNodeHelper = getVNodeHelper;
            exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
            exports.hasScopeRef = hasScopeRef;
            exports.helperNameMap = helperNameMap;
            exports.injectProp = injectProp;
            exports.isCoreComponent = isCoreComponent;
            exports.isFnExpression = isFnExpression;
            exports.isFnExpressionBrowser = isFnExpressionBrowser;
            exports.isFnExpressionNode = isFnExpressionNode;
            exports.isFunctionType = isFunctionType;
            exports.isInDestructureAssignment = isInDestructureAssignment;
            exports.isInNewExpression = isInNewExpression;
            exports.isMemberExpression = isMemberExpression;
            exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
            exports.isMemberExpressionNode = isMemberExpressionNode;
            exports.isReferencedIdentifier = isReferencedIdentifier;
            exports.isSimpleIdentifier = isSimpleIdentifier;
            exports.isSlotOutlet = isSlotOutlet;
            exports.isStaticArgOf = isStaticArgOf;
            exports.isStaticExp = isStaticExp;
            exports.isStaticProperty = isStaticProperty;
            exports.isStaticPropertyKey = isStaticPropertyKey;
            exports.isTemplateNode = isTemplateNode;
            exports.isText = isText$1;
            exports.isVSlot = isVSlot;
            exports.locStub = locStub;
            exports.noopDirectiveTransform = noopDirectiveTransform;
            exports.processExpression = processExpression;
            exports.processFor = processFor;
            exports.processIf = processIf;
            exports.processSlotOutlet = processSlotOutlet;
            exports.registerRuntimeHelpers = registerRuntimeHelpers;
            exports.resolveComponentType = resolveComponentType;
            exports.stringifyExpression = stringifyExpression;
            exports.toValidAssetId = toValidAssetId;
            exports.trackSlotScopes = trackSlotScopes;
            exports.trackVForSlotScopes = trackVForSlotScopes;
            exports.transform = transform;
            exports.transformBind = transformBind;
            exports.transformElement = transformElement;
            exports.transformExpression = transformExpression;
            exports.transformModel = transformModel;
            exports.transformOn = transformOn;
            exports.traverseNode = traverseNode;
            exports.unwrapTSNode = unwrapTSNode;
            exports.walkBlockDeclarations = walkBlockDeclarations;
            exports.walkFunctionParams = walkFunctionParams;
            exports.walkIdentifiers = walkIdentifiers;
            exports.warnDeprecation = warnDeprecation;
        }
    });
    // ../../node_modules/.pnpm/@vue+compiler-core@3.5.13/node_modules/@vue/compiler-core/index.js
    var require_compiler_core = __commonJS({
        "../../node_modules/.pnpm/@vue+compiler-core@3.5.13/node_modules/@vue/compiler-core/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_compiler_core_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/@vue+compiler-dom@3.5.13/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js
    var require_compiler_dom_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+compiler-dom@3.5.13/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var compilerCore = require_compiler_core();
            var shared = require_shared();
            var V_MODEL_RADIO = Symbol("vModelRadio");
            var V_MODEL_CHECKBOX = Symbol("vModelCheckbox");
            var V_MODEL_TEXT = Symbol("vModelText");
            var V_MODEL_SELECT = Symbol("vModelSelect");
            var V_MODEL_DYNAMIC = Symbol("vModelDynamic");
            var V_ON_WITH_MODIFIERS = Symbol("vOnModifiersGuard");
            var V_ON_WITH_KEYS = Symbol("vOnKeysGuard");
            var V_SHOW = Symbol("vShow");
            var TRANSITION = Symbol("Transition");
            var TRANSITION_GROUP = Symbol("TransitionGroup");
            var _obj;
            compilerCore.registerRuntimeHelpers((_obj = {}, _define_property(_obj, V_MODEL_RADIO, "vModelRadio"), _define_property(_obj, V_MODEL_CHECKBOX, "vModelCheckbox"), _define_property(_obj, V_MODEL_TEXT, "vModelText"), _define_property(_obj, V_MODEL_SELECT, "vModelSelect"), _define_property(_obj, V_MODEL_DYNAMIC, "vModelDynamic"), _define_property(_obj, V_ON_WITH_MODIFIERS, "withModifiers"), _define_property(_obj, V_ON_WITH_KEYS, "withKeys"), _define_property(_obj, V_SHOW, "vShow"), _define_property(_obj, TRANSITION, "Transition"), _define_property(_obj, TRANSITION_GROUP, "TransitionGroup"), _obj));
            var parserOptions = {
                parseMode: "html",
                isVoidTag: shared.isVoidTag,
                isNativeTag: function(tag) {
                    return shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag);
                },
                isPreTag: function(tag) {
                    return tag === "pre";
                },
                isIgnoreNewlineTag: function(tag) {
                    return tag === "pre" || tag === "textarea";
                },
                decodeEntities: void 0,
                isBuiltInComponent: function(tag) {
                    if (tag === "Transition" || tag === "transition") {
                        return TRANSITION;
                    } else if (tag === "TransitionGroup" || tag === "transition-group") {
                        return TRANSITION_GROUP;
                    }
                },
                // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
                getNamespace: function getNamespace(tag, parent, rootNamespace) {
                    var ns = parent ? parent.ns : rootNamespace;
                    if (parent && ns === 2) {
                        if (parent.tag === "annotation-xml") {
                            if (tag === "svg") {
                                return 1;
                            }
                            if (parent.props.some(function(a) {
                                return a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml");
                            })) {
                                ns = 0;
                            }
                        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
                            ns = 0;
                        }
                    } else if (parent && ns === 1) {
                        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
                            ns = 0;
                        }
                    }
                    if (ns === 0) {
                        if (tag === "svg") {
                            return 1;
                        }
                        if (tag === "math") {
                            return 2;
                        }
                    }
                    return ns;
                }
            };
            var transformStyle = function(node) {
                if (node.type === 1) {
                    node.props.forEach(function(p, i) {
                        if (p.type === 6 && p.name === "style" && p.value) {
                            node.props[i] = {
                                type: 7,
                                name: "bind",
                                arg: compilerCore.createSimpleExpression("style", true, p.loc),
                                exp: parseInlineCSS(p.value.content, p.loc),
                                modifiers: [],
                                loc: p.loc
                            };
                        }
                    });
                }
            };
            var parseInlineCSS = function(cssText, loc) {
                var normalized = shared.parseStringStyle(cssText);
                return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
            };
            function createDOMCompilerError(code, loc) {
                return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
            }
            var DOMErrorCodes = {
                "X_V_HTML_NO_EXPRESSION": 53,
                "53": "X_V_HTML_NO_EXPRESSION",
                "X_V_HTML_WITH_CHILDREN": 54,
                "54": "X_V_HTML_WITH_CHILDREN",
                "X_V_TEXT_NO_EXPRESSION": 55,
                "55": "X_V_TEXT_NO_EXPRESSION",
                "X_V_TEXT_WITH_CHILDREN": 56,
                "56": "X_V_TEXT_WITH_CHILDREN",
                "X_V_MODEL_ON_INVALID_ELEMENT": 57,
                "57": "X_V_MODEL_ON_INVALID_ELEMENT",
                "X_V_MODEL_ARG_ON_ELEMENT": 58,
                "58": "X_V_MODEL_ARG_ON_ELEMENT",
                "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
                "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
                "X_V_MODEL_UNNECESSARY_VALUE": 60,
                "60": "X_V_MODEL_UNNECESSARY_VALUE",
                "X_V_SHOW_NO_EXPRESSION": 61,
                "61": "X_V_SHOW_NO_EXPRESSION",
                "X_TRANSITION_INVALID_CHILDREN": 62,
                "62": "X_TRANSITION_INVALID_CHILDREN",
                "X_IGNORED_SIDE_EFFECT_TAG": 63,
                "63": "X_IGNORED_SIDE_EFFECT_TAG",
                "__EXTEND_POINT__": 64,
                "64": "__EXTEND_POINT__"
            };
            var _obj1;
            var DOMErrorMessages = (_obj1 = {}, _define_property(_obj1, 53, "v-html is missing expression."), _define_property(_obj1, 54, "v-html will override element children."), _define_property(_obj1, 55, "v-text is missing expression."), _define_property(_obj1, 56, "v-text will override element children."), _define_property(_obj1, 57, "v-model can only be used on <input>, <textarea> and <select> elements."), _define_property(_obj1, 58, "v-model argument is not supported on plain elements."), _define_property(_obj1, 59, "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead."), _define_property(_obj1, 60, "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior."), _define_property(_obj1, 61, "v-show is missing expression."), _define_property(_obj1, 62, "<Transition> expects exactly one child element or component."), _define_property(_obj1, 63, "Tags with side effect (<script> and <style>) are ignored in client component templates."), _obj1);
            var transformVHtml = function(dir, node, context) {
                var exp = dir.exp, loc = dir.loc;
                if (!exp) {
                    context.onError(createDOMCompilerError(53, loc));
                }
                if (node.children.length) {
                    context.onError(createDOMCompilerError(54, loc));
                    node.children.length = 0;
                }
                return {
                    props: [
                        compilerCore.createObjectProperty(compilerCore.createSimpleExpression("innerHTML", true, loc), exp || compilerCore.createSimpleExpression("", true))
                    ]
                };
            };
            var transformVText = function(dir, node, context) {
                var exp = dir.exp, loc = dir.loc;
                if (!exp) {
                    context.onError(createDOMCompilerError(55, loc));
                }
                if (node.children.length) {
                    context.onError(createDOMCompilerError(56, loc));
                    node.children.length = 0;
                }
                return {
                    props: [
                        compilerCore.createObjectProperty(compilerCore.createSimpleExpression("textContent", true), exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [
                            exp
                        ], loc) : compilerCore.createSimpleExpression("", true))
                    ]
                };
            };
            var transformModel = function(dir, node, context) {
                var checkDuplicatedValue = function checkDuplicatedValue() {
                    var value = compilerCore.findDir(node, "bind");
                    if (value && compilerCore.isStaticArgOf(value.arg, "value")) {
                        context.onError(createDOMCompilerError(60, value.loc));
                    }
                };
                var baseResult = compilerCore.transformModel(dir, node, context);
                if (!baseResult.props.length || node.tagType === 1) {
                    return baseResult;
                }
                if (dir.arg) {
                    context.onError(createDOMCompilerError(58, dir.arg.loc));
                }
                var tag = node.tag;
                var isCustomElement = context.isCustomElement(tag);
                if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
                    var directiveToUse = V_MODEL_TEXT;
                    var isInvalidType = false;
                    if (tag === "input" || isCustomElement) {
                        var type = compilerCore.findProp(node, "type");
                        if (type) {
                            if (type.type === 7) {
                                directiveToUse = V_MODEL_DYNAMIC;
                            } else if (type.value) {
                                switch(type.value.content){
                                    case "radio":
                                        directiveToUse = V_MODEL_RADIO;
                                        break;
                                    case "checkbox":
                                        directiveToUse = V_MODEL_CHECKBOX;
                                        break;
                                    case "file":
                                        isInvalidType = true;
                                        context.onError(createDOMCompilerError(59, dir.loc));
                                        break;
                                    default:
                                        checkDuplicatedValue();
                                        break;
                                }
                            }
                        } else if (compilerCore.hasDynamicKeyVBind(node)) {
                            directiveToUse = V_MODEL_DYNAMIC;
                        } else {
                            checkDuplicatedValue();
                        }
                    } else if (tag === "select") {
                        directiveToUse = V_MODEL_SELECT;
                    } else {
                        checkDuplicatedValue();
                    }
                    if (!isInvalidType) {
                        baseResult.needRuntime = context.helper(directiveToUse);
                    }
                } else {
                    context.onError(createDOMCompilerError(57, dir.loc));
                }
                baseResult.props = baseResult.props.filter(function(p) {
                    return !(p.key.type === 4 && p.key.content === "modelValue");
                });
                return baseResult;
            };
            var isEventOptionModifier = /* @__PURE__ */ shared.makeMap("passive,once,capture");
            var isNonKeyModifier = /* @__PURE__ */ shared.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle");
            var maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
            var isKeyboardEvent = /* @__PURE__ */ shared.makeMap("onkeyup,onkeydown,onkeypress");
            var resolveModifiers = function(key, modifiers, context, loc) {
                var keyModifiers = [];
                var nonKeyModifiers = [];
                var eventOptionModifiers = [];
                for(var i = 0; i < modifiers.length; i++){
                    var modifier = modifiers[i].content;
                    if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
                        eventOptionModifiers.push(modifier);
                    } else if (isEventOptionModifier(modifier)) {
                        eventOptionModifiers.push(modifier);
                    } else {
                        if (maybeKeyModifier(modifier)) {
                            if (compilerCore.isStaticExp(key)) {
                                if (isKeyboardEvent(key.content.toLowerCase())) {
                                    keyModifiers.push(modifier);
                                } else {
                                    nonKeyModifiers.push(modifier);
                                }
                            } else {
                                keyModifiers.push(modifier);
                                nonKeyModifiers.push(modifier);
                            }
                        } else {
                            if (isNonKeyModifier(modifier)) {
                                nonKeyModifiers.push(modifier);
                            } else {
                                keyModifiers.push(modifier);
                            }
                        }
                    }
                }
                return {
                    keyModifiers: keyModifiers,
                    nonKeyModifiers: nonKeyModifiers,
                    eventOptionModifiers: eventOptionModifiers
                };
            };
            var transformClick = function(key, event) {
                var isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
                return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
                    "(",
                    key,
                    ') === "onClick" ? "'.concat(event, '" : ('),
                    key,
                    ")"
                ]) : key;
            };
            var transformOn = function(dir, node, context) {
                return compilerCore.transformOn(dir, node, context, function(baseResult) {
                    var modifiers = dir.modifiers;
                    if (!modifiers.length) return baseResult;
                    var _baseResult_props_ = baseResult.props[0], key = _baseResult_props_.key, handlerExp = _baseResult_props_.value;
                    var _resolveModifiers = resolveModifiers(key, modifiers, context, dir.loc), keyModifiers = _resolveModifiers.keyModifiers, nonKeyModifiers = _resolveModifiers.nonKeyModifiers, eventOptionModifiers = _resolveModifiers.eventOptionModifiers;
                    if (nonKeyModifiers.includes("right")) {
                        key = transformClick(key, "onContextmenu");
                    }
                    if (nonKeyModifiers.includes("middle")) {
                        key = transformClick(key, "onMouseup");
                    }
                    if (nonKeyModifiers.length) {
                        handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                            handlerExp,
                            JSON.stringify(nonKeyModifiers)
                        ]);
                    }
                    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
                    (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {
                        handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
                            handlerExp,
                            JSON.stringify(keyModifiers)
                        ]);
                    }
                    if (eventOptionModifiers.length) {
                        var modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
                        key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression("".concat(key.content).concat(modifierPostfix), true) : compilerCore.createCompoundExpression([
                            "(",
                            key,
                            ') + "'.concat(modifierPostfix, '"')
                        ]);
                    }
                    return {
                        props: [
                            compilerCore.createObjectProperty(key, handlerExp)
                        ]
                    };
                });
            };
            var transformShow = function(dir, node, context) {
                var exp = dir.exp, loc = dir.loc;
                if (!exp) {
                    context.onError(createDOMCompilerError(61, loc));
                }
                return {
                    props: [],
                    needRuntime: context.helper(V_SHOW)
                };
            };
            var transformTransition = function(node, context) {
                if (node.type === 1 && node.tagType === 1) {
                    var component = context.isBuiltInComponent(node.tag);
                    if (component === TRANSITION) {
                        return function() {
                            if (!node.children.length) {
                                return;
                            }
                            if (hasMultipleChildren(node)) {
                                context.onError(createDOMCompilerError(62, {
                                    start: node.children[0].loc.start,
                                    end: node.children[node.children.length - 1].loc.end,
                                    source: ""
                                }));
                            }
                            var child = node.children[0];
                            if (child.type === 1) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = child.props[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var p = _step.value;
                                        if (p.type === 7 && p.name === "show") {
                                            node.props.push({
                                                type: 6,
                                                name: "persisted",
                                                nameLoc: node.loc,
                                                value: void 0,
                                                loc: node.loc
                                            });
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            }
                        };
                    }
                }
            };
            function hasMultipleChildren(node) {
                var children = node.children = node.children.filter(function(c) {
                    return c.type !== 3 && !(c.type === 2 && !c.content.trim());
                });
                var child = children[0];
                return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
            }
            var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
            var stringifyStatic = function(children, context, parent) {
                if (context.scopes.vSlot > 0) {
                    return;
                }
                var isParentCached = parent.type === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !shared.isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 20;
                var nc = 0;
                var ec = 0;
                var currentChunk = [];
                var stringifyCurrentChunk = function(currentIndex) {
                    if (nc >= 20 || ec >= 5) {
                        var staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
                            JSON.stringify(currentChunk.map(function(node) {
                                return stringifyNode(node, context);
                            }).join("")).replace(expReplaceRE, '" + $1 + "'),
                            // the 2nd argument indicates the number of DOM nodes this static vnode
                            // will insert / hydrate
                            String(currentChunk.length)
                        ]);
                        var deleteCount = currentChunk.length - 1;
                        if (isParentCached) {
                            children.splice(currentIndex - currentChunk.length, currentChunk.length, // @ts-expect-error
                            staticCall);
                        } else {
                            currentChunk[0].codegenNode.value = staticCall;
                            if (currentChunk.length > 1) {
                                children.splice(currentIndex - currentChunk.length + 1, deleteCount);
                                var cacheIndex = context.cached.indexOf(currentChunk[currentChunk.length - 1].codegenNode);
                                if (cacheIndex > -1) {
                                    for(var i2 = cacheIndex; i2 < context.cached.length; i2++){
                                        var c = context.cached[i2];
                                        if (c) c.index -= deleteCount;
                                    }
                                    context.cached.splice(cacheIndex - deleteCount + 1, deleteCount);
                                }
                            }
                        }
                        return deleteCount;
                    }
                    return 0;
                };
                var i = 0;
                for(; i < children.length; i++){
                    var child = children[i];
                    var isCached = isParentCached || getCachedNode(child);
                    if (isCached) {
                        var result = analyzeNode(child);
                        if (result) {
                            nc += result[0];
                            ec += result[1];
                            currentChunk.push(child);
                            continue;
                        }
                    }
                    i -= stringifyCurrentChunk(i);
                    nc = 0;
                    ec = 0;
                    currentChunk.length = 0;
                }
                stringifyCurrentChunk(i);
            };
            var getCachedNode = function(node) {
                if ((node.type === 1 && node.tagType === 0 || node.type === 12) && node.codegenNode && node.codegenNode.type === 20) {
                    return node.codegenNode;
                }
            };
            var dataAriaRE = /^(data|aria)-/;
            var isStringifiableAttr = function(name, ns) {
                return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : ns === 2 ? shared.isKnownMathMLAttr(name) : false) || dataAriaRE.test(name);
            };
            var isNonStringifiable = /* @__PURE__ */ shared.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
            function analyzeNode(node) {
                if (node.type === 1 && isNonStringifiable(node.tag)) {
                    return false;
                }
                if (node.type === 12) {
                    return [
                        1,
                        0
                    ];
                }
                var nc = 1;
                var ec = node.props.length > 0 ? 1 : 0;
                var bailed = false;
                var bail = function() {
                    bailed = true;
                    return false;
                };
                function walk(node2) {
                    var isOptionTag = node2.tag === "option" && node2.ns === 0;
                    for(var i = 0; i < node2.props.length; i++){
                        var p = node2.props[i];
                        if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
                            return bail();
                        }
                        if (p.type === 7 && p.name === "bind") {
                            if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
                                return bail();
                            }
                            if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
                                return bail();
                            }
                            if (isOptionTag && compilerCore.isStaticArgOf(p.arg, "value") && p.exp && !p.exp.isStatic) {
                                return bail();
                            }
                        }
                    }
                    for(var i1 = 0; i1 < node2.children.length; i1++){
                        nc++;
                        var child = node2.children[i1];
                        if (child.type === 1) {
                            if (child.props.length > 0) {
                                ec++;
                            }
                            walk(child);
                            if (bailed) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                return walk(node) ? [
                    nc,
                    ec
                ] : false;
            }
            function stringifyNode(node, context) {
                if (shared.isString(node)) {
                    return node;
                }
                if (shared.isSymbol(node)) {
                    return "";
                }
                switch(node.type){
                    case 1:
                        return stringifyElement(node, context);
                    case 2:
                        return shared.escapeHtml(node.content);
                    case 3:
                        return "<!--".concat(shared.escapeHtml(node.content), "-->");
                    case 5:
                        return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
                    case 8:
                        return shared.escapeHtml(evaluateConstant(node));
                    case 12:
                        return stringifyNode(node.content, context);
                    default:
                        return "";
                }
            }
            function stringifyElement(node, context) {
                var res = "<".concat(node.tag);
                var innerHTML = "";
                for(var i = 0; i < node.props.length; i++){
                    var p = node.props[i];
                    if (p.type === 6) {
                        res += " ".concat(p.name);
                        if (p.value) {
                            res += '="'.concat(shared.escapeHtml(p.value.content), '"');
                        }
                    } else if (p.type === 7) {
                        if (p.name === "bind") {
                            var exp = p.exp;
                            if (exp.content[0] === "_") {
                                res += " ".concat(p.arg.content, '="__VUE_EXP_START__').concat(exp.content, '__VUE_EXP_END__"');
                                continue;
                            }
                            if (shared.isBooleanAttr(p.arg.content) && exp.content === "false") {
                                continue;
                            }
                            var evaluated = evaluateConstant(exp);
                            if (evaluated != null) {
                                var arg = p.arg && p.arg.content;
                                if (arg === "class") {
                                    evaluated = shared.normalizeClass(evaluated);
                                } else if (arg === "style") {
                                    evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
                                }
                                res += " ".concat(p.arg.content, '="').concat(shared.escapeHtml(evaluated), '"');
                            }
                        } else if (p.name === "html") {
                            innerHTML = evaluateConstant(p.exp);
                        } else if (p.name === "text") {
                            innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p.exp)));
                        }
                    }
                }
                if (context.scopeId) {
                    res += " ".concat(context.scopeId);
                }
                res += ">";
                if (innerHTML) {
                    res += innerHTML;
                } else {
                    for(var i1 = 0; i1 < node.children.length; i1++){
                        res += stringifyNode(node.children[i1], context);
                    }
                }
                if (!shared.isVoidTag(node.tag)) {
                    res += "</".concat(node.tag, ">");
                }
                return res;
            }
            function evaluateConstant(exp) {
                if (exp.type === 4) {
                    return new Function("return (".concat(exp.content, ")"))();
                } else {
                    var res = "";
                    exp.children.forEach(function(c) {
                        if (shared.isString(c) || shared.isSymbol(c)) {
                            return;
                        }
                        if (c.type === 2) {
                            res += c.content;
                        } else if (c.type === 5) {
                            res += shared.toDisplayString(evaluateConstant(c.content));
                        } else {
                            res += evaluateConstant(c);
                        }
                    });
                    return res;
                }
            }
            var ignoreSideEffectTags = function(node, context) {
                if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
                    context.onError(createDOMCompilerError(63, node.loc));
                    context.removeNode();
                }
            };
            function isValidHTMLNesting(parent, child) {
                if (parent in onlyValidChildren) {
                    return onlyValidChildren[parent].has(child);
                }
                if (child in onlyValidParents) {
                    return onlyValidParents[child].has(parent);
                }
                if (parent in knownInvalidChildren) {
                    if (knownInvalidChildren[parent].has(child)) return false;
                }
                if (child in knownInvalidParents) {
                    if (knownInvalidParents[child].has(parent)) return false;
                }
                return true;
            }
            var headings = /* @__PURE__ */ new Set([
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6"
            ]);
            var emptySet = /* @__PURE__ */ new Set([]);
            var onlyValidChildren = {
                head: /* @__PURE__ */ new Set([
                    "base",
                    "basefront",
                    "bgsound",
                    "link",
                    "meta",
                    "title",
                    "noscript",
                    "noframes",
                    "style",
                    "script",
                    "template"
                ]),
                optgroup: /* @__PURE__ */ new Set([
                    "option"
                ]),
                select: /* @__PURE__ */ new Set([
                    "optgroup",
                    "option",
                    "hr"
                ]),
                // table
                table: /* @__PURE__ */ new Set([
                    "caption",
                    "colgroup",
                    "tbody",
                    "tfoot",
                    "thead"
                ]),
                tr: /* @__PURE__ */ new Set([
                    "td",
                    "th"
                ]),
                colgroup: /* @__PURE__ */ new Set([
                    "col"
                ]),
                tbody: /* @__PURE__ */ new Set([
                    "tr"
                ]),
                thead: /* @__PURE__ */ new Set([
                    "tr"
                ]),
                tfoot: /* @__PURE__ */ new Set([
                    "tr"
                ]),
                // these elements can not have any children elements
                script: emptySet,
                iframe: emptySet,
                option: emptySet,
                textarea: emptySet,
                style: emptySet,
                title: emptySet
            };
            var onlyValidParents = {
                // sections
                html: emptySet,
                body: /* @__PURE__ */ new Set([
                    "html"
                ]),
                head: /* @__PURE__ */ new Set([
                    "html"
                ]),
                // table
                td: /* @__PURE__ */ new Set([
                    "tr"
                ]),
                colgroup: /* @__PURE__ */ new Set([
                    "table"
                ]),
                caption: /* @__PURE__ */ new Set([
                    "table"
                ]),
                tbody: /* @__PURE__ */ new Set([
                    "table"
                ]),
                tfoot: /* @__PURE__ */ new Set([
                    "table"
                ]),
                col: /* @__PURE__ */ new Set([
                    "colgroup"
                ]),
                th: /* @__PURE__ */ new Set([
                    "tr"
                ]),
                thead: /* @__PURE__ */ new Set([
                    "table"
                ]),
                tr: /* @__PURE__ */ new Set([
                    "tbody",
                    "thead",
                    "tfoot"
                ]),
                // data list
                dd: /* @__PURE__ */ new Set([
                    "dl",
                    "div"
                ]),
                dt: /* @__PURE__ */ new Set([
                    "dl",
                    "div"
                ]),
                // other
                figcaption: /* @__PURE__ */ new Set([
                    "figure"
                ]),
                // li: new Set(["ul", "ol"]),
                summary: /* @__PURE__ */ new Set([
                    "details"
                ]),
                area: /* @__PURE__ */ new Set([
                    "map"
                ])
            };
            var knownInvalidChildren = {
                p: /* @__PURE__ */ new Set([
                    "address",
                    "article",
                    "aside",
                    "blockquote",
                    "center",
                    "details",
                    "dialog",
                    "dir",
                    "div",
                    "dl",
                    "fieldset",
                    "figure",
                    "footer",
                    "form",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                    "header",
                    "hgroup",
                    "hr",
                    "li",
                    "main",
                    "nav",
                    "menu",
                    "ol",
                    "p",
                    "pre",
                    "section",
                    "table",
                    "ul"
                ]),
                svg: /* @__PURE__ */ new Set([
                    "b",
                    "blockquote",
                    "br",
                    "code",
                    "dd",
                    "div",
                    "dl",
                    "dt",
                    "em",
                    "embed",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                    "hr",
                    "i",
                    "img",
                    "li",
                    "menu",
                    "meta",
                    "ol",
                    "p",
                    "pre",
                    "ruby",
                    "s",
                    "small",
                    "span",
                    "strong",
                    "sub",
                    "sup",
                    "table",
                    "u",
                    "ul",
                    "var"
                ])
            };
            var knownInvalidParents = {
                a: /* @__PURE__ */ new Set([
                    "a"
                ]),
                button: /* @__PURE__ */ new Set([
                    "button"
                ]),
                dd: /* @__PURE__ */ new Set([
                    "dd",
                    "dt"
                ]),
                dt: /* @__PURE__ */ new Set([
                    "dd",
                    "dt"
                ]),
                form: /* @__PURE__ */ new Set([
                    "form"
                ]),
                li: /* @__PURE__ */ new Set([
                    "li"
                ]),
                h1: headings,
                h2: headings,
                h3: headings,
                h4: headings,
                h5: headings,
                h6: headings
            };
            var validateHtmlNesting = function(node, context) {
                if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
                    var error = new SyntaxError("<".concat(node.tag, "> cannot be child of <").concat(context.parent.tag, ">, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality."));
                    error.loc = node.loc;
                    context.onWarn(error);
                }
            };
            var DOMNodeTransforms = [
                transformStyle
            ].concat(_to_consumable_array([
                transformTransition,
                validateHtmlNesting
            ]));
            var DOMDirectiveTransforms = {
                cloak: compilerCore.noopDirectiveTransform,
                html: transformVHtml,
                text: transformVText,
                model: transformModel,
                // override compiler-core
                on: transformOn,
                // override compiler-core
                show: transformShow
            };
            function compile(src) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return compilerCore.baseCompile(src, shared.extend({}, parserOptions, options, {
                    nodeTransforms: [
                        // ignore <script> and <tag>
                        // this is not put inside DOMNodeTransforms because that list is used
                        // by compiler-ssr to generate vnode fallback branches
                        ignoreSideEffectTags
                    ].concat(_to_consumable_array(DOMNodeTransforms), _to_consumable_array(options.nodeTransforms || [])),
                    directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
                    transformHoist: stringifyStatic
                }));
            }
            function parse(template) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
            }
            exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
            exports.DOMErrorCodes = DOMErrorCodes;
            exports.DOMErrorMessages = DOMErrorMessages;
            exports.DOMNodeTransforms = DOMNodeTransforms;
            exports.TRANSITION = TRANSITION;
            exports.TRANSITION_GROUP = TRANSITION_GROUP;
            exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
            exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
            exports.V_MODEL_RADIO = V_MODEL_RADIO;
            exports.V_MODEL_SELECT = V_MODEL_SELECT;
            exports.V_MODEL_TEXT = V_MODEL_TEXT;
            exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
            exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
            exports.V_SHOW = V_SHOW;
            exports.compile = compile;
            exports.createDOMCompilerError = createDOMCompilerError;
            exports.parse = parse;
            exports.parserOptions = parserOptions;
            exports.transformStyle = transformStyle;
            Object.keys(compilerCore).forEach(function(k) {
                if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = compilerCore[k];
            });
        }
    });
    // ../../node_modules/.pnpm/@vue+compiler-dom@3.5.13/node_modules/@vue/compiler-dom/index.js
    var require_compiler_dom = __commonJS({
        "../../node_modules/.pnpm/@vue+compiler-dom@3.5.13/node_modules/@vue/compiler-dom/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_compiler_dom_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/@vue+reactivity@3.5.13/node_modules/@vue/reactivity/dist/reactivity.cjs.js
    var require_reactivity_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+reactivity@3.5.13/node_modules/@vue/reactivity/dist/reactivity.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var shared = require_shared();
            function warn(msg) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                var _console;
                (_console = console).warn.apply(_console, [
                    "[Vue warn] ".concat(msg)
                ].concat(_to_consumable_array(args)));
            }
            var activeEffectScope;
            var EffectScope = /*#__PURE__*/ function() {
                function EffectScope() {
                    var detached = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    _class_call_check(this, EffectScope);
                    this.detached = detached;
                    this._active = true;
                    this.effects = [];
                    this.cleanups = [];
                    this._isPaused = false;
                    this.parent = activeEffectScope;
                    if (!detached && activeEffectScope) {
                        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
                    }
                }
                _create_class(EffectScope, [
                    {
                        key: "active",
                        get: function get() {
                            return this._active;
                        }
                    },
                    {
                        key: "pause",
                        value: function pause() {
                            if (this._active) {
                                this._isPaused = true;
                                var i, l;
                                if (this.scopes) {
                                    for(i = 0, l = this.scopes.length; i < l; i++){
                                        this.scopes[i].pause();
                                    }
                                }
                                for(i = 0, l = this.effects.length; i < l; i++){
                                    this.effects[i].pause();
                                }
                            }
                        }
                    },
                    {
                        /**
         * Resumes the effect scope, including all child scopes and effects.
         */ key: "resume",
                        value: function resume() {
                            if (this._active) {
                                if (this._isPaused) {
                                    this._isPaused = false;
                                    var i, l;
                                    if (this.scopes) {
                                        for(i = 0, l = this.scopes.length; i < l; i++){
                                            this.scopes[i].resume();
                                        }
                                    }
                                    for(i = 0, l = this.effects.length; i < l; i++){
                                        this.effects[i].resume();
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "run",
                        value: function run(fn) {
                            if (this._active) {
                                var currentEffectScope = activeEffectScope;
                                try {
                                    activeEffectScope = this;
                                    return fn();
                                } finally{
                                    activeEffectScope = currentEffectScope;
                                }
                            } else {
                                warn("cannot run an inactive effect scope.");
                            }
                        }
                    },
                    {
                        /**
         * This should only be called on non-detached scopes
         * @internal
         */ key: "on",
                        value: function on() {
                            activeEffectScope = this;
                        }
                    },
                    {
                        /**
         * This should only be called on non-detached scopes
         * @internal
         */ key: "off",
                        value: function off() {
                            activeEffectScope = this.parent;
                        }
                    },
                    {
                        key: "stop",
                        value: function stop(fromParent) {
                            if (this._active) {
                                this._active = false;
                                var i, l;
                                for(i = 0, l = this.effects.length; i < l; i++){
                                    this.effects[i].stop();
                                }
                                this.effects.length = 0;
                                for(i = 0, l = this.cleanups.length; i < l; i++){
                                    this.cleanups[i]();
                                }
                                this.cleanups.length = 0;
                                if (this.scopes) {
                                    for(i = 0, l = this.scopes.length; i < l; i++){
                                        this.scopes[i].stop(true);
                                    }
                                    this.scopes.length = 0;
                                }
                                if (!this.detached && this.parent && !fromParent) {
                                    var last = this.parent.scopes.pop();
                                    if (last && last !== this) {
                                        this.parent.scopes[this.index] = last;
                                        last.index = this.index;
                                    }
                                }
                                this.parent = void 0;
                            }
                        }
                    }
                ]);
                return EffectScope;
            }();
            function effectScope(detached) {
                return new EffectScope(detached);
            }
            function getCurrentScope() {
                return activeEffectScope;
            }
            function onScopeDispose(fn) {
                var failSilently = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (activeEffectScope) {
                    activeEffectScope.cleanups.push(fn);
                } else if (!failSilently) {
                    warn("onScopeDispose() is called when there is no active effect scope to be associated with.");
                }
            }
            var activeSub;
            var EffectFlags = {
                "ACTIVE": 1,
                "1": "ACTIVE",
                "RUNNING": 2,
                "2": "RUNNING",
                "TRACKING": 4,
                "4": "TRACKING",
                "NOTIFIED": 8,
                "8": "NOTIFIED",
                "DIRTY": 16,
                "16": "DIRTY",
                "ALLOW_RECURSE": 32,
                "32": "ALLOW_RECURSE",
                "PAUSED": 64,
                "64": "PAUSED"
            };
            var pausedQueueEffects = /* @__PURE__ */ new WeakSet();
            var ReactiveEffect = /*#__PURE__*/ function() {
                function ReactiveEffect(fn) {
                    _class_call_check(this, ReactiveEffect);
                    this.fn = fn;
                    this.deps = void 0;
                    this.depsTail = void 0;
                    this.flags = 1 | 4;
                    this.next = void 0;
                    this.cleanup = void 0;
                    this.scheduler = void 0;
                    if (activeEffectScope && activeEffectScope.active) {
                        activeEffectScope.effects.push(this);
                    }
                }
                _create_class(ReactiveEffect, [
                    {
                        key: "pause",
                        value: function pause() {
                            this.flags |= 64;
                        }
                    },
                    {
                        key: "resume",
                        value: function resume() {
                            if (this.flags & 64) {
                                this.flags &= ~64;
                                if (pausedQueueEffects.has(this)) {
                                    pausedQueueEffects.delete(this);
                                    this.trigger();
                                }
                            }
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "notify",
                        value: function notify() {
                            if (this.flags & 2 && !(this.flags & 32)) {
                                return;
                            }
                            if (!(this.flags & 8)) {
                                batch(this);
                            }
                        }
                    },
                    {
                        key: "run",
                        value: function run() {
                            if (!(this.flags & 1)) {
                                return this.fn();
                            }
                            this.flags |= 2;
                            cleanupEffect(this);
                            prepareDeps(this);
                            var prevEffect = activeSub;
                            var prevShouldTrack = shouldTrack;
                            activeSub = this;
                            shouldTrack = true;
                            try {
                                return this.fn();
                            } finally{
                                if (activeSub !== this) {
                                    warn("Active effect was not restored correctly - this is likely a Vue internal bug.");
                                }
                                cleanupDeps(this);
                                activeSub = prevEffect;
                                shouldTrack = prevShouldTrack;
                                this.flags &= ~2;
                            }
                        }
                    },
                    {
                        key: "stop",
                        value: function stop() {
                            if (this.flags & 1) {
                                for(var link = this.deps; link; link = link.nextDep){
                                    removeSub(link);
                                }
                                this.deps = this.depsTail = void 0;
                                cleanupEffect(this);
                                this.onStop && this.onStop();
                                this.flags &= ~1;
                            }
                        }
                    },
                    {
                        key: "trigger",
                        value: function trigger() {
                            if (this.flags & 64) {
                                pausedQueueEffects.add(this);
                            } else if (this.scheduler) {
                                this.scheduler();
                            } else {
                                this.runIfDirty();
                            }
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "runIfDirty",
                        value: function runIfDirty() {
                            if (isDirty(this)) {
                                this.run();
                            }
                        }
                    },
                    {
                        key: "dirty",
                        get: function get() {
                            return isDirty(this);
                        }
                    }
                ]);
                return ReactiveEffect;
            }();
            var batchDepth = 0;
            var batchedSub;
            var batchedComputed;
            function batch(sub) {
                var isComputed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                sub.flags |= 8;
                if (isComputed) {
                    sub.next = batchedComputed;
                    batchedComputed = sub;
                    return;
                }
                sub.next = batchedSub;
                batchedSub = sub;
            }
            function startBatch() {
                batchDepth++;
            }
            function endBatch() {
                if (--batchDepth > 0) {
                    return;
                }
                if (batchedComputed) {
                    var e = batchedComputed;
                    batchedComputed = void 0;
                    while(e){
                        var next = e.next;
                        e.next = void 0;
                        e.flags &= ~8;
                        e = next;
                    }
                }
                var error;
                while(batchedSub){
                    var e1 = batchedSub;
                    batchedSub = void 0;
                    while(e1){
                        var next1 = e1.next;
                        e1.next = void 0;
                        e1.flags &= ~8;
                        if (e1.flags & 1) {
                            try {
                                ;
                                e1.trigger();
                            } catch (err) {
                                if (!error) error = err;
                            }
                        }
                        e1 = next1;
                    }
                }
                if (error) throw error;
            }
            function prepareDeps(sub) {
                for(var link = sub.deps; link; link = link.nextDep){
                    link.version = -1;
                    link.prevActiveLink = link.dep.activeLink;
                    link.dep.activeLink = link;
                }
            }
            function cleanupDeps(sub) {
                var head;
                var tail = sub.depsTail;
                var link = tail;
                while(link){
                    var prev = link.prevDep;
                    if (link.version === -1) {
                        if (link === tail) tail = prev;
                        removeSub(link);
                        removeDep(link);
                    } else {
                        head = link;
                    }
                    link.dep.activeLink = link.prevActiveLink;
                    link.prevActiveLink = void 0;
                    link = prev;
                }
                sub.deps = head;
                sub.depsTail = tail;
            }
            function isDirty(sub) {
                for(var link = sub.deps; link; link = link.nextDep){
                    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
                        return true;
                    }
                }
                if (sub._dirty) {
                    return true;
                }
                return false;
            }
            function refreshComputed(computed2) {
                if (computed2.flags & 4 && !(computed2.flags & 16)) {
                    return;
                }
                computed2.flags &= ~16;
                if (computed2.globalVersion === globalVersion) {
                    return;
                }
                computed2.globalVersion = globalVersion;
                var dep = computed2.dep;
                computed2.flags |= 2;
                if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
                    computed2.flags &= ~2;
                    return;
                }
                var prevSub = activeSub;
                var prevShouldTrack = shouldTrack;
                activeSub = computed2;
                shouldTrack = true;
                try {
                    prepareDeps(computed2);
                    var value = computed2.fn(computed2._value);
                    if (dep.version === 0 || shared.hasChanged(value, computed2._value)) {
                        computed2._value = value;
                        dep.version++;
                    }
                } catch (err) {
                    dep.version++;
                    throw err;
                } finally{
                    activeSub = prevSub;
                    shouldTrack = prevShouldTrack;
                    cleanupDeps(computed2);
                    computed2.flags &= ~2;
                }
            }
            function removeSub(link) {
                var soft = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                var dep = link.dep, prevSub = link.prevSub, nextSub = link.nextSub;
                if (prevSub) {
                    prevSub.nextSub = nextSub;
                    link.prevSub = void 0;
                }
                if (nextSub) {
                    nextSub.prevSub = prevSub;
                    link.nextSub = void 0;
                }
                if (dep.subsHead === link) {
                    dep.subsHead = nextSub;
                }
                if (dep.subs === link) {
                    dep.subs = prevSub;
                    if (!prevSub && dep.computed) {
                        dep.computed.flags &= ~4;
                        for(var l = dep.computed.deps; l; l = l.nextDep){
                            removeSub(l, true);
                        }
                    }
                }
                if (!soft && !--dep.sc && dep.map) {
                    dep.map.delete(dep.key);
                }
            }
            function removeDep(link) {
                var prevDep = link.prevDep, nextDep = link.nextDep;
                if (prevDep) {
                    prevDep.nextDep = nextDep;
                    link.prevDep = void 0;
                }
                if (nextDep) {
                    nextDep.prevDep = prevDep;
                    link.nextDep = void 0;
                }
            }
            function effect(fn, options) {
                if (_instanceof(fn.effect, ReactiveEffect)) {
                    fn = fn.effect.fn;
                }
                var e = new ReactiveEffect(fn);
                if (options) {
                    shared.extend(e, options);
                }
                try {
                    e.run();
                } catch (err) {
                    e.stop();
                    throw err;
                }
                var runner = e.run.bind(e);
                runner.effect = e;
                return runner;
            }
            function stop(runner) {
                runner.effect.stop();
            }
            var shouldTrack = true;
            var trackStack = [];
            function pauseTracking() {
                trackStack.push(shouldTrack);
                shouldTrack = false;
            }
            function enableTracking() {
                trackStack.push(shouldTrack);
                shouldTrack = true;
            }
            function resetTracking() {
                var last = trackStack.pop();
                shouldTrack = last === void 0 ? true : last;
            }
            function onEffectCleanup(fn) {
                var failSilently = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                if (_instanceof(activeSub, ReactiveEffect)) {
                    activeSub.cleanup = fn;
                } else if (!failSilently) {
                    warn("onEffectCleanup() was called when there was no active effect to associate with.");
                }
            }
            function cleanupEffect(e) {
                var cleanup = e.cleanup;
                e.cleanup = void 0;
                if (cleanup) {
                    var prevSub = activeSub;
                    activeSub = void 0;
                    try {
                        cleanup();
                    } finally{
                        activeSub = prevSub;
                    }
                }
            }
            var globalVersion = 0;
            var Link = function Link(sub, dep) {
                _class_call_check(this, Link);
                this.sub = sub;
                this.dep = dep;
                this.version = dep.version;
                this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
            };
            var Dep = /*#__PURE__*/ function() {
                function Dep(computed2) {
                    _class_call_check(this, Dep);
                    this.computed = computed2;
                    this.version = 0;
                    this.activeLink = void 0;
                    this.subs = void 0;
                    this.map = void 0;
                    this.key = void 0;
                    this.sc = 0;
                    {
                        this.subsHead = void 0;
                    }
                }
                _create_class(Dep, [
                    {
                        key: "track",
                        value: function track(debugInfo) {
                            if (!activeSub || !shouldTrack || activeSub === this.computed) {
                                return;
                            }
                            var link = this.activeLink;
                            if (link === void 0 || link.sub !== activeSub) {
                                link = this.activeLink = new Link(activeSub, this);
                                if (!activeSub.deps) {
                                    activeSub.deps = activeSub.depsTail = link;
                                } else {
                                    link.prevDep = activeSub.depsTail;
                                    activeSub.depsTail.nextDep = link;
                                    activeSub.depsTail = link;
                                }
                                addSub(link);
                            } else if (link.version === -1) {
                                link.version = this.version;
                                if (link.nextDep) {
                                    var next = link.nextDep;
                                    next.prevDep = link.prevDep;
                                    if (link.prevDep) {
                                        link.prevDep.nextDep = next;
                                    }
                                    link.prevDep = activeSub.depsTail;
                                    link.nextDep = void 0;
                                    activeSub.depsTail.nextDep = link;
                                    activeSub.depsTail = link;
                                    if (activeSub.deps === link) {
                                        activeSub.deps = next;
                                    }
                                }
                            }
                            if (activeSub.onTrack) {
                                activeSub.onTrack(shared.extend({
                                    effect: activeSub
                                }, debugInfo));
                            }
                            return link;
                        }
                    },
                    {
                        key: "trigger",
                        value: function trigger(debugInfo) {
                            this.version++;
                            globalVersion++;
                            this.notify(debugInfo);
                        }
                    },
                    {
                        key: "notify",
                        value: function notify(debugInfo) {
                            startBatch();
                            try {
                                if (true) {
                                    for(var head = this.subsHead; head; head = head.nextSub){
                                        if (head.sub.onTrigger && !(head.sub.flags & 8)) {
                                            head.sub.onTrigger(shared.extend({
                                                effect: head.sub
                                            }, debugInfo));
                                        }
                                    }
                                }
                                for(var link = this.subs; link; link = link.prevSub){
                                    if (link.sub.notify()) {
                                        ;
                                        link.sub.dep.notify();
                                    }
                                }
                            } finally{
                                endBatch();
                            }
                        }
                    }
                ]);
                return Dep;
            }();
            function addSub(link) {
                link.dep.sc++;
                if (link.sub.flags & 4) {
                    var computed2 = link.dep.computed;
                    if (computed2 && !link.dep.subs) {
                        computed2.flags |= 4 | 16;
                        for(var l = computed2.deps; l; l = l.nextDep){
                            addSub(l);
                        }
                    }
                    var currentTail = link.dep.subs;
                    if (currentTail !== link) {
                        link.prevSub = currentTail;
                        if (currentTail) currentTail.nextSub = link;
                    }
                    if (link.dep.subsHead === void 0) {
                        link.dep.subsHead = link;
                    }
                    link.dep.subs = link;
                }
            }
            var targetMap = /* @__PURE__ */ new WeakMap();
            var ITERATE_KEY = Symbol("Object iterate");
            var MAP_KEY_ITERATE_KEY = Symbol("Map keys iterate");
            var ARRAY_ITERATE_KEY = Symbol("Array iterate");
            function track(target, type, key) {
                if (shouldTrack && activeSub) {
                    var depsMap = targetMap.get(target);
                    if (!depsMap) {
                        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
                    }
                    var dep = depsMap.get(key);
                    if (!dep) {
                        depsMap.set(key, dep = new Dep());
                        dep.map = depsMap;
                        dep.key = key;
                    }
                    {
                        dep.track({
                            target: target,
                            type: type,
                            key: key
                        });
                    }
                }
            }
            function trigger(target, type, key, newValue, oldValue, oldTarget) {
                var depsMap = targetMap.get(target);
                if (!depsMap) {
                    globalVersion++;
                    return;
                }
                var run = function(dep) {
                    if (dep) {
                        {
                            dep.trigger({
                                target: target,
                                type: type,
                                key: key,
                                newValue: newValue,
                                oldValue: oldValue,
                                oldTarget: oldTarget
                            });
                        }
                    }
                };
                startBatch();
                if (type === "clear") {
                    depsMap.forEach(run);
                } else {
                    var targetIsArray = shared.isArray(target);
                    var isArrayIndex = targetIsArray && shared.isIntegerKey(key);
                    if (targetIsArray && key === "length") {
                        var newLength = Number(newValue);
                        depsMap.forEach(function(dep, key2) {
                            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !shared.isSymbol(key2) && key2 >= newLength) {
                                run(dep);
                            }
                        });
                    } else {
                        if (key !== void 0 || depsMap.has(void 0)) {
                            run(depsMap.get(key));
                        }
                        if (isArrayIndex) {
                            run(depsMap.get(ARRAY_ITERATE_KEY));
                        }
                        switch(type){
                            case "add":
                                if (!targetIsArray) {
                                    run(depsMap.get(ITERATE_KEY));
                                    if (shared.isMap(target)) {
                                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                                    }
                                } else if (isArrayIndex) {
                                    run(depsMap.get("length"));
                                }
                                break;
                            case "delete":
                                if (!targetIsArray) {
                                    run(depsMap.get(ITERATE_KEY));
                                    if (shared.isMap(target)) {
                                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                                    }
                                }
                                break;
                            case "set":
                                if (shared.isMap(target)) {
                                    run(depsMap.get(ITERATE_KEY));
                                }
                                break;
                        }
                    }
                }
                endBatch();
            }
            function getDepFromReactive(object, key) {
                var depMap = targetMap.get(object);
                return depMap && depMap.get(key);
            }
            function reactiveReadArray(array) {
                var raw = toRaw(array);
                if (raw === array) return raw;
                track(raw, "iterate", ARRAY_ITERATE_KEY);
                return isShallow(array) ? raw : raw.map(toReactive);
            }
            function shallowReadArray(arr) {
                track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
                return arr;
            }
            var _obj;
            var arrayInstrumentations = (_obj = {
                __proto__: null
            }, _define_property(_obj, Symbol.iterator, function() {
                return iterator(this, Symbol.iterator, toReactive);
            }), _define_property(_obj, "concat", function concat() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _reactiveReadArray;
                return (_reactiveReadArray = reactiveReadArray(this)).concat.apply(_reactiveReadArray, _to_consumable_array(args.map(function(x) {
                    return shared.isArray(x) ? reactiveReadArray(x) : x;
                })));
            }), _define_property(_obj, "entries", function entries() {
                return iterator(this, "entries", function(value) {
                    value[1] = toReactive(value[1]);
                    return value;
                });
            }), _define_property(_obj, "every", function every(fn, thisArg) {
                return apply(this, "every", fn, thisArg, void 0, arguments);
            }), _define_property(_obj, "filter", function filter(fn, thisArg) {
                return apply(this, "filter", fn, thisArg, function(v1) {
                    return v1.map(toReactive);
                }, arguments);
            }), _define_property(_obj, "find", function find(fn, thisArg) {
                return apply(this, "find", fn, thisArg, toReactive, arguments);
            }), _define_property(_obj, "findIndex", function findIndex(fn, thisArg) {
                return apply(this, "findIndex", fn, thisArg, void 0, arguments);
            }), _define_property(_obj, "findLast", function findLast(fn, thisArg) {
                return apply(this, "findLast", fn, thisArg, toReactive, arguments);
            }), _define_property(_obj, "findLastIndex", function findLastIndex(fn, thisArg) {
                return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
            }), // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
            _define_property(_obj, "forEach", function forEach(fn, thisArg) {
                return apply(this, "forEach", fn, thisArg, void 0, arguments);
            }), _define_property(_obj, "includes", function includes() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return searchProxy(this, "includes", args);
            }), _define_property(_obj, "indexOf", function indexOf() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return searchProxy(this, "indexOf", args);
            }), _define_property(_obj, "join", function join(separator) {
                return reactiveReadArray(this).join(separator);
            }), // keys() iterator only reads `length`, no optimisation required
            _define_property(_obj, "lastIndexOf", function lastIndexOf() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return searchProxy(this, "lastIndexOf", args);
            }), _define_property(_obj, "map", function map(fn, thisArg) {
                return apply(this, "map", fn, thisArg, void 0, arguments);
            }), _define_property(_obj, "pop", function pop() {
                return noTracking(this, "pop");
            }), _define_property(_obj, "push", function push() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return noTracking(this, "push", args);
            }), _define_property(_obj, "reduce", function reduce1(fn) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                return reduce(this, "reduce", fn, args);
            }), _define_property(_obj, "reduceRight", function reduceRight(fn) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                return reduce(this, "reduceRight", fn, args);
            }), _define_property(_obj, "shift", function shift() {
                return noTracking(this, "shift");
            }), // slice could use ARRAY_ITERATE but also seems to beg for range tracking
            _define_property(_obj, "some", function some(fn, thisArg) {
                return apply(this, "some", fn, thisArg, void 0, arguments);
            }), _define_property(_obj, "splice", function splice() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return noTracking(this, "splice", args);
            }), _define_property(_obj, "toReversed", function toReversed() {
                return reactiveReadArray(this).toReversed();
            }), _define_property(_obj, "toSorted", function toSorted(comparer) {
                return reactiveReadArray(this).toSorted(comparer);
            }), _define_property(_obj, "toSpliced", function toSpliced() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _reactiveReadArray;
                return (_reactiveReadArray = reactiveReadArray(this)).toSpliced.apply(_reactiveReadArray, _to_consumable_array(args));
            }), _define_property(_obj, "unshift", function unshift() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return noTracking(this, "unshift", args);
            }), _define_property(_obj, "values", function values() {
                return iterator(this, "values", toReactive);
            }), _obj);
            function iterator(self2, method, wrapValue) {
                var arr = shallowReadArray(self2);
                var iter = arr[method]();
                if (arr !== self2 && !isShallow(self2)) {
                    iter._next = iter.next;
                    iter.next = function() {
                        var result = iter._next();
                        if (result.value) {
                            result.value = wrapValue(result.value);
                        }
                        return result;
                    };
                }
                return iter;
            }
            var arrayProto = Array.prototype;
            function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
                var arr = shallowReadArray(self2);
                var needsWrap = arr !== self2 && !isShallow(self2);
                var methodFn = arr[method];
                if (methodFn !== arrayProto[method]) {
                    var result2 = methodFn.apply(self2, args);
                    return needsWrap ? toReactive(result2) : result2;
                }
                var wrappedFn = fn;
                if (arr !== self2) {
                    if (needsWrap) {
                        wrappedFn = function wrappedFn(item, index) {
                            return fn.call(this, toReactive(item), index, self2);
                        };
                    } else if (fn.length > 2) {
                        wrappedFn = function wrappedFn(item, index) {
                            return fn.call(this, item, index, self2);
                        };
                    }
                }
                var result = methodFn.call(arr, wrappedFn, thisArg);
                return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
            }
            function reduce(self2, method, fn, args) {
                var _arr;
                var arr = shallowReadArray(self2);
                var wrappedFn = fn;
                if (arr !== self2) {
                    if (!isShallow(self2)) {
                        wrappedFn = function wrappedFn(acc, item, index) {
                            return fn.call(this, acc, toReactive(item), index, self2);
                        };
                    } else if (fn.length > 3) {
                        wrappedFn = function wrappedFn(acc, item, index) {
                            return fn.call(this, acc, item, index, self2);
                        };
                    }
                }
                return (_arr = arr)[method].apply(_arr, [
                    wrappedFn
                ].concat(_to_consumable_array(args)));
            }
            function searchProxy(self2, method, args) {
                var _arr;
                var arr = toRaw(self2);
                track(arr, "iterate", ARRAY_ITERATE_KEY);
                var res = (_arr = arr)[method].apply(_arr, _to_consumable_array(args));
                if ((res === -1 || res === false) && isProxy(args[0])) {
                    var _arr1;
                    args[0] = toRaw(args[0]);
                    return (_arr1 = arr)[method].apply(_arr1, _to_consumable_array(args));
                }
                return res;
            }
            function noTracking(self2, method) {
                var args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                pauseTracking();
                startBatch();
                var res = toRaw(self2)[method].apply(self2, args);
                endBatch();
                resetTracking();
                return res;
            }
            var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap("__proto__,__v_isRef,__isVue");
            var builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter(function(key) {
                return key !== "arguments" && key !== "caller";
            }).map(function(key) {
                return Symbol[key];
            }).filter(shared.isSymbol));
            function hasOwnProperty2(key) {
                if (!shared.isSymbol(key)) key = String(key);
                var obj = toRaw(this);
                track(obj, "has", key);
                return obj.hasOwnProperty(key);
            }
            var BaseReactiveHandler = /*#__PURE__*/ function() {
                function BaseReactiveHandler() {
                    var _isReadonly = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, _isShallow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    _class_call_check(this, BaseReactiveHandler);
                    this._isReadonly = _isReadonly;
                    this._isShallow = _isShallow;
                }
                _create_class(BaseReactiveHandler, [
                    {
                        key: "get",
                        value: function get(target, key, receiver) {
                            if (key === "__v_skip") return target["__v_skip"];
                            var isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
                            if (key === "__v_isReactive") {
                                return !isReadonly2;
                            } else if (key === "__v_isReadonly") {
                                return isReadonly2;
                            } else if (key === "__v_isShallow") {
                                return isShallow2;
                            } else if (key === "__v_raw") {
                                if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
                                // this means the receiver is a user proxy of the reactive proxy
                                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
                                    return target;
                                }
                                return;
                            }
                            var targetIsArray = shared.isArray(target);
                            if (!isReadonly2) {
                                var fn;
                                if (targetIsArray && (fn = arrayInstrumentations[key])) {
                                    return fn;
                                }
                                if (key === "hasOwnProperty") {
                                    return hasOwnProperty2;
                                }
                            }
                            var res = Reflect.get(target, key, // if this is a proxy wrapping a ref, return methods using the raw ref
                            // as receiver so that we don't have to call `toRaw` on the ref in all
                            // its class methods
                            isRef(target) ? target : receiver);
                            if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
                                return res;
                            }
                            if (!isReadonly2) {
                                track(target, "get", key);
                            }
                            if (isShallow2) {
                                return res;
                            }
                            if (isRef(res)) {
                                return targetIsArray && shared.isIntegerKey(key) ? res : res.value;
                            }
                            if (shared.isObject(res)) {
                                return isReadonly2 ? readonly(res) : reactive(res);
                            }
                            return res;
                        }
                    }
                ]);
                return BaseReactiveHandler;
            }();
            var MutableReactiveHandler = /*#__PURE__*/ function(BaseReactiveHandler) {
                _inherits(MutableReactiveHandler, BaseReactiveHandler);
                function MutableReactiveHandler() {
                    var isShallow2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    _class_call_check(this, MutableReactiveHandler);
                    return _call_super(this, MutableReactiveHandler, [
                        false,
                        isShallow2
                    ]);
                }
                _create_class(MutableReactiveHandler, [
                    {
                        key: "set",
                        value: function set(target, key, value, receiver) {
                            var oldValue = target[key];
                            if (!this._isShallow) {
                                var isOldValueReadonly = isReadonly(oldValue);
                                if (!isShallow(value) && !isReadonly(value)) {
                                    oldValue = toRaw(oldValue);
                                    value = toRaw(value);
                                }
                                if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
                                    if (isOldValueReadonly) {
                                        return false;
                                    } else {
                                        oldValue.value = value;
                                        return true;
                                    }
                                }
                            }
                            var hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
                            var result = Reflect.set(target, key, value, isRef(target) ? target : receiver);
                            if (target === toRaw(receiver)) {
                                if (!hadKey) {
                                    trigger(target, "add", key, value);
                                } else if (shared.hasChanged(value, oldValue)) {
                                    trigger(target, "set", key, value, oldValue);
                                }
                            }
                            return result;
                        }
                    },
                    {
                        key: "deleteProperty",
                        value: function deleteProperty(target, key) {
                            var hadKey = shared.hasOwn(target, key);
                            var oldValue = target[key];
                            var result = Reflect.deleteProperty(target, key);
                            if (result && hadKey) {
                                trigger(target, "delete", key, void 0, oldValue);
                            }
                            return result;
                        }
                    },
                    {
                        key: "has",
                        value: function has(target, key) {
                            var result = Reflect.has(target, key);
                            if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
                                track(target, "has", key);
                            }
                            return result;
                        }
                    },
                    {
                        key: "ownKeys",
                        value: function ownKeys(target) {
                            track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
                            return Reflect.ownKeys(target);
                        }
                    }
                ]);
                return MutableReactiveHandler;
            }(BaseReactiveHandler);
            var ReadonlyReactiveHandler = /*#__PURE__*/ function(BaseReactiveHandler) {
                _inherits(ReadonlyReactiveHandler, BaseReactiveHandler);
                function ReadonlyReactiveHandler() {
                    var isShallow2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                    _class_call_check(this, ReadonlyReactiveHandler);
                    return _call_super(this, ReadonlyReactiveHandler, [
                        true,
                        isShallow2
                    ]);
                }
                _create_class(ReadonlyReactiveHandler, [
                    {
                        key: "set",
                        value: function set(target, key) {
                            {
                                warn('Set operation on key "'.concat(String(key), '" failed: target is readonly.'), target);
                            }
                            return true;
                        }
                    },
                    {
                        key: "deleteProperty",
                        value: function deleteProperty(target, key) {
                            {
                                warn('Delete operation on key "'.concat(String(key), '" failed: target is readonly.'), target);
                            }
                            return true;
                        }
                    }
                ]);
                return ReadonlyReactiveHandler;
            }(BaseReactiveHandler);
            var mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
            var readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
            var shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
            var shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
            var toShallow = function(value) {
                return value;
            };
            var getProto = function(v1) {
                return Reflect.getPrototypeOf(v1);
            };
            function createIterableMethod(method, isReadonly2, isShallow2) {
                return function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    var _target;
                    var target = this["__v_raw"];
                    var rawTarget = toRaw(target);
                    var targetIsMap = shared.isMap(rawTarget);
                    var isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
                    var isKeyOnly = method === "keys" && targetIsMap;
                    var innerIterator = (_target = target)[method].apply(_target, _to_consumable_array(args));
                    var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
                    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
                    return(// iterable protocol
                    _define_property({
                        // iterator protocol
                        next: function next() {
                            var _innerIterator_next = innerIterator.next(), value = _innerIterator_next.value, done = _innerIterator_next.done;
                            return done ? {
                                value: value,
                                done: done
                            } : {
                                value: isPair ? [
                                    wrap(value[0]),
                                    wrap(value[1])
                                ] : wrap(value),
                                done: done
                            };
                        }
                    }, Symbol.iterator, function() {
                        return this;
                    }));
                };
            }
            function createReadonlyMethod(type) {
                return function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    {
                        var key = args[0] ? 'on key "'.concat(args[0], '" ') : "";
                        warn("".concat(shared.capitalize(type), " operation ").concat(key, "failed: target is readonly."), toRaw(this));
                    }
                    return type === "delete" ? false : type === "clear" ? void 0 : this;
                };
            }
            function createInstrumentations(readonly2, shallow) {
                var instrumentations = {
                    get: function get(key) {
                        var target = this["__v_raw"];
                        var rawTarget = toRaw(target);
                        var rawKey = toRaw(key);
                        if (!readonly2) {
                            if (shared.hasChanged(key, rawKey)) {
                                track(rawTarget, "get", key);
                            }
                            track(rawTarget, "get", rawKey);
                        }
                        var has = getProto(rawTarget).has;
                        var wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                        if (has.call(rawTarget, key)) {
                            return wrap(target.get(key));
                        } else if (has.call(rawTarget, rawKey)) {
                            return wrap(target.get(rawKey));
                        } else if (target !== rawTarget) {
                            target.get(key);
                        }
                    },
                    get size () {
                        var target = this["__v_raw"];
                        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
                        return Reflect.get(target, "size", target);
                    },
                    has: function has(key) {
                        var target = this["__v_raw"];
                        var rawTarget = toRaw(target);
                        var rawKey = toRaw(key);
                        if (!readonly2) {
                            if (shared.hasChanged(key, rawKey)) {
                                track(rawTarget, "has", key);
                            }
                            track(rawTarget, "has", rawKey);
                        }
                        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
                    },
                    forEach: function forEach(callback, thisArg) {
                        var observed = this;
                        var target = observed["__v_raw"];
                        var rawTarget = toRaw(target);
                        var wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
                        return target.forEach(function(value, key) {
                            return callback.call(thisArg, wrap(value), wrap(key), observed);
                        });
                    }
                };
                shared.extend(instrumentations, readonly2 ? {
                    add: createReadonlyMethod("add"),
                    set: createReadonlyMethod("set"),
                    delete: createReadonlyMethod("delete"),
                    clear: createReadonlyMethod("clear")
                } : {
                    add: function add(value) {
                        if (!shallow && !isShallow(value) && !isReadonly(value)) {
                            value = toRaw(value);
                        }
                        var target = toRaw(this);
                        var proto = getProto(target);
                        var hadKey = proto.has.call(target, value);
                        if (!hadKey) {
                            target.add(value);
                            trigger(target, "add", value, value);
                        }
                        return this;
                    },
                    set: function set(key, value) {
                        if (!shallow && !isShallow(value) && !isReadonly(value)) {
                            value = toRaw(value);
                        }
                        var target = toRaw(this);
                        var _getProto = getProto(target), has = _getProto.has, get = _getProto.get;
                        var hadKey = has.call(target, key);
                        if (!hadKey) {
                            key = toRaw(key);
                            hadKey = has.call(target, key);
                        } else {
                            checkIdentityKeys(target, has, key);
                        }
                        var oldValue = get.call(target, key);
                        target.set(key, value);
                        if (!hadKey) {
                            trigger(target, "add", key, value);
                        } else if (shared.hasChanged(value, oldValue)) {
                            trigger(target, "set", key, value, oldValue);
                        }
                        return this;
                    },
                    delete: function _delete(key) {
                        var target = toRaw(this);
                        var _getProto = getProto(target), has = _getProto.has, get = _getProto.get;
                        var hadKey = has.call(target, key);
                        if (!hadKey) {
                            key = toRaw(key);
                            hadKey = has.call(target, key);
                        } else {
                            checkIdentityKeys(target, has, key);
                        }
                        var oldValue = get ? get.call(target, key) : void 0;
                        var result = target.delete(key);
                        if (hadKey) {
                            trigger(target, "delete", key, void 0, oldValue);
                        }
                        return result;
                    },
                    clear: function clear() {
                        var target = toRaw(this);
                        var hadItems = target.size !== 0;
                        var oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
                        var result = target.clear();
                        if (hadItems) {
                            trigger(target, "clear", void 0, void 0, oldTarget);
                        }
                        return result;
                    }
                });
                var iteratorMethods = [
                    "keys",
                    "values",
                    "entries",
                    Symbol.iterator
                ];
                iteratorMethods.forEach(function(method) {
                    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
                });
                return instrumentations;
            }
            function createInstrumentationGetter(isReadonly2, shallow) {
                var instrumentations = createInstrumentations(isReadonly2, shallow);
                return function(target, key, receiver) {
                    if (key === "__v_isReactive") {
                        return !isReadonly2;
                    } else if (key === "__v_isReadonly") {
                        return isReadonly2;
                    } else if (key === "__v_raw") {
                        return target;
                    }
                    return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
                };
            }
            var mutableCollectionHandlers = {
                get: /* @__PURE__ */ createInstrumentationGetter(false, false)
            };
            var shallowCollectionHandlers = {
                get: /* @__PURE__ */ createInstrumentationGetter(false, true)
            };
            var readonlyCollectionHandlers = {
                get: /* @__PURE__ */ createInstrumentationGetter(true, false)
            };
            var shallowReadonlyCollectionHandlers = {
                get: /* @__PURE__ */ createInstrumentationGetter(true, true)
            };
            function checkIdentityKeys(target, has, key) {
                var rawKey = toRaw(key);
                if (rawKey !== key && has.call(target, rawKey)) {
                    var type = shared.toRawType(target);
                    warn("Reactive ".concat(type, " contains both the raw and reactive versions of the same object").concat(type === "Map" ? " as keys" : "", ", which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible."));
                }
            }
            var reactiveMap = /* @__PURE__ */ new WeakMap();
            var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
            var readonlyMap = /* @__PURE__ */ new WeakMap();
            var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
            function targetTypeMap(rawType) {
                switch(rawType){
                    case "Object":
                    case "Array":
                        return 1;
                    case "Map":
                    case "Set":
                    case "WeakMap":
                    case "WeakSet":
                        return 2;
                    default:
                        return 0;
                }
            }
            function getTargetType(value) {
                return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
            }
            function reactive(target) {
                if (isReadonly(target)) {
                    return target;
                }
                return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
            }
            function shallowReactive(target) {
                return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
            }
            function readonly(target) {
                return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
            }
            function shallowReadonly(target) {
                return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
            }
            function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
                if (!shared.isObject(target)) {
                    {
                        warn("value cannot be made ".concat(isReadonly2 ? "readonly" : "reactive", ": ").concat(String(target)));
                    }
                    return target;
                }
                if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
                    return target;
                }
                var existingProxy = proxyMap.get(target);
                if (existingProxy) {
                    return existingProxy;
                }
                var targetType = getTargetType(target);
                if (targetType === 0) {
                    return target;
                }
                var proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
                proxyMap.set(target, proxy);
                return proxy;
            }
            function isReactive(value) {
                if (isReadonly(value)) {
                    return isReactive(value["__v_raw"]);
                }
                return !!(value && value["__v_isReactive"]);
            }
            function isReadonly(value) {
                return !!(value && value["__v_isReadonly"]);
            }
            function isShallow(value) {
                return !!(value && value["__v_isShallow"]);
            }
            function isProxy(value) {
                return value ? !!value["__v_raw"] : false;
            }
            function toRaw(observed) {
                var raw = observed && observed["__v_raw"];
                return raw ? toRaw(raw) : observed;
            }
            function markRaw(value) {
                if (!shared.hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
                    shared.def(value, "__v_skip", true);
                }
                return value;
            }
            var toReactive = function(value) {
                return shared.isObject(value) ? reactive(value) : value;
            };
            var toReadonly = function(value) {
                return shared.isObject(value) ? readonly(value) : value;
            };
            function isRef(r) {
                return r ? r["__v_isRef"] === true : false;
            }
            function ref(value) {
                return createRef(value, false);
            }
            function shallowRef(value) {
                return createRef(value, true);
            }
            function createRef(rawValue, shallow) {
                if (isRef(rawValue)) {
                    return rawValue;
                }
                return new RefImpl(rawValue, shallow);
            }
            var RefImpl = /*#__PURE__*/ function() {
                function RefImpl(value, isShallow2) {
                    _class_call_check(this, RefImpl);
                    this.dep = new Dep();
                    this["__v_isRef"] = true;
                    this["__v_isShallow"] = false;
                    this._rawValue = isShallow2 ? value : toRaw(value);
                    this._value = isShallow2 ? value : toReactive(value);
                    this["__v_isShallow"] = isShallow2;
                }
                _create_class(RefImpl, [
                    {
                        key: "value",
                        get: function get() {
                            {
                                this.dep.track({
                                    target: this,
                                    type: "get",
                                    key: "value"
                                });
                            }
                            return this._value;
                        },
                        set: function set(newValue) {
                            var oldValue = this._rawValue;
                            var useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
                            newValue = useDirectValue ? newValue : toRaw(newValue);
                            if (shared.hasChanged(newValue, oldValue)) {
                                this._rawValue = newValue;
                                this._value = useDirectValue ? newValue : toReactive(newValue);
                                {
                                    this.dep.trigger({
                                        target: this,
                                        type: "set",
                                        key: "value",
                                        newValue: newValue,
                                        oldValue: oldValue
                                    });
                                }
                            }
                        }
                    }
                ]);
                return RefImpl;
            }();
            function triggerRef(ref2) {
                if (ref2.dep) {
                    {
                        ref2.dep.trigger({
                            target: ref2,
                            type: "set",
                            key: "value",
                            newValue: ref2._value
                        });
                    }
                }
            }
            function unref(ref2) {
                return isRef(ref2) ? ref2.value : ref2;
            }
            function toValue(source) {
                return shared.isFunction(source) ? source() : unref(source);
            }
            var shallowUnwrapHandlers = {
                get: function(target, key, receiver) {
                    return key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver));
                },
                set: function(target, key, value, receiver) {
                    var oldValue = target[key];
                    if (isRef(oldValue) && !isRef(value)) {
                        oldValue.value = value;
                        return true;
                    } else {
                        return Reflect.set(target, key, value, receiver);
                    }
                }
            };
            function proxyRefs(objectWithRefs) {
                return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
            }
            var CustomRefImpl = /*#__PURE__*/ function() {
                function CustomRefImpl(factory) {
                    _class_call_check(this, CustomRefImpl);
                    this["__v_isRef"] = true;
                    this._value = void 0;
                    var dep = this.dep = new Dep();
                    var _factory = factory(dep.track.bind(dep), dep.trigger.bind(dep)), get = _factory.get, set = _factory.set;
                    this._get = get;
                    this._set = set;
                }
                _create_class(CustomRefImpl, [
                    {
                        key: "value",
                        get: function get() {
                            return this._value = this._get();
                        },
                        set: function set(newVal) {
                            this._set(newVal);
                        }
                    }
                ]);
                return CustomRefImpl;
            }();
            function customRef(factory) {
                return new CustomRefImpl(factory);
            }
            function toRefs(object) {
                if (!isProxy(object)) {
                    warn("toRefs() expects a reactive object but received a plain one.");
                }
                var ret = shared.isArray(object) ? new Array(object.length) : {};
                for(var key in object){
                    ret[key] = propertyToRef(object, key);
                }
                return ret;
            }
            var ObjectRefImpl = /*#__PURE__*/ function() {
                function ObjectRefImpl(_object, _key, _defaultValue) {
                    _class_call_check(this, ObjectRefImpl);
                    this._object = _object;
                    this._key = _key;
                    this._defaultValue = _defaultValue;
                    this["__v_isRef"] = true;
                    this._value = void 0;
                }
                _create_class(ObjectRefImpl, [
                    {
                        key: "value",
                        get: function get() {
                            var val = this._object[this._key];
                            return this._value = val === void 0 ? this._defaultValue : val;
                        },
                        set: function set(newVal) {
                            this._object[this._key] = newVal;
                        }
                    },
                    {
                        key: "dep",
                        get: function get() {
                            return getDepFromReactive(toRaw(this._object), this._key);
                        }
                    }
                ]);
                return ObjectRefImpl;
            }();
            var GetterRefImpl = /*#__PURE__*/ function() {
                function GetterRefImpl(_getter) {
                    _class_call_check(this, GetterRefImpl);
                    this._getter = _getter;
                    this["__v_isRef"] = true;
                    this["__v_isReadonly"] = true;
                    this._value = void 0;
                }
                _create_class(GetterRefImpl, [
                    {
                        key: "value",
                        get: function get() {
                            return this._value = this._getter();
                        }
                    }
                ]);
                return GetterRefImpl;
            }();
            function toRef(source, key, defaultValue) {
                if (isRef(source)) {
                    return source;
                } else if (shared.isFunction(source)) {
                    return new GetterRefImpl(source);
                } else if (shared.isObject(source) && arguments.length > 1) {
                    return propertyToRef(source, key, defaultValue);
                } else {
                    return ref(source);
                }
            }
            function propertyToRef(source, key, defaultValue) {
                var val = source[key];
                return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
            }
            var ComputedRefImpl = /*#__PURE__*/ function() {
                function ComputedRefImpl(fn, setter, isSSR) {
                    _class_call_check(this, ComputedRefImpl);
                    this.fn = fn;
                    this.setter = setter;
                    this._value = void 0;
                    this.dep = new Dep(this);
                    this.__v_isRef = true;
                    this.deps = void 0;
                    this.depsTail = void 0;
                    this.flags = 16;
                    this.globalVersion = globalVersion - 1;
                    this.next = void 0;
                    this.effect = this;
                    this["__v_isReadonly"] = !setter;
                    this.isSSR = isSSR;
                }
                _create_class(ComputedRefImpl, [
                    {
                        /**
         * @internal
         */ key: "notify",
                        value: function notify() {
                            this.flags |= 16;
                            if (!(this.flags & 8) && // avoid infinite self recursion
                            activeSub !== this) {
                                batch(this, true);
                                return true;
                            }
                        }
                    },
                    {
                        key: "value",
                        get: function get() {
                            var link = this.dep.track({
                                target: this,
                                type: "get",
                                key: "value"
                            });
                            refreshComputed(this);
                            if (link) {
                                link.version = this.dep.version;
                            }
                            return this._value;
                        },
                        set: function set(newValue) {
                            if (this.setter) {
                                this.setter(newValue);
                            } else {
                                warn("Write operation failed: computed value is readonly");
                            }
                        }
                    }
                ]);
                return ComputedRefImpl;
            }();
            function computed(getterOrOptions, debugOptions) {
                var isSSR = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var getter;
                var setter;
                if (shared.isFunction(getterOrOptions)) {
                    getter = getterOrOptions;
                } else {
                    getter = getterOrOptions.get;
                    setter = getterOrOptions.set;
                }
                var cRef = new ComputedRefImpl(getter, setter, isSSR);
                if (debugOptions && !isSSR) {
                    cRef.onTrack = debugOptions.onTrack;
                    cRef.onTrigger = debugOptions.onTrigger;
                }
                return cRef;
            }
            var TrackOpTypes = {
                "GET": "get",
                "HAS": "has",
                "ITERATE": "iterate"
            };
            var TriggerOpTypes = {
                "SET": "set",
                "ADD": "add",
                "DELETE": "delete",
                "CLEAR": "clear"
            };
            var ReactiveFlags = {
                "SKIP": "__v_skip",
                "IS_REACTIVE": "__v_isReactive",
                "IS_READONLY": "__v_isReadonly",
                "IS_SHALLOW": "__v_isShallow",
                "RAW": "__v_raw",
                "IS_REF": "__v_isRef"
            };
            var WatchErrorCodes = {
                "WATCH_GETTER": 2,
                "2": "WATCH_GETTER",
                "WATCH_CALLBACK": 3,
                "3": "WATCH_CALLBACK",
                "WATCH_CLEANUP": 4,
                "4": "WATCH_CLEANUP"
            };
            var INITIAL_WATCHER_VALUE = {};
            var cleanupMap = /* @__PURE__ */ new WeakMap();
            var activeWatcher = void 0;
            function getCurrentWatcher() {
                return activeWatcher;
            }
            function onWatcherCleanup(cleanupFn) {
                var failSilently = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, owner = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : activeWatcher;
                if (owner) {
                    var cleanups = cleanupMap.get(owner);
                    if (!cleanups) cleanupMap.set(owner, cleanups = []);
                    cleanups.push(cleanupFn);
                } else if (!failSilently) {
                    warn("onWatcherCleanup() was called when there was no active watcher to associate with.");
                }
            }
            function watch(source, cb) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : shared.EMPTY_OBJ;
                var immediate = options.immediate, deep = options.deep, once = options.once, scheduler = options.scheduler, augmentJob = options.augmentJob, call = options.call;
                var warnInvalidSource = function(s) {
                    (options.onWarn || warn)("Invalid watch source: ", s, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
                };
                var reactiveGetter = function(source2) {
                    if (deep) return source2;
                    if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);
                    return traverse(source2);
                };
                var effect2;
                var getter;
                var cleanup;
                var boundCleanup;
                var forceTrigger = false;
                var isMultiSource = false;
                if (isRef(source)) {
                    getter = function() {
                        return source.value;
                    };
                    forceTrigger = isShallow(source);
                } else if (isReactive(source)) {
                    getter = function() {
                        return reactiveGetter(source);
                    };
                    forceTrigger = true;
                } else if (shared.isArray(source)) {
                    isMultiSource = true;
                    forceTrigger = source.some(function(s) {
                        return isReactive(s) || isShallow(s);
                    });
                    getter = function() {
                        return source.map(function(s) {
                            if (isRef(s)) {
                                return s.value;
                            } else if (isReactive(s)) {
                                return reactiveGetter(s);
                            } else if (shared.isFunction(s)) {
                                return call ? call(s, 2) : s();
                            } else {
                                warnInvalidSource(s);
                            }
                        });
                    };
                } else if (shared.isFunction(source)) {
                    if (cb) {
                        getter = call ? function() {
                            return call(source, 2);
                        } : source;
                    } else {
                        getter = function() {
                            if (cleanup) {
                                pauseTracking();
                                try {
                                    cleanup();
                                } finally{
                                    resetTracking();
                                }
                            }
                            var currentEffect = activeWatcher;
                            activeWatcher = effect2;
                            try {
                                return call ? call(source, 3, [
                                    boundCleanup
                                ]) : source(boundCleanup);
                            } finally{
                                activeWatcher = currentEffect;
                            }
                        };
                    }
                } else {
                    getter = shared.NOOP;
                    warnInvalidSource(source);
                }
                if (cb && deep) {
                    var baseGetter = getter;
                    var depth = deep === true ? Infinity : deep;
                    getter = function() {
                        return traverse(baseGetter(), depth);
                    };
                }
                var scope = getCurrentScope();
                var watchHandle = function() {
                    effect2.stop();
                    if (scope && scope.active) {
                        shared.remove(scope.effects, effect2);
                    }
                };
                if (once && cb) {
                    var _cb = cb;
                    cb = function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        _cb.apply(void 0, _to_consumable_array(args));
                        watchHandle();
                    };
                }
                var oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
                var job = function(immediateFirstRun) {
                    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
                        return;
                    }
                    if (cb) {
                        var newValue = effect2.run();
                        if (deep || forceTrigger || (isMultiSource ? newValue.some(function(v1, i) {
                            return shared.hasChanged(v1, oldValue[i]);
                        }) : shared.hasChanged(newValue, oldValue))) {
                            if (cleanup) {
                                cleanup();
                            }
                            var currentWatcher = activeWatcher;
                            activeWatcher = effect2;
                            try {
                                var args = [
                                    newValue,
                                    // pass undefined as the old value when it's changed for the first time
                                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                                    boundCleanup
                                ];
                                call ? call(cb, 3, args) : // @ts-expect-error
                                cb.apply(void 0, _to_consumable_array(args));
                                oldValue = newValue;
                            } finally{
                                activeWatcher = currentWatcher;
                            }
                        }
                    } else {
                        effect2.run();
                    }
                };
                if (augmentJob) {
                    augmentJob(job);
                }
                effect2 = new ReactiveEffect(getter);
                effect2.scheduler = scheduler ? function() {
                    return scheduler(job, false);
                } : job;
                boundCleanup = function(fn) {
                    return onWatcherCleanup(fn, false, effect2);
                };
                cleanup = effect2.onStop = function() {
                    var cleanups = cleanupMap.get(effect2);
                    if (cleanups) {
                        if (call) {
                            call(cleanups, 4);
                        } else {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = cleanups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var cleanup2 = _step.value;
                                    cleanup2();
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                        cleanupMap.delete(effect2);
                    }
                };
                {
                    effect2.onTrack = options.onTrack;
                    effect2.onTrigger = options.onTrigger;
                }
                if (cb) {
                    if (immediate) {
                        job(true);
                    } else {
                        oldValue = effect2.run();
                    }
                } else if (scheduler) {
                    scheduler(job.bind(null, true), true);
                } else {
                    effect2.run();
                }
                watchHandle.pause = effect2.pause.bind(effect2);
                watchHandle.resume = effect2.resume.bind(effect2);
                watchHandle.stop = watchHandle;
                return watchHandle;
            }
            function traverse(value) {
                var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity, seen = arguments.length > 2 ? arguments[2] : void 0;
                if (depth <= 0 || !shared.isObject(value) || value["__v_skip"]) {
                    return value;
                }
                seen = seen || /* @__PURE__ */ new Set();
                if (seen.has(value)) {
                    return value;
                }
                seen.add(value);
                depth--;
                if (isRef(value)) {
                    traverse(value.value, depth, seen);
                } else if (shared.isArray(value)) {
                    for(var i = 0; i < value.length; i++){
                        traverse(value[i], depth, seen);
                    }
                } else if (shared.isSet(value) || shared.isMap(value)) {
                    value.forEach(function(v1) {
                        traverse(v1, depth, seen);
                    });
                } else if (shared.isPlainObject(value)) {
                    for(var key in value){
                        traverse(value[key], depth, seen);
                    }
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = Object.getOwnPropertySymbols(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var key1 = _step.value;
                            if (Object.prototype.propertyIsEnumerable.call(value, key1)) {
                                traverse(value[key1], depth, seen);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                return value;
            }
            exports.ARRAY_ITERATE_KEY = ARRAY_ITERATE_KEY;
            exports.EffectFlags = EffectFlags;
            exports.EffectScope = EffectScope;
            exports.ITERATE_KEY = ITERATE_KEY;
            exports.MAP_KEY_ITERATE_KEY = MAP_KEY_ITERATE_KEY;
            exports.ReactiveEffect = ReactiveEffect;
            exports.ReactiveFlags = ReactiveFlags;
            exports.TrackOpTypes = TrackOpTypes;
            exports.TriggerOpTypes = TriggerOpTypes;
            exports.WatchErrorCodes = WatchErrorCodes;
            exports.computed = computed;
            exports.customRef = customRef;
            exports.effect = effect;
            exports.effectScope = effectScope;
            exports.enableTracking = enableTracking;
            exports.getCurrentScope = getCurrentScope;
            exports.getCurrentWatcher = getCurrentWatcher;
            exports.isProxy = isProxy;
            exports.isReactive = isReactive;
            exports.isReadonly = isReadonly;
            exports.isRef = isRef;
            exports.isShallow = isShallow;
            exports.markRaw = markRaw;
            exports.onEffectCleanup = onEffectCleanup;
            exports.onScopeDispose = onScopeDispose;
            exports.onWatcherCleanup = onWatcherCleanup;
            exports.pauseTracking = pauseTracking;
            exports.proxyRefs = proxyRefs;
            exports.reactive = reactive;
            exports.reactiveReadArray = reactiveReadArray;
            exports.readonly = readonly;
            exports.ref = ref;
            exports.resetTracking = resetTracking;
            exports.shallowReactive = shallowReactive;
            exports.shallowReadArray = shallowReadArray;
            exports.shallowReadonly = shallowReadonly;
            exports.shallowRef = shallowRef;
            exports.stop = stop;
            exports.toRaw = toRaw;
            exports.toReactive = toReactive;
            exports.toReadonly = toReadonly;
            exports.toRef = toRef;
            exports.toRefs = toRefs;
            exports.toValue = toValue;
            exports.track = track;
            exports.traverse = traverse;
            exports.trigger = trigger;
            exports.triggerRef = triggerRef;
            exports.unref = unref;
            exports.watch = watch;
        }
    });
    // ../../node_modules/.pnpm/@vue+reactivity@3.5.13/node_modules/@vue/reactivity/index.js
    var require_reactivity = __commonJS({
        "../../node_modules/.pnpm/@vue+reactivity@3.5.13/node_modules/@vue/reactivity/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_reactivity_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/dist/runtime-core.cjs.js
    var require_runtime_core_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/dist/runtime-core.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var reactivity = require_reactivity();
            var shared = require_shared();
            var stack = [];
            function pushWarningContext(vnode) {
                stack.push(vnode);
            }
            function popWarningContext() {
                stack.pop();
            }
            var isWarning = false;
            function warn$1(msg) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                if (isWarning) return;
                isWarning = true;
                reactivity.pauseTracking();
                var instance = stack.length ? stack[stack.length - 1].component : null;
                var appWarnHandler = instance && instance.appContext.config.warnHandler;
                var trace = getComponentTrace();
                if (appWarnHandler) {
                    callWithErrorHandling(appWarnHandler, instance, 11, [
                        // eslint-disable-next-line no-restricted-syntax
                        msg + args.map(function(a) {
                            var _a, _b;
                            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
                        }).join(""),
                        instance && instance.proxy,
                        trace.map(function(param) {
                            var vnode = param.vnode;
                            return "at <".concat(formatComponentName(instance, vnode.type), ">");
                        }).join("\n"),
                        trace
                    ]);
                } else {
                    var _console;
                    var warnArgs = [
                        "[Vue warn]: ".concat(msg)
                    ].concat(_to_consumable_array(args));
                    if (trace.length && // avoid spamming console during tests
                    true) {
                        var _warnArgs;
                        (_warnArgs = warnArgs).push.apply(_warnArgs, [
                            "\n"
                        ].concat(_to_consumable_array(formatTrace(trace))));
                    }
                    (_console = console).warn.apply(_console, _to_consumable_array(warnArgs));
                }
                reactivity.resetTracking();
                isWarning = false;
            }
            function getComponentTrace() {
                var currentVNode = stack[stack.length - 1];
                if (!currentVNode) {
                    return [];
                }
                var normalizedStack = [];
                while(currentVNode){
                    var last = normalizedStack[0];
                    if (last && last.vnode === currentVNode) {
                        last.recurseCount++;
                    } else {
                        normalizedStack.push({
                            vnode: currentVNode,
                            recurseCount: 0
                        });
                    }
                    var parentInstance = currentVNode.component && currentVNode.component.parent;
                    currentVNode = parentInstance && parentInstance.vnode;
                }
                return normalizedStack;
            }
            function formatTrace(trace) {
                var logs = [];
                trace.forEach(function(entry, i) {
                    var _logs;
                    (_logs = logs).push.apply(_logs, _to_consumable_array(i === 0 ? [] : [
                        "\n"
                    ]).concat(_to_consumable_array(formatTraceEntry(entry))));
                });
                return logs;
            }
            function formatTraceEntry(param) {
                var vnode = param.vnode, recurseCount = param.recurseCount;
                var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
                var isRoot = vnode.component ? vnode.component.parent == null : false;
                var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
                var close = ">" + postfix;
                return vnode.props ? [
                    open
                ].concat(_to_consumable_array(formatProps(vnode.props)), [
                    close
                ]) : [
                    open + close
                ];
            }
            function formatProps(props) {
                var res = [];
                var keys = Object.keys(props);
                keys.slice(0, 3).forEach(function(key) {
                    var _res;
                    (_res = res).push.apply(_res, _to_consumable_array(formatProp(key, props[key])));
                });
                if (keys.length > 3) {
                    res.push(" ...");
                }
                return res;
            }
            function formatProp(key, value, raw) {
                if (shared.isString(value)) {
                    value = JSON.stringify(value);
                    return raw ? value : [
                        "".concat(key, "=").concat(value)
                    ];
                } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
                    return raw ? value : [
                        "".concat(key, "=").concat(value)
                    ];
                } else if (reactivity.isRef(value)) {
                    value = formatProp(key, reactivity.toRaw(value.value), true);
                    return raw ? value : [
                        "".concat(key, "=Ref<"),
                        value,
                        ">"
                    ];
                } else if (shared.isFunction(value)) {
                    return [
                        "".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")
                    ];
                } else {
                    value = reactivity.toRaw(value);
                    return raw ? value : [
                        "".concat(key, "="),
                        value
                    ];
                }
            }
            function assertNumber(val, type) {
                if (val === void 0) {
                    return;
                } else if (typeof val !== "number") {
                    warn$1("".concat(type, " is not a valid number - got ").concat(JSON.stringify(val), "."));
                } else if (isNaN(val)) {
                    warn$1("".concat(type, " is NaN - the duration expression might be incorrect."));
                }
            }
            var ErrorCodes = {
                "SETUP_FUNCTION": 0,
                "0": "SETUP_FUNCTION",
                "RENDER_FUNCTION": 1,
                "1": "RENDER_FUNCTION",
                "NATIVE_EVENT_HANDLER": 5,
                "5": "NATIVE_EVENT_HANDLER",
                "COMPONENT_EVENT_HANDLER": 6,
                "6": "COMPONENT_EVENT_HANDLER",
                "VNODE_HOOK": 7,
                "7": "VNODE_HOOK",
                "DIRECTIVE_HOOK": 8,
                "8": "DIRECTIVE_HOOK",
                "TRANSITION_HOOK": 9,
                "9": "TRANSITION_HOOK",
                "APP_ERROR_HANDLER": 10,
                "10": "APP_ERROR_HANDLER",
                "APP_WARN_HANDLER": 11,
                "11": "APP_WARN_HANDLER",
                "FUNCTION_REF": 12,
                "12": "FUNCTION_REF",
                "ASYNC_COMPONENT_LOADER": 13,
                "13": "ASYNC_COMPONENT_LOADER",
                "SCHEDULER": 14,
                "14": "SCHEDULER",
                "COMPONENT_UPDATE": 15,
                "15": "COMPONENT_UPDATE",
                "APP_UNMOUNT_CLEANUP": 16,
                "16": "APP_UNMOUNT_CLEANUP"
            };
            var _obj;
            var ErrorTypeStrings$1 = (_obj = {}, _define_property(_obj, "sp", "serverPrefetch hook"), _define_property(_obj, "bc", "beforeCreate hook"), _define_property(_obj, "c", "created hook"), _define_property(_obj, "bm", "beforeMount hook"), _define_property(_obj, "m", "mounted hook"), _define_property(_obj, "bu", "beforeUpdate hook"), _define_property(_obj, "u", "updated"), _define_property(_obj, "bum", "beforeUnmount hook"), _define_property(_obj, "um", "unmounted hook"), _define_property(_obj, "a", "activated hook"), _define_property(_obj, "da", "deactivated hook"), _define_property(_obj, "ec", "errorCaptured hook"), _define_property(_obj, "rtc", "renderTracked hook"), _define_property(_obj, "rtg", "renderTriggered hook"), _define_property(_obj, 0, "setup function"), _define_property(_obj, 1, "render function"), _define_property(_obj, 2, "watcher getter"), _define_property(_obj, 3, "watcher callback"), _define_property(_obj, 4, "watcher cleanup function"), _define_property(_obj, 5, "native event handler"), _define_property(_obj, 6, "component event handler"), _define_property(_obj, 7, "vnode hook"), _define_property(_obj, 8, "directive hook"), _define_property(_obj, 9, "transition hook"), _define_property(_obj, 10, "app errorHandler"), _define_property(_obj, 11, "app warnHandler"), _define_property(_obj, 12, "ref function"), _define_property(_obj, 13, "async component loader"), _define_property(_obj, 14, "scheduler flush"), _define_property(_obj, 15, "component update"), _define_property(_obj, 16, "app unmount cleanup function"), _obj);
            function callWithErrorHandling(fn, instance, type, args) {
                try {
                    return args ? fn.apply(void 0, _to_consumable_array(args)) : fn();
                } catch (err) {
                    handleError(err, instance, type);
                }
            }
            function callWithAsyncErrorHandling(fn, instance, type, args) {
                if (shared.isFunction(fn)) {
                    var res = callWithErrorHandling(fn, instance, type, args);
                    if (res && shared.isPromise(res)) {
                        res.catch(function(err) {
                            handleError(err, instance, type);
                        });
                    }
                    return res;
                }
                if (shared.isArray(fn)) {
                    var values = [];
                    for(var i = 0; i < fn.length; i++){
                        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
                    }
                    return values;
                } else {
                    warn$1("Invalid value type passed to callWithAsyncErrorHandling(): ".concat(typeof fn === "undefined" ? "undefined" : _type_of(fn)));
                }
            }
            function handleError(err, instance, type) {
                var throwInDev = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                var contextVNode = instance ? instance.vnode : null;
                var _ref = instance && instance.appContext.config || shared.EMPTY_OBJ, errorHandler = _ref.errorHandler, throwUnhandledErrorInProduction = _ref.throwUnhandledErrorInProduction;
                if (instance) {
                    var cur = instance.parent;
                    var exposedInstance = instance.proxy;
                    var errorInfo = ErrorTypeStrings$1[type];
                    while(cur){
                        var errorCapturedHooks = cur.ec;
                        if (errorCapturedHooks) {
                            for(var i = 0; i < errorCapturedHooks.length; i++){
                                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                                    return;
                                }
                            }
                        }
                        cur = cur.parent;
                    }
                    if (errorHandler) {
                        reactivity.pauseTracking();
                        callWithErrorHandling(errorHandler, null, 10, [
                            err,
                            exposedInstance,
                            errorInfo
                        ]);
                        reactivity.resetTracking();
                        return;
                    }
                }
                logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
            }
            function logError(err, type, contextVNode) {
                var throwInDev = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, throwInProd = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                {
                    var info = ErrorTypeStrings$1[type];
                    if (contextVNode) {
                        pushWarningContext(contextVNode);
                    }
                    warn$1("Unhandled error".concat(info ? " during execution of ".concat(info) : ""));
                    if (contextVNode) {
                        popWarningContext();
                    }
                    if (throwInDev) {
                        throw err;
                    } else {
                        console.error(err);
                    }
                }
            }
            var queue = [];
            var flushIndex = -1;
            var pendingPostFlushCbs = [];
            var activePostFlushCbs = null;
            var postFlushIndex = 0;
            var resolvedPromise = /* @__PURE__ */ Promise.resolve();
            var currentFlushPromise = null;
            var RECURSION_LIMIT = 100;
            function nextTick(fn) {
                var p = currentFlushPromise || resolvedPromise;
                return fn ? p.then(this ? fn.bind(this) : fn) : p;
            }
            function findInsertionIndex(id) {
                var start = flushIndex + 1;
                var end = queue.length;
                while(start < end){
                    var middle = start + end >>> 1;
                    var middleJob = queue[middle];
                    var middleJobId = getId(middleJob);
                    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
                        start = middle + 1;
                    } else {
                        end = middle;
                    }
                }
                return start;
            }
            function queueJob(job) {
                if (!(job.flags & 1)) {
                    var jobId = getId(job);
                    var lastJob = queue[queue.length - 1];
                    if (!lastJob || // fast path when the job id is larger than the tail
                    !(job.flags & 2) && jobId >= getId(lastJob)) {
                        queue.push(job);
                    } else {
                        queue.splice(findInsertionIndex(jobId), 0, job);
                    }
                    job.flags |= 1;
                    queueFlush();
                }
            }
            function queueFlush() {
                if (!currentFlushPromise) {
                    currentFlushPromise = resolvedPromise.then(flushJobs);
                }
            }
            function queuePostFlushCb(cb) {
                if (!shared.isArray(cb)) {
                    if (activePostFlushCbs && cb.id === -1) {
                        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
                    } else if (!(cb.flags & 1)) {
                        pendingPostFlushCbs.push(cb);
                        cb.flags |= 1;
                    }
                } else {
                    var _pendingPostFlushCbs;
                    (_pendingPostFlushCbs = pendingPostFlushCbs).push.apply(_pendingPostFlushCbs, _to_consumable_array(cb));
                }
                queueFlush();
            }
            function flushPreFlushCbs(instance, seen) {
                var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : flushIndex + 1;
                {
                    seen = seen || /* @__PURE__ */ new Map();
                }
                for(; i < queue.length; i++){
                    var cb = queue[i];
                    if (cb && cb.flags & 2) {
                        if (instance && cb.id !== instance.uid) {
                            continue;
                        }
                        if (checkRecursiveUpdates(seen, cb)) {
                            continue;
                        }
                        queue.splice(i, 1);
                        i--;
                        if (cb.flags & 4) {
                            cb.flags &= ~1;
                        }
                        cb();
                        if (!(cb.flags & 4)) {
                            cb.flags &= ~1;
                        }
                    }
                }
            }
            function flushPostFlushCbs(seen) {
                if (pendingPostFlushCbs.length) {
                    var deduped = _to_consumable_array(new Set(pendingPostFlushCbs)).sort(function(a, b) {
                        return getId(a) - getId(b);
                    });
                    pendingPostFlushCbs.length = 0;
                    if (activePostFlushCbs) {
                        var _activePostFlushCbs;
                        (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _to_consumable_array(deduped));
                        return;
                    }
                    activePostFlushCbs = deduped;
                    {
                        seen = seen || /* @__PURE__ */ new Map();
                    }
                    for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
                        var cb = activePostFlushCbs[postFlushIndex];
                        if (checkRecursiveUpdates(seen, cb)) {
                            continue;
                        }
                        if (cb.flags & 4) {
                            cb.flags &= ~1;
                        }
                        if (!(cb.flags & 8)) cb();
                        cb.flags &= ~1;
                    }
                    activePostFlushCbs = null;
                    postFlushIndex = 0;
                }
            }
            var getId = function(job) {
                return job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
            };
            function flushJobs(seen) {
                {
                    seen = seen || /* @__PURE__ */ new Map();
                }
                var check = function(job) {
                    return checkRecursiveUpdates(seen, job);
                };
                try {
                    for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
                        var job = queue[flushIndex];
                        if (job && !(job.flags & 8)) {
                            if (check(job)) {
                                continue;
                            }
                            if (job.flags & 4) {
                                job.flags &= ~1;
                            }
                            callWithErrorHandling(job, job.i, job.i ? 15 : 14);
                            if (!(job.flags & 4)) {
                                job.flags &= ~1;
                            }
                        }
                    }
                } finally{
                    for(; flushIndex < queue.length; flushIndex++){
                        var job1 = queue[flushIndex];
                        if (job1) {
                            job1.flags &= ~1;
                        }
                    }
                    flushIndex = -1;
                    queue.length = 0;
                    flushPostFlushCbs(seen);
                    currentFlushPromise = null;
                    if (queue.length || pendingPostFlushCbs.length) {
                        flushJobs(seen);
                    }
                }
            }
            function checkRecursiveUpdates(seen, fn) {
                var count = seen.get(fn) || 0;
                if (count > RECURSION_LIMIT) {
                    var instance = fn.i;
                    var componentName = instance && getComponentName(instance.type);
                    handleError("Maximum recursive updates exceeded".concat(componentName ? " in component <".concat(componentName, ">") : "", ". This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function."), null, 10);
                    return true;
                }
                seen.set(fn, count + 1);
                return false;
            }
            var isHmrUpdating = false;
            var hmrDirtyComponents = /* @__PURE__ */ new Map();
            {
                shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {
                    createRecord: tryWrap(createRecord),
                    rerender: tryWrap(rerender),
                    reload: tryWrap(reload)
                };
            }
            var map = /* @__PURE__ */ new Map();
            function registerHMR(instance) {
                var id = instance.type.__hmrId;
                var record = map.get(id);
                if (!record) {
                    createRecord(id, instance.type);
                    record = map.get(id);
                }
                record.instances.add(instance);
            }
            function unregisterHMR(instance) {
                map.get(instance.type.__hmrId).instances.delete(instance);
            }
            function createRecord(id, initialDef) {
                if (map.has(id)) {
                    return false;
                }
                map.set(id, {
                    initialDef: normalizeClassComponent(initialDef),
                    instances: /* @__PURE__ */ new Set()
                });
                return true;
            }
            function normalizeClassComponent(component) {
                return isClassComponent(component) ? component.__vccOpts : component;
            }
            function rerender(id, newRender) {
                var record = map.get(id);
                if (!record) {
                    return;
                }
                record.initialDef.render = newRender;
                _to_consumable_array(record.instances).forEach(function(instance) {
                    if (newRender) {
                        instance.render = newRender;
                        normalizeClassComponent(instance.type).render = newRender;
                    }
                    instance.renderCache = [];
                    isHmrUpdating = true;
                    instance.update();
                    isHmrUpdating = false;
                });
            }
            function reload(id, newComp) {
                var _loop = function(i) {
                    var instance = instances[i];
                    var oldComp = normalizeClassComponent(instance.type);
                    var dirtyInstances = hmrDirtyComponents.get(oldComp);
                    if (!dirtyInstances) {
                        if (oldComp !== record.initialDef) {
                            updateComponentDef(oldComp, newComp);
                        }
                        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
                    }
                    dirtyInstances.add(instance);
                    instance.appContext.propsCache.delete(instance.type);
                    instance.appContext.emitsCache.delete(instance.type);
                    instance.appContext.optionsCache.delete(instance.type);
                    if (instance.ceReload) {
                        dirtyInstances.add(instance);
                        instance.ceReload(newComp.styles);
                        dirtyInstances.delete(instance);
                    } else if (instance.parent) {
                        queueJob(function() {
                            isHmrUpdating = true;
                            instance.parent.update();
                            isHmrUpdating = false;
                            dirtyInstances.delete(instance);
                        });
                    } else if (instance.appContext.reload) {
                        instance.appContext.reload();
                    } else if (typeof window !== "undefined") {
                        window.location.reload();
                    } else {
                        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
                    }
                    if (instance.root.ce && instance !== instance.root) {
                        instance.root.ce._removeChildStyle(oldComp);
                    }
                };
                var record = map.get(id);
                if (!record) return;
                newComp = normalizeClassComponent(newComp);
                updateComponentDef(record.initialDef, newComp);
                var instances = _to_consumable_array(record.instances);
                for(var i = 0; i < instances.length; i++)_loop(i);
                queuePostFlushCb(function() {
                    hmrDirtyComponents.clear();
                });
            }
            function updateComponentDef(oldComp, newComp) {
                shared.extend(oldComp, newComp);
                for(var key in oldComp){
                    if (key !== "__file" && !(key in newComp)) {
                        delete oldComp[key];
                    }
                }
            }
            function tryWrap(fn) {
                return function(id, arg) {
                    try {
                        return fn(id, arg);
                    } catch (e) {
                        console.error(e);
                        console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
                    }
                };
            }
            var devtools$1;
            var buffer = [];
            var devtoolsNotInstalled = false;
            function emit$1(event) {
                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    args[_key - 1] = arguments[_key];
                }
                if (devtools$1) {
                    var _devtools$1;
                    (_devtools$1 = devtools$1).emit.apply(_devtools$1, [
                        event
                    ].concat(_to_consumable_array(args)));
                } else if (!devtoolsNotInstalled) {
                    buffer.push({
                        event: event,
                        args: args
                    });
                }
            }
            function setDevtoolsHook$1(hook, target) {
                var _a, _b;
                devtools$1 = hook;
                if (devtools$1) {
                    var _devtools$1;
                    devtools$1.enabled = true;
                    buffer.forEach(function(param) {
                        var event = param.event, args = param.args;
                        return (_devtools$1 = devtools$1).emit.apply(_devtools$1, [
                            event
                        ].concat(_to_consumable_array(args)));
                    });
                    buffer = [];
                } else if (// handle late devtools injection - only do this if we are in an actual
                // browser environment to avoid the timer handle stalling test runner exit
                // (#4815)
                typeof window !== "undefined" && // some envs mock window but not fully
                window.HTMLElement && // also exclude jsdom
                // eslint-disable-next-line no-restricted-syntax
                !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
                    var replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
                    replay.push(function(newHook) {
                        setDevtoolsHook$1(newHook, target);
                    });
                    setTimeout(function() {
                        if (!devtools$1) {
                            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                            devtoolsNotInstalled = true;
                            buffer = [];
                        }
                    }, 3e3);
                } else {
                    devtoolsNotInstalled = true;
                    buffer = [];
                }
            }
            function devtoolsInitApp(app, version2) {
                emit$1("app:init", app, version2, {
                    Fragment: Fragment,
                    Text: Text,
                    Comment: Comment,
                    Static: Static
                });
            }
            function devtoolsUnmountApp(app) {
                emit$1("app:unmount", app);
            }
            var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
            var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
            var _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
            var devtoolsComponentRemoved = function(component) {
                if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
                !devtools$1.cleanupBuffer(component)) {
                    _devtoolsComponentRemoved(component);
                }
            };
            // @__NO_SIDE_EFFECTS__
            function createDevtoolsComponentHook(hook) {
                return function(component) {
                    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
                };
            }
            var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
            var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
            function createDevtoolsPerformanceHook(hook) {
                return function(component, type, time) {
                    emit$1(hook, component.appContext.app, component.uid, component, type, time);
                };
            }
            function devtoolsComponentEmit(component, event, params) {
                emit$1("component:emit", component.appContext.app, component, event, params);
            }
            var currentRenderingInstance = null;
            var currentScopeId = null;
            function setCurrentRenderingInstance(instance) {
                var prev = currentRenderingInstance;
                currentRenderingInstance = instance;
                currentScopeId = instance && instance.type.__scopeId || null;
                return prev;
            }
            function pushScopeId(id) {
                currentScopeId = id;
            }
            function popScopeId() {
                currentScopeId = null;
            }
            var withScopeId = function(_id) {
                return withCtx;
            };
            function withCtx(fn) {
                var ctx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentRenderingInstance, isNonScopedSlot = arguments.length > 2 ? arguments[2] : void 0;
                if (!ctx) return fn;
                if (fn._n) {
                    return fn;
                }
                var renderFnWithContext = function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (renderFnWithContext._d) {
                        setBlockTracking(-1);
                    }
                    var prevInstance = setCurrentRenderingInstance(ctx);
                    var res;
                    try {
                        res = fn.apply(void 0, _to_consumable_array(args));
                    } finally{
                        setCurrentRenderingInstance(prevInstance);
                        if (renderFnWithContext._d) {
                            setBlockTracking(1);
                        }
                    }
                    {
                        devtoolsComponentUpdated(ctx);
                    }
                    return res;
                };
                renderFnWithContext._n = true;
                renderFnWithContext._c = true;
                renderFnWithContext._d = true;
                return renderFnWithContext;
            }
            function validateDirectiveName(name) {
                if (shared.isBuiltInDirective(name)) {
                    warn$1("Do not use built-in directive ids as custom directive id: " + name);
                }
            }
            function withDirectives(vnode, directives) {
                if (currentRenderingInstance === null) {
                    warn$1("withDirectives can only be used inside render functions.");
                    return vnode;
                }
                var instance = getComponentPublicInstance(currentRenderingInstance);
                var bindings = vnode.dirs || (vnode.dirs = []);
                for(var i = 0; i < directives.length; i++){
                    var _directives_i = _sliced_to_array(directives[i], 4), dir = _directives_i[0], value = _directives_i[1], arg = _directives_i[2], tmp = _directives_i[3], modifiers = tmp === void 0 ? shared.EMPTY_OBJ : tmp;
                    if (dir) {
                        if (shared.isFunction(dir)) {
                            dir = {
                                mounted: dir,
                                updated: dir
                            };
                        }
                        if (dir.deep) {
                            reactivity.traverse(value);
                        }
                        bindings.push({
                            dir: dir,
                            instance: instance,
                            value: value,
                            oldValue: void 0,
                            arg: arg,
                            modifiers: modifiers
                        });
                    }
                }
                return vnode;
            }
            function invokeDirectiveHook(vnode, prevVNode, instance, name) {
                var bindings = vnode.dirs;
                var oldBindings = prevVNode && prevVNode.dirs;
                for(var i = 0; i < bindings.length; i++){
                    var binding = bindings[i];
                    if (oldBindings) {
                        binding.oldValue = oldBindings[i].value;
                    }
                    var hook = binding.dir[name];
                    if (hook) {
                        reactivity.pauseTracking();
                        callWithAsyncErrorHandling(hook, instance, 8, [
                            vnode.el,
                            binding,
                            vnode,
                            prevVNode
                        ]);
                        reactivity.resetTracking();
                    }
                }
            }
            var TeleportEndKey = Symbol("_vte");
            var isTeleport = function(type) {
                return type.__isTeleport;
            };
            var isTeleportDisabled = function(props) {
                return props && (props.disabled || props.disabled === "");
            };
            var isTeleportDeferred = function(props) {
                return props && (props.defer || props.defer === "");
            };
            var isTargetSVG = function(target) {
                return typeof SVGElement !== "undefined" && _instanceof(target, SVGElement);
            };
            var isTargetMathML = function(target) {
                return typeof MathMLElement === "function" && _instanceof(target, MathMLElement);
            };
            var resolveTarget = function(props, select) {
                var targetSelector = props && props.to;
                if (shared.isString(targetSelector)) {
                    if (!select) {
                        warn$1("Current renderer does not support string target for Teleports. (missing querySelector renderer option)");
                        return null;
                    } else {
                        var target = select(targetSelector);
                        if (!target && !isTeleportDisabled(props)) {
                            warn$1('Failed to locate Teleport target with selector "'.concat(targetSelector, '". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.'));
                        }
                        return target;
                    }
                } else {
                    if (!targetSelector && !isTeleportDisabled(props)) {
                        warn$1("Invalid Teleport target: ".concat(targetSelector));
                    }
                    return targetSelector;
                }
            };
            var TeleportImpl = {
                name: "Teleport",
                __isTeleport: true,
                process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
                    var mountChildren = internals.mc, patchChildren = internals.pc, patchBlockChildren = internals.pbc, _internals_o = internals.o, insert = _internals_o.insert, querySelector = _internals_o.querySelector, createText = _internals_o.createText, createComment = _internals_o.createComment;
                    var disabled = isTeleportDisabled(n2.props);
                    var shapeFlag = n2.shapeFlag, children = n2.children, dynamicChildren = n2.dynamicChildren;
                    if (isHmrUpdating) {
                        optimized = false;
                        dynamicChildren = null;
                    }
                    if (n1 == null) {
                        var placeholder = n2.el = createComment("teleport start");
                        var mainAnchor = n2.anchor = createComment("teleport end");
                        insert(placeholder, container, anchor);
                        insert(mainAnchor, container, anchor);
                        var mount = function(container2, anchor2) {
                            if (shapeFlag & 16) {
                                if (parentComponent && parentComponent.isCE) {
                                    parentComponent.ce._teleportTarget = container2;
                                }
                                mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            }
                        };
                        var mountToTarget = function() {
                            var target = n2.target = resolveTarget(n2.props, querySelector);
                            var targetAnchor = prepareAnchor(target, n2, createText, insert);
                            if (target) {
                                if (namespace !== "svg" && isTargetSVG(target)) {
                                    namespace = "svg";
                                } else if (namespace !== "mathml" && isTargetMathML(target)) {
                                    namespace = "mathml";
                                }
                                if (!disabled) {
                                    mount(target, targetAnchor);
                                    updateCssVars(n2, false);
                                }
                            } else if (!disabled) {
                                warn$1("Invalid Teleport target on mount:", target, "(".concat(typeof target === "undefined" ? "undefined" : _type_of(target), ")"));
                            }
                        };
                        if (disabled) {
                            mount(container, mainAnchor);
                            updateCssVars(n2, true);
                        }
                        if (isTeleportDeferred(n2.props)) {
                            queuePostRenderEffect(function() {
                                mountToTarget();
                                n2.el.__isMounted = true;
                            }, parentSuspense);
                        } else {
                            mountToTarget();
                        }
                    } else {
                        if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
                            queuePostRenderEffect(function() {
                                TeleportImpl.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                                delete n1.el.__isMounted;
                            }, parentSuspense);
                            return;
                        }
                        n2.el = n1.el;
                        n2.targetStart = n1.targetStart;
                        var mainAnchor1 = n2.anchor = n1.anchor;
                        var target = n2.target = n1.target;
                        var targetAnchor = n2.targetAnchor = n1.targetAnchor;
                        var wasDisabled = isTeleportDisabled(n1.props);
                        var currentContainer = wasDisabled ? container : target;
                        var currentAnchor = wasDisabled ? mainAnchor1 : targetAnchor;
                        if (namespace === "svg" || isTargetSVG(target)) {
                            namespace = "svg";
                        } else if (namespace === "mathml" || isTargetMathML(target)) {
                            namespace = "mathml";
                        }
                        if (dynamicChildren) {
                            patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);
                            traverseStaticChildren(n1, n2, true);
                        } else if (!optimized) {
                            patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);
                        }
                        if (disabled) {
                            if (!wasDisabled) {
                                moveTeleport(n2, container, mainAnchor1, internals, 1);
                            } else {
                                if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                                    n2.props.to = n1.props.to;
                                }
                            }
                        } else {
                            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                                var nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                                if (nextTarget) {
                                    moveTeleport(n2, nextTarget, null, internals, 0);
                                } else {
                                    warn$1("Invalid Teleport target on update:", target, "(".concat(typeof target === "undefined" ? "undefined" : _type_of(target), ")"));
                                }
                            } else if (wasDisabled) {
                                moveTeleport(n2, target, targetAnchor, internals, 1);
                            }
                        }
                        updateCssVars(n2, disabled);
                    }
                },
                remove: function remove(vnode, parentComponent, parentSuspense, param, doRemove) {
                    var unmount = param.um, _param_o = param.o, hostRemove = _param_o.remove;
                    var shapeFlag = vnode.shapeFlag, children = vnode.children, anchor = vnode.anchor, targetStart = vnode.targetStart, targetAnchor = vnode.targetAnchor, target = vnode.target, props = vnode.props;
                    if (target) {
                        hostRemove(targetStart);
                        hostRemove(targetAnchor);
                    }
                    doRemove && hostRemove(anchor);
                    if (shapeFlag & 16) {
                        var shouldRemove = doRemove || !isTeleportDisabled(props);
                        for(var i = 0; i < children.length; i++){
                            var child = children[i];
                            unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
                        }
                    }
                },
                move: moveTeleport,
                hydrate: hydrateTeleport
            };
            function moveTeleport(vnode, container, parentAnchor, param) {
                var insert = param.o.insert, move = param.m, moveType = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2;
                if (moveType === 0) {
                    insert(vnode.targetAnchor, container, parentAnchor);
                }
                var el = vnode.el, anchor = vnode.anchor, shapeFlag = vnode.shapeFlag, children = vnode.children, props = vnode.props;
                var isReorder = moveType === 2;
                if (isReorder) {
                    insert(el, container, parentAnchor);
                }
                if (!isReorder || isTeleportDisabled(props)) {
                    if (shapeFlag & 16) {
                        for(var i = 0; i < children.length; i++){
                            move(children[i], container, parentAnchor, 2);
                        }
                    }
                }
                if (isReorder) {
                    insert(anchor, container, parentAnchor);
                }
            }
            function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, param, hydrateChildren) {
                var _param_o = param.o, nextSibling = _param_o.nextSibling, parentNode = _param_o.parentNode, querySelector = _param_o.querySelector, insert = _param_o.insert, createText = _param_o.createText;
                var target = vnode.target = resolveTarget(vnode.props, querySelector);
                if (target) {
                    var disabled = isTeleportDisabled(vnode.props);
                    var targetNode = target._lpa || target.firstChild;
                    if (vnode.shapeFlag & 16) {
                        if (disabled) {
                            vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                            vnode.targetStart = targetNode;
                            vnode.targetAnchor = targetNode && nextSibling(targetNode);
                        } else {
                            vnode.anchor = nextSibling(node);
                            var targetAnchor = targetNode;
                            while(targetAnchor){
                                if (targetAnchor && targetAnchor.nodeType === 8) {
                                    if (targetAnchor.data === "teleport start anchor") {
                                        vnode.targetStart = targetAnchor;
                                    } else if (targetAnchor.data === "teleport anchor") {
                                        vnode.targetAnchor = targetAnchor;
                                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                                        break;
                                    }
                                }
                                targetAnchor = nextSibling(targetAnchor);
                            }
                            if (!vnode.targetAnchor) {
                                prepareAnchor(target, vnode, createText, insert);
                            }
                            hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
                        }
                    }
                    updateCssVars(vnode, disabled);
                }
                return vnode.anchor && nextSibling(vnode.anchor);
            }
            var Teleport = TeleportImpl;
            function updateCssVars(vnode, isDisabled) {
                var ctx = vnode.ctx;
                if (ctx && ctx.ut) {
                    var node, anchor;
                    if (isDisabled) {
                        node = vnode.el;
                        anchor = vnode.anchor;
                    } else {
                        node = vnode.targetStart;
                        anchor = vnode.targetAnchor;
                    }
                    while(node && node !== anchor){
                        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
                        node = node.nextSibling;
                    }
                    ctx.ut();
                }
            }
            function prepareAnchor(target, vnode, createText, insert) {
                var targetStart = vnode.targetStart = createText("");
                var targetAnchor = vnode.targetAnchor = createText("");
                targetStart[TeleportEndKey] = targetAnchor;
                if (target) {
                    insert(targetStart, target);
                    insert(targetAnchor, target);
                }
                return targetAnchor;
            }
            var leaveCbKey = Symbol("_leaveCb");
            var enterCbKey = Symbol("_enterCb");
            function useTransitionState() {
                var state = {
                    isMounted: false,
                    isLeaving: false,
                    isUnmounting: false,
                    leavingVNodes: /* @__PURE__ */ new Map()
                };
                onMounted(function() {
                    state.isMounted = true;
                });
                onBeforeUnmount(function() {
                    state.isUnmounting = true;
                });
                return state;
            }
            var TransitionHookValidator = [
                Function,
                Array
            ];
            var BaseTransitionPropsValidators = {
                mode: String,
                appear: Boolean,
                persisted: Boolean,
                // enter
                onBeforeEnter: TransitionHookValidator,
                onEnter: TransitionHookValidator,
                onAfterEnter: TransitionHookValidator,
                onEnterCancelled: TransitionHookValidator,
                // leave
                onBeforeLeave: TransitionHookValidator,
                onLeave: TransitionHookValidator,
                onAfterLeave: TransitionHookValidator,
                onLeaveCancelled: TransitionHookValidator,
                // appear
                onBeforeAppear: TransitionHookValidator,
                onAppear: TransitionHookValidator,
                onAfterAppear: TransitionHookValidator,
                onAppearCancelled: TransitionHookValidator
            };
            var recursiveGetSubtree = function(instance) {
                var subTree = instance.subTree;
                return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
            };
            var BaseTransitionImpl = {
                name: "BaseTransition",
                props: BaseTransitionPropsValidators,
                setup: function setup(props, param) {
                    var slots = param.slots;
                    var instance = getCurrentInstance();
                    var state = useTransitionState();
                    return function() {
                        var children = slots.default && getTransitionRawChildren(slots.default(), true);
                        if (!children || !children.length) {
                            return;
                        }
                        var child = findNonCommentChild(children);
                        var rawProps = reactivity.toRaw(props);
                        var mode = rawProps.mode;
                        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
                            warn$1("invalid <transition> mode: ".concat(mode));
                        }
                        if (state.isLeaving) {
                            return emptyPlaceholder(child);
                        }
                        var innerChild = getInnerChild$1(child);
                        if (!innerChild) {
                            return emptyPlaceholder(child);
                        }
                        var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance, // #11061, ensure enterHooks is fresh after clone
                        function(hooks) {
                            return enterHooks = hooks;
                        });
                        if (innerChild.type !== Comment) {
                            setTransitionHooks(innerChild, enterHooks);
                        }
                        var oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
                        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
                            var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                            setTransitionHooks(oldInnerChild, leavingHooks);
                            if (mode === "out-in" && innerChild.type !== Comment) {
                                state.isLeaving = true;
                                leavingHooks.afterLeave = function() {
                                    state.isLeaving = false;
                                    if (!(instance.job.flags & 8)) {
                                        instance.update();
                                    }
                                    delete leavingHooks.afterLeave;
                                    oldInnerChild = void 0;
                                };
                                return emptyPlaceholder(child);
                            } else if (mode === "in-out" && innerChild.type !== Comment) {
                                leavingHooks.delayLeave = function(el, earlyRemove, delayedLeave) {
                                    var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                                    el[leaveCbKey] = function() {
                                        earlyRemove();
                                        el[leaveCbKey] = void 0;
                                        delete enterHooks.delayedLeave;
                                        oldInnerChild = void 0;
                                    };
                                    enterHooks.delayedLeave = function() {
                                        delayedLeave();
                                        delete enterHooks.delayedLeave;
                                        oldInnerChild = void 0;
                                    };
                                };
                            } else {
                                oldInnerChild = void 0;
                            }
                        } else if (oldInnerChild) {
                            oldInnerChild = void 0;
                        }
                        return child;
                    };
                }
            };
            function findNonCommentChild(children) {
                var child = children[0];
                if (children.length > 1) {
                    var hasFound = false;
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var c = _step.value;
                            if (c.type !== Comment) {
                                if (hasFound) {
                                    warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                                    break;
                                }
                                child = c;
                                hasFound = true;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
                return child;
            }
            var BaseTransition = BaseTransitionImpl;
            function getLeavingNodesForType(state, vnode) {
                var leavingVNodes = state.leavingVNodes;
                var leavingVNodesCache = leavingVNodes.get(vnode.type);
                if (!leavingVNodesCache) {
                    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
                    leavingVNodes.set(vnode.type, leavingVNodesCache);
                }
                return leavingVNodesCache;
            }
            function resolveTransitionHooks(vnode, props, state, instance, postClone) {
                var appear = props.appear, mode = props.mode, _props_persisted = props.persisted, persisted = _props_persisted === void 0 ? false : _props_persisted, onBeforeEnter = props.onBeforeEnter, onEnter = props.onEnter, onAfterEnter = props.onAfterEnter, onEnterCancelled = props.onEnterCancelled, onBeforeLeave = props.onBeforeLeave, onLeave = props.onLeave, onAfterLeave = props.onAfterLeave, onLeaveCancelled = props.onLeaveCancelled, onBeforeAppear = props.onBeforeAppear, onAppear = props.onAppear, onAfterAppear = props.onAfterAppear, onAppearCancelled = props.onAppearCancelled;
                var key = String(vnode.key);
                var leavingVNodesCache = getLeavingNodesForType(state, vnode);
                var callHook2 = function(hook, args) {
                    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
                };
                var callAsyncHook = function(hook, args) {
                    var done = args[1];
                    callHook2(hook, args);
                    if (shared.isArray(hook)) {
                        if (hook.every(function(hook2) {
                            return hook2.length <= 1;
                        })) done();
                    } else if (hook.length <= 1) {
                        done();
                    }
                };
                var hooks = {
                    mode: mode,
                    persisted: persisted,
                    beforeEnter: function beforeEnter(el) {
                        var hook = onBeforeEnter;
                        if (!state.isMounted) {
                            if (appear) {
                                hook = onBeforeAppear || onBeforeEnter;
                            } else {
                                return;
                            }
                        }
                        if (el[leaveCbKey]) {
                            el[leaveCbKey](true);
                        }
                        var leavingVNode = leavingVNodesCache[key];
                        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
                            leavingVNode.el[leaveCbKey]();
                        }
                        callHook2(hook, [
                            el
                        ]);
                    },
                    enter: function enter(el) {
                        var hook = onEnter;
                        var afterHook = onAfterEnter;
                        var cancelHook = onEnterCancelled;
                        if (!state.isMounted) {
                            if (appear) {
                                hook = onAppear || onEnter;
                                afterHook = onAfterAppear || onAfterEnter;
                                cancelHook = onAppearCancelled || onEnterCancelled;
                            } else {
                                return;
                            }
                        }
                        var called = false;
                        var done = el[enterCbKey] = function(cancelled) {
                            if (called) return;
                            called = true;
                            if (cancelled) {
                                callHook2(cancelHook, [
                                    el
                                ]);
                            } else {
                                callHook2(afterHook, [
                                    el
                                ]);
                            }
                            if (hooks.delayedLeave) {
                                hooks.delayedLeave();
                            }
                            el[enterCbKey] = void 0;
                        };
                        if (hook) {
                            callAsyncHook(hook, [
                                el,
                                done
                            ]);
                        } else {
                            done();
                        }
                    },
                    leave: function leave(el, remove) {
                        var key2 = String(vnode.key);
                        if (el[enterCbKey]) {
                            el[enterCbKey](true);
                        }
                        if (state.isUnmounting) {
                            return remove();
                        }
                        callHook2(onBeforeLeave, [
                            el
                        ]);
                        var called = false;
                        var done = el[leaveCbKey] = function(cancelled) {
                            if (called) return;
                            called = true;
                            remove();
                            if (cancelled) {
                                callHook2(onLeaveCancelled, [
                                    el
                                ]);
                            } else {
                                callHook2(onAfterLeave, [
                                    el
                                ]);
                            }
                            el[leaveCbKey] = void 0;
                            if (leavingVNodesCache[key2] === vnode) {
                                delete leavingVNodesCache[key2];
                            }
                        };
                        leavingVNodesCache[key2] = vnode;
                        if (onLeave) {
                            callAsyncHook(onLeave, [
                                el,
                                done
                            ]);
                        } else {
                            done();
                        }
                    },
                    clone: function clone(vnode2) {
                        var hooks2 = resolveTransitionHooks(vnode2, props, state, instance, postClone);
                        if (postClone) postClone(hooks2);
                        return hooks2;
                    }
                };
                return hooks;
            }
            function emptyPlaceholder(vnode) {
                if (isKeepAlive(vnode)) {
                    vnode = cloneVNode(vnode);
                    vnode.children = null;
                    return vnode;
                }
            }
            function getInnerChild$1(vnode) {
                if (!isKeepAlive(vnode)) {
                    if (isTeleport(vnode.type) && vnode.children) {
                        return findNonCommentChild(vnode.children);
                    }
                    return vnode;
                }
                if (vnode.component) {
                    return vnode.component.subTree;
                }
                var shapeFlag = vnode.shapeFlag, children = vnode.children;
                if (children) {
                    if (shapeFlag & 16) {
                        return children[0];
                    }
                    if (shapeFlag & 32 && shared.isFunction(children.default)) {
                        return children.default();
                    }
                }
            }
            function setTransitionHooks(vnode, hooks) {
                if (vnode.shapeFlag & 6 && vnode.component) {
                    vnode.transition = hooks;
                    setTransitionHooks(vnode.component.subTree, hooks);
                } else if (vnode.shapeFlag & 128) {
                    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
                    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
                } else {
                    vnode.transition = hooks;
                }
            }
            function getTransitionRawChildren(children) {
                var keepComment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, parentKey = arguments.length > 2 ? arguments[2] : void 0;
                var ret = [];
                var keyedFragmentCount = 0;
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    var key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
                    if (child.type === Fragment) {
                        if (child.patchFlag & 128) keyedFragmentCount++;
                        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
                    } else if (keepComment || child.type !== Comment) {
                        ret.push(key != null ? cloneVNode(child, {
                            key: key
                        }) : child);
                    }
                }
                if (keyedFragmentCount > 1) {
                    for(var i1 = 0; i1 < ret.length; i1++){
                        ret[i1].patchFlag = -2;
                    }
                }
                return ret;
            }
            // @__NO_SIDE_EFFECTS__
            function defineComponent(options, extraOptions) {
                return shared.isFunction(options) ? // #8236: extend call and options.name access are considered side-effects
                // by Rollup, so we have to wrap it in a pure-annotated IIFE.
                /* @__PURE__ */ function() {
                    return shared.extend({
                        name: options.name
                    }, extraOptions, {
                        setup: options
                    });
                }() : options;
            }
            function useId() {
                var i = getCurrentInstance();
                if (i) {
                    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
                } else {
                    warn$1("useId() is called when there is no active component instance to be associated with.");
                }
                return "";
            }
            function markAsyncBoundary(instance) {
                instance.ids = [
                    instance.ids[0] + instance.ids[2]++ + "-",
                    0,
                    0
                ];
            }
            var knownTemplateRefs = /* @__PURE__ */ new WeakSet();
            function useTemplateRef(key) {
                var i = getCurrentInstance();
                var r = reactivity.shallowRef(null);
                if (i) {
                    var refs = i.refs === shared.EMPTY_OBJ ? i.refs = {} : i.refs;
                    var desc;
                    if ((desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {
                        warn$1("useTemplateRef('".concat(key, "') already exists."));
                    } else {
                        Object.defineProperty(refs, key, {
                            enumerable: true,
                            get: function() {
                                return r.value;
                            },
                            set: function(val) {
                                return r.value = val;
                            }
                        });
                    }
                } else {
                    warn$1("useTemplateRef() is called when there is no active component instance to be associated with.");
                }
                var ret = reactivity.readonly(r);
                {
                    knownTemplateRefs.add(ret);
                }
                return ret;
            }
            function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
                var isUnmount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                if (shared.isArray(rawRef)) {
                    rawRef.forEach(function(r, i) {
                        return setRef(r, oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
                    });
                    return;
                }
                if (isAsyncWrapper(vnode) && !isUnmount) {
                    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
                        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
                    }
                    return;
                }
                var refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
                var value = isUnmount ? null : refValue;
                var owner = rawRef.i, ref = rawRef.r;
                if (!owner) {
                    warn$1("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
                    return;
                }
                var oldRef = oldRawRef && oldRawRef.r;
                var refs = owner.refs === shared.EMPTY_OBJ ? owner.refs = {} : owner.refs;
                var setupState = owner.setupState;
                var rawSetupState = reactivity.toRaw(setupState);
                var canSetSetupRef = setupState === shared.EMPTY_OBJ ? function() {
                    return false;
                } : function(key) {
                    {
                        if (shared.hasOwn(rawSetupState, key) && !reactivity.isRef(rawSetupState[key])) {
                            warn$1('Template ref "'.concat(key, '" used on a non-ref value. It will not work in the production build.'));
                        }
                        if (knownTemplateRefs.has(rawSetupState[key])) {
                            return false;
                        }
                    }
                    return shared.hasOwn(rawSetupState, key);
                };
                if (oldRef != null && oldRef !== ref) {
                    if (shared.isString(oldRef)) {
                        refs[oldRef] = null;
                        if (canSetSetupRef(oldRef)) {
                            setupState[oldRef] = null;
                        }
                    } else if (reactivity.isRef(oldRef)) {
                        oldRef.value = null;
                    }
                }
                if (shared.isFunction(ref)) {
                    callWithErrorHandling(ref, owner, 12, [
                        value,
                        refs
                    ]);
                } else {
                    var _isString = shared.isString(ref);
                    var _isRef = reactivity.isRef(ref);
                    if (_isString || _isRef) {
                        var doSet = function() {
                            if (rawRef.f) {
                                var existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
                                if (isUnmount) {
                                    shared.isArray(existing) && shared.remove(existing, refValue);
                                } else {
                                    if (!shared.isArray(existing)) {
                                        if (_isString) {
                                            refs[ref] = [
                                                refValue
                                            ];
                                            if (canSetSetupRef(ref)) {
                                                setupState[ref] = refs[ref];
                                            }
                                        } else {
                                            ref.value = [
                                                refValue
                                            ];
                                            if (rawRef.k) refs[rawRef.k] = ref.value;
                                        }
                                    } else if (!existing.includes(refValue)) {
                                        existing.push(refValue);
                                    }
                                }
                            } else if (_isString) {
                                refs[ref] = value;
                                if (canSetSetupRef(ref)) {
                                    setupState[ref] = value;
                                }
                            } else if (_isRef) {
                                ref.value = value;
                                if (rawRef.k) refs[rawRef.k] = value;
                            } else {
                                warn$1("Invalid template ref type:", ref, "(".concat(typeof ref === "undefined" ? "undefined" : _type_of(ref), ")"));
                            }
                        };
                        if (value) {
                            doSet.id = -1;
                            queuePostRenderEffect(doSet, parentSuspense);
                        } else {
                            doSet();
                        }
                    } else {
                        warn$1("Invalid template ref type:", ref, "(".concat(typeof ref === "undefined" ? "undefined" : _type_of(ref), ")"));
                    }
                }
            }
            var hasLoggedMismatchError = false;
            var logMismatchError = function() {
                if (hasLoggedMismatchError) {
                    return;
                }
                console.error("Hydration completed but contains mismatches.");
                hasLoggedMismatchError = true;
            };
            var isSVGContainer = function(container) {
                return container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
            };
            var isMathMLContainer = function(container) {
                return container.namespaceURI.includes("MathML");
            };
            var getContainerType = function(container) {
                if (container.nodeType !== 1) return void 0;
                if (isSVGContainer(container)) return "svg";
                if (isMathMLContainer(container)) return "mathml";
                return void 0;
            };
            var isComment = function(node) {
                return node.nodeType === 8;
            };
            function createHydrationFunctions(rendererInternals) {
                var mountComponent = rendererInternals.mt, patch = rendererInternals.p, _rendererInternals_o = rendererInternals.o, patchProp = _rendererInternals_o.patchProp, createText = _rendererInternals_o.createText, nextSibling = _rendererInternals_o.nextSibling, parentNode = _rendererInternals_o.parentNode, remove = _rendererInternals_o.remove, insert = _rendererInternals_o.insert, createComment = _rendererInternals_o.createComment;
                var hydrate = function(vnode, container) {
                    if (!container.hasChildNodes()) {
                        warn$1("Attempting to hydrate existing markup but container is empty. Performing full mount instead.");
                        patch(null, vnode, container);
                        flushPostFlushCbs();
                        container._vnode = vnode;
                        return;
                    }
                    hydrateNode(container.firstChild, vnode, null, null, null);
                    flushPostFlushCbs();
                    container._vnode = vnode;
                };
                var hydrateNode = function(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
                    var optimized = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                    optimized = optimized || !!vnode.dynamicChildren;
                    var isFragmentStart = isComment(node) && node.data === "[";
                    var onMismatch = function() {
                        return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
                    };
                    var type = vnode.type, ref = vnode.ref, shapeFlag = vnode.shapeFlag, patchFlag = vnode.patchFlag;
                    var domType = node.nodeType;
                    vnode.el = node;
                    {
                        shared.def(node, "__vnode", vnode, true);
                        shared.def(node, "__vueParentComponent", parentComponent, true);
                    }
                    if (patchFlag === -2) {
                        optimized = false;
                        vnode.dynamicChildren = null;
                    }
                    var nextNode = null;
                    switch(type){
                        case Text:
                            if (domType !== 3) {
                                if (vnode.children === "") {
                                    insert(vnode.el = createText(""), parentNode(node), node);
                                    nextNode = node;
                                } else {
                                    nextNode = onMismatch();
                                }
                            } else {
                                if (node.data !== vnode.children) {
                                    warn$1("Hydration text mismatch in", node.parentNode, "\n  - rendered on server: ".concat(JSON.stringify(node.data), "\n  - expected on client: ").concat(JSON.stringify(vnode.children)));
                                    logMismatchError();
                                    node.data = vnode.children;
                                }
                                nextNode = nextSibling(node);
                            }
                            break;
                        case Comment:
                            if (isTemplateNode(node)) {
                                nextNode = nextSibling(node);
                                replaceNode(vnode.el = node.content.firstChild, node, parentComponent);
                            } else if (domType !== 8 || isFragmentStart) {
                                nextNode = onMismatch();
                            } else {
                                nextNode = nextSibling(node);
                            }
                            break;
                        case Static:
                            if (isFragmentStart) {
                                node = nextSibling(node);
                                domType = node.nodeType;
                            }
                            if (domType === 1 || domType === 3) {
                                nextNode = node;
                                var needToAdoptContent = !vnode.children.length;
                                for(var i = 0; i < vnode.staticCount; i++){
                                    if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                                    if (i === vnode.staticCount - 1) {
                                        vnode.anchor = nextNode;
                                    }
                                    nextNode = nextSibling(nextNode);
                                }
                                return isFragmentStart ? nextSibling(nextNode) : nextNode;
                            } else {
                                onMismatch();
                            }
                            break;
                        case Fragment:
                            if (!isFragmentStart) {
                                nextNode = onMismatch();
                            } else {
                                nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                            }
                            break;
                        default:
                            if (shapeFlag & 1) {
                                if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
                                    nextNode = onMismatch();
                                } else {
                                    nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                                }
                            } else if (shapeFlag & 6) {
                                vnode.slotScopeIds = slotScopeIds;
                                var container = parentNode(node);
                                if (isFragmentStart) {
                                    nextNode = locateClosingAnchor(node);
                                } else if (isComment(node) && node.data === "teleport start") {
                                    nextNode = locateClosingAnchor(node, node.data, "teleport end");
                                } else {
                                    nextNode = nextSibling(node);
                                }
                                mountComponent(vnode, container, null, parentComponent, parentSuspense, getContainerType(container), optimized);
                                if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
                                    var subTree;
                                    if (isFragmentStart) {
                                        subTree = createVNode(Fragment);
                                        subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                                    } else {
                                        subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                                    }
                                    subTree.el = node;
                                    vnode.component.subTree = subTree;
                                }
                            } else if (shapeFlag & 64) {
                                if (domType !== 8) {
                                    nextNode = onMismatch();
                                } else {
                                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                                }
                            } else if (shapeFlag & 128) {
                                nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, getContainerType(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                            } else {
                                warn$1("Invalid HostVNode type:", type, "(".concat(typeof type === "undefined" ? "undefined" : _type_of(type), ")"));
                            }
                    }
                    if (ref != null) {
                        setRef(ref, null, parentSuspense, vnode);
                    }
                    return nextNode;
                };
                var hydrateElement = function(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
                    optimized = optimized || !!vnode.dynamicChildren;
                    var type = vnode.type, props = vnode.props, patchFlag = vnode.patchFlag, shapeFlag = vnode.shapeFlag, dirs = vnode.dirs, transition = vnode.transition;
                    var forcePatch = type === "input" || type === "option";
                    {
                        if (dirs) {
                            invokeDirectiveHook(vnode, null, parentComponent, "created");
                        }
                        var needCallTransitionHooks = false;
                        if (isTemplateNode(el)) {
                            needCallTransitionHooks = needTransition(null, // no need check parentSuspense in hydration
                            transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
                            var content = el.content.firstChild;
                            if (needCallTransitionHooks) {
                                transition.beforeEnter(content);
                            }
                            replaceNode(content, el, parentComponent);
                            vnode.el = el = content;
                        }
                        if (shapeFlag & 16 && // skip if element has innerHTML / textContent
                        !(props && (props.innerHTML || props.textContent))) {
                            var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                            var hasWarned2 = false;
                            while(next){
                                if (!isMismatchAllowed(el, 1)) {
                                    if (!hasWarned2) {
                                        warn$1("Hydration children mismatch on", el, "\nServer rendered element contains more child nodes than client vdom.");
                                        hasWarned2 = true;
                                    }
                                    logMismatchError();
                                }
                                var cur = next;
                                next = next.nextSibling;
                                remove(cur);
                            }
                        } else if (shapeFlag & 8) {
                            var clientText = vnode.children;
                            if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
                                clientText = clientText.slice(1);
                            }
                            if (el.textContent !== clientText) {
                                if (!isMismatchAllowed(el, 0)) {
                                    warn$1("Hydration text content mismatch on", el, "\n  - rendered on server: ".concat(el.textContent, "\n  - expected on client: ").concat(vnode.children));
                                    logMismatchError();
                                }
                                el.textContent = vnode.children;
                            }
                        }
                        if (props) {
                            {
                                var isCustomElement = el.tagName.includes("-");
                                for(var key in props){
                                    if (// #11189 skip if this node has directives that have created hooks
                                    // as it could have mutated the DOM in any possible way
                                    !(dirs && dirs.some(function(d) {
                                        return d.dir.created;
                                    })) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {
                                        logMismatchError();
                                    }
                                    if (forcePatch && (key.endsWith("value") || key === "indeterminate") || shared.isOn(key) && !shared.isReservedProp(key) || // force hydrate v-bind with .prop modifiers
                                    key[0] === "." || isCustomElement) {
                                        patchProp(el, key, null, props[key], void 0, parentComponent);
                                    }
                                }
                            }
                        }
                        var vnodeHooks;
                        if (vnodeHooks = props && props.onVnodeBeforeMount) {
                            invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                        }
                        if (dirs) {
                            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
                        }
                        if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
                            queueEffectWithSuspense(function() {
                                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                                needCallTransitionHooks && transition.enter(el);
                                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                            }, parentSuspense);
                        }
                    }
                    return el.nextSibling;
                };
                var hydrateChildren = function(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
                    optimized = optimized || !!parentVNode.dynamicChildren;
                    var children = parentVNode.children;
                    var l = children.length;
                    var hasWarned2 = false;
                    for(var i = 0; i < l; i++){
                        var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
                        var isText = vnode.type === Text;
                        if (node) {
                            if (isText && !optimized) {
                                if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
                                    insert(createText(node.data.slice(vnode.children.length)), container, nextSibling(node));
                                    node.data = vnode.children;
                                }
                            }
                            node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                        } else if (isText && !vnode.children) {
                            insert(vnode.el = createText(""), container);
                        } else {
                            if (!isMismatchAllowed(container, 1)) {
                                if (!hasWarned2) {
                                    warn$1("Hydration children mismatch on", container, "\nServer rendered element contains fewer child nodes than client vdom.");
                                    hasWarned2 = true;
                                }
                                logMismatchError();
                            }
                            patch(null, vnode, container, null, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
                        }
                    }
                    return node;
                };
                var hydrateFragment = function(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
                    var fragmentSlotScopeIds = vnode.slotScopeIds;
                    if (fragmentSlotScopeIds) {
                        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
                    }
                    var container = parentNode(node);
                    var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
                    if (next && isComment(next) && next.data === "]") {
                        return nextSibling(vnode.anchor = next);
                    } else {
                        logMismatchError();
                        insert(vnode.anchor = createComment("]"), container, next);
                        return next;
                    }
                };
                var handleMismatch = function(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
                    if (!isMismatchAllowed(node.parentElement, 1)) {
                        warn$1("Hydration node mismatch:\n- rendered on server:", node, node.nodeType === 3 ? "(text)" : isComment(node) && node.data === "[" ? "(start of fragment)" : "", "\n- expected on client:", vnode.type);
                        logMismatchError();
                    }
                    vnode.el = null;
                    if (isFragment) {
                        var end = locateClosingAnchor(node);
                        while(true){
                            var next2 = nextSibling(node);
                            if (next2 && next2 !== end) {
                                remove(next2);
                            } else {
                                break;
                            }
                        }
                    }
                    var next = nextSibling(node);
                    var container = parentNode(node);
                    remove(node);
                    patch(null, vnode, container, next, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);
                    if (parentComponent) {
                        parentComponent.vnode.el = vnode.el;
                        updateHOCHostEl(parentComponent, vnode.el);
                    }
                    return next;
                };
                var locateClosingAnchor = function(node) {
                    var open = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "[", close = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "]";
                    var match = 0;
                    while(node){
                        node = nextSibling(node);
                        if (node && isComment(node)) {
                            if (node.data === open) match++;
                            if (node.data === close) {
                                if (match === 0) {
                                    return nextSibling(node);
                                } else {
                                    match--;
                                }
                            }
                        }
                    }
                    return node;
                };
                var replaceNode = function(newNode, oldNode, parentComponent) {
                    var parentNode2 = oldNode.parentNode;
                    if (parentNode2) {
                        parentNode2.replaceChild(newNode, oldNode);
                    }
                    var parent = parentComponent;
                    while(parent){
                        if (parent.vnode.el === oldNode) {
                            parent.vnode.el = parent.subTree.el = newNode;
                        }
                        parent = parent.parent;
                    }
                };
                var isTemplateNode = function(node) {
                    return node.nodeType === 1 && node.tagName === "TEMPLATE";
                };
                return [
                    hydrate,
                    hydrateNode
                ];
            }
            function propHasMismatch(el, key, clientValue, vnode, instance) {
                var mismatchType;
                var mismatchKey;
                var actual;
                var expected;
                if (key === "class") {
                    actual = el.getAttribute("class");
                    expected = shared.normalizeClass(clientValue);
                    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
                        mismatchType = 2;
                        mismatchKey = "class";
                    }
                } else if (key === "style") {
                    actual = el.getAttribute("style") || "";
                    expected = shared.isString(clientValue) ? clientValue : shared.stringifyStyle(shared.normalizeStyle(clientValue));
                    var actualMap = toStyleMap(actual);
                    var expectedMap = toStyleMap(expected);
                    if (vnode.dirs) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = vnode.dirs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var _step_value = _step.value, dir = _step_value.dir, value = _step_value.value;
                                if (dir.name === "show" && !value) {
                                    expectedMap.set("display", "none");
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                    if (instance) {
                        resolveCssVars(instance, vnode, expectedMap);
                    }
                    if (!isMapEqual(actualMap, expectedMap)) {
                        mismatchType = 3;
                        mismatchKey = "style";
                    }
                } else if (_instanceof(el, SVGElement) && shared.isKnownSvgAttr(key) || _instanceof(el, HTMLElement) && (shared.isBooleanAttr(key) || shared.isKnownHtmlAttr(key))) {
                    if (shared.isBooleanAttr(key)) {
                        actual = el.hasAttribute(key);
                        expected = shared.includeBooleanAttr(clientValue);
                    } else if (clientValue == null) {
                        actual = el.hasAttribute(key);
                        expected = false;
                    } else {
                        if (el.hasAttribute(key)) {
                            actual = el.getAttribute(key);
                        } else if (key === "value" && el.tagName === "TEXTAREA") {
                            actual = el.value;
                        } else {
                            actual = false;
                        }
                        expected = shared.isRenderableAttrValue(clientValue) ? String(clientValue) : false;
                    }
                    if (actual !== expected) {
                        mismatchType = 4;
                        mismatchKey = key;
                    }
                }
                if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
                    var format = function(v1) {
                        return v1 === false ? "(not rendered)" : "".concat(mismatchKey, '="').concat(v1, '"');
                    };
                    var preSegment = "Hydration ".concat(MismatchTypeString[mismatchType], " mismatch on");
                    var postSegment = "\n  - rendered on server: ".concat(format(actual), "\n  - expected on client: ").concat(format(expected), "\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.");
                    {
                        warn$1(preSegment, el, postSegment);
                    }
                    return true;
                }
                return false;
            }
            function toClassSet(str) {
                return new Set(str.trim().split(/\s+/));
            }
            function isSetEqual(a, b) {
                if (a.size !== b.size) {
                    return false;
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var s = _step.value;
                        if (!b.has(s)) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
            function toStyleMap(str) {
                var styleMap = /* @__PURE__ */ new Map();
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = str.split(";")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var item = _step.value;
                        var _item_split = _sliced_to_array(item.split(":"), 2), key = _item_split[0], value = _item_split[1];
                        key = key.trim();
                        value = value && value.trim();
                        if (key && value) {
                            styleMap.set(key, value);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return styleMap;
            }
            function isMapEqual(a, b) {
                if (a.size !== b.size) {
                    return false;
                }
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
                        if (value !== b.get(key)) {
                            return false;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
                return true;
            }
            function resolveCssVars(instance, vnode, expectedMap) {
                var root = instance.subTree;
                if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
                    var cssVars = instance.getCssVars();
                    for(var key in cssVars){
                        expectedMap.set("--".concat(shared.getEscapedCssVarName(key, false)), String(cssVars[key]));
                    }
                }
                if (vnode === root && instance.parent) {
                    resolveCssVars(instance.parent, instance.vnode, expectedMap);
                }
            }
            var allowMismatchAttr = "data-allow-mismatch";
            var _obj1;
            var MismatchTypeString = (_obj1 = {}, _define_property(_obj1, 0, "text"), _define_property(_obj1, 1, "children"), _define_property(_obj1, 2, "class"), _define_property(_obj1, 3, "style"), _define_property(_obj1, 4, "attribute"), _obj1);
            function isMismatchAllowed(el, allowedType) {
                if (allowedType === 0 || allowedType === 1) {
                    while(el && !el.hasAttribute(allowMismatchAttr)){
                        el = el.parentElement;
                    }
                }
                var allowedAttr = el && el.getAttribute(allowMismatchAttr);
                if (allowedAttr == null) {
                    return false;
                } else if (allowedAttr === "") {
                    return true;
                } else {
                    var list = allowedAttr.split(",");
                    if (allowedType === 0 && list.includes("children")) {
                        return true;
                    }
                    return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
                }
            }
            var requestIdleCallback = shared.getGlobalThis().requestIdleCallback || function(cb) {
                return setTimeout(cb, 1);
            };
            var cancelIdleCallback = shared.getGlobalThis().cancelIdleCallback || function(id) {
                return clearTimeout(id);
            };
            var hydrateOnIdle = function() {
                var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1e4;
                return function(hydrate) {
                    var id = requestIdleCallback(hydrate, {
                        timeout: timeout
                    });
                    return function() {
                        return cancelIdleCallback(id);
                    };
                };
            };
            function elementIsVisibleInViewport(el) {
                var _el_getBoundingClientRect = el.getBoundingClientRect(), top = _el_getBoundingClientRect.top, left = _el_getBoundingClientRect.left, bottom = _el_getBoundingClientRect.bottom, right = _el_getBoundingClientRect.right;
                var innerHeight = window.innerHeight, innerWidth = window.innerWidth;
                return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
            }
            var hydrateOnVisible = function(opts) {
                return function(hydrate, forEach) {
                    var ob = new IntersectionObserver(function(entries) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var e = _step.value;
                                if (!e.isIntersecting) continue;
                                ob.disconnect();
                                hydrate();
                                break;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }, opts);
                    forEach(function(el) {
                        if (!_instanceof(el, Element)) return;
                        if (elementIsVisibleInViewport(el)) {
                            hydrate();
                            ob.disconnect();
                            return false;
                        }
                        ob.observe(el);
                    });
                    return function() {
                        return ob.disconnect();
                    };
                };
            };
            var hydrateOnMediaQuery = function(query) {
                return function(hydrate) {
                    if (query) {
                        var mql = matchMedia(query);
                        if (mql.matches) {
                            hydrate();
                        } else {
                            mql.addEventListener("change", hydrate, {
                                once: true
                            });
                            return function() {
                                return mql.removeEventListener("change", hydrate);
                            };
                        }
                    }
                };
            };
            var hydrateOnInteraction = function() {
                var interactions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
                return function(hydrate, forEach) {
                    if (shared.isString(interactions)) interactions = [
                        interactions
                    ];
                    var hasHydrated = false;
                    var doHydrate = function(e) {
                        if (!hasHydrated) {
                            hasHydrated = true;
                            teardown();
                            hydrate();
                            e.target.dispatchEvent(new e.constructor(e.type, e));
                        }
                    };
                    var teardown = function() {
                        forEach(function(el) {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = interactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var i = _step.value;
                                    el.removeEventListener(i, doHydrate);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        });
                    };
                    forEach(function(el) {
                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                        try {
                            for(var _iterator = interactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                var i = _step.value;
                                el.addEventListener(i, doHydrate, {
                                    once: true
                                });
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally{
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally{
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    });
                    return teardown;
                };
            };
            function forEachElement(node, cb) {
                if (isComment(node) && node.data === "[") {
                    var depth = 1;
                    var next = node.nextSibling;
                    while(next){
                        if (next.nodeType === 1) {
                            var result = cb(next);
                            if (result === false) {
                                break;
                            }
                        } else if (isComment(next)) {
                            if (next.data === "]") {
                                if (--depth === 0) break;
                            } else if (next.data === "[") {
                                depth++;
                            }
                        }
                        next = next.nextSibling;
                    }
                } else {
                    cb(node);
                }
            }
            var isAsyncWrapper = function(i) {
                return !!i.type.__asyncLoader;
            };
            // @__NO_SIDE_EFFECTS__
            function defineAsyncComponent(source) {
                if (shared.isFunction(source)) {
                    source = {
                        loader: source
                    };
                }
                var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _source_delay = source.delay, delay = _source_delay === void 0 ? 200 : _source_delay, hydrateStrategy = source.hydrate, timeout = source.timeout, _source_suspensible = source.// undefined = never times out
                suspensible, suspensible = _source_suspensible === void 0 ? true : _source_suspensible, userOnError = source.onError;
                var pendingRequest = null;
                var resolvedComp;
                var retries = 0;
                var retry = function() {
                    retries++;
                    pendingRequest = null;
                    return load();
                };
                var load = function() {
                    var thisRequest;
                    return pendingRequest || (thisRequest = pendingRequest = loader().catch(function(err) {
                        err = _instanceof(err, Error) ? err : new Error(String(err));
                        if (userOnError) {
                            return new Promise(function(resolve2, reject) {
                                var userRetry = function() {
                                    return resolve2(retry());
                                };
                                var userFail = function() {
                                    return reject(err);
                                };
                                userOnError(err, userRetry, userFail, retries + 1);
                            });
                        } else {
                            throw err;
                        }
                    }).then(function(comp) {
                        if (thisRequest !== pendingRequest && pendingRequest) {
                            return pendingRequest;
                        }
                        if (!comp) {
                            warn$1("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.");
                        }
                        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
                            comp = comp.default;
                        }
                        if (comp && !shared.isObject(comp) && !shared.isFunction(comp)) {
                            throw new Error("Invalid async component load result: ".concat(comp));
                        }
                        resolvedComp = comp;
                        return comp;
                    }));
                };
                return /* @__PURE__ */ defineComponent({
                    name: "AsyncComponentWrapper",
                    __asyncLoader: load,
                    __asyncHydrate: function __asyncHydrate(el, instance, hydrate) {
                        var doHydrate = hydrateStrategy ? function() {
                            var teardown = hydrateStrategy(hydrate, function(cb) {
                                return forEachElement(el, cb);
                            });
                            if (teardown) {
                                (instance.bum || (instance.bum = [])).push(teardown);
                            }
                        } : hydrate;
                        if (resolvedComp) {
                            doHydrate();
                        } else {
                            load().then(function() {
                                return !instance.isUnmounted && doHydrate();
                            });
                        }
                    },
                    get __asyncResolved () {
                        return resolvedComp;
                    },
                    setup: function setup() {
                        var instance = currentInstance;
                        markAsyncBoundary(instance);
                        if (resolvedComp) {
                            return function() {
                                return createInnerComp(resolvedComp, instance);
                            };
                        }
                        var onError = function(err) {
                            pendingRequest = null;
                            handleError(err, instance, 13, !errorComponent);
                        };
                        if (suspensible && instance.suspense || isInSSRComponentSetup) {
                            return load().then(function(comp) {
                                return function() {
                                    return createInnerComp(comp, instance);
                                };
                            }).catch(function(err) {
                                onError(err);
                                return function() {
                                    return errorComponent ? createVNode(errorComponent, {
                                        error: err
                                    }) : null;
                                };
                            });
                        }
                        var loaded = reactivity.ref(false);
                        var error = reactivity.ref();
                        var delayed = reactivity.ref(!!delay);
                        if (delay) {
                            setTimeout(function() {
                                delayed.value = false;
                            }, delay);
                        }
                        if (timeout != null) {
                            setTimeout(function() {
                                if (!loaded.value && !error.value) {
                                    var err = new Error("Async component timed out after ".concat(timeout, "ms."));
                                    onError(err);
                                    error.value = err;
                                }
                            }, timeout);
                        }
                        load().then(function() {
                            loaded.value = true;
                            if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                                instance.parent.update();
                            }
                        }).catch(function(err) {
                            onError(err);
                            error.value = err;
                        });
                        return function() {
                            if (loaded.value && resolvedComp) {
                                return createInnerComp(resolvedComp, instance);
                            } else if (error.value && errorComponent) {
                                return createVNode(errorComponent, {
                                    error: error.value
                                });
                            } else if (loadingComponent && !delayed.value) {
                                return createVNode(loadingComponent);
                            }
                        };
                    }
                });
            }
            function createInnerComp(comp, parent) {
                var _parent_vnode = parent.vnode, ref2 = _parent_vnode.ref, props = _parent_vnode.props, children = _parent_vnode.children, ce = _parent_vnode.ce;
                var vnode = createVNode(comp, props, children);
                vnode.ref = ref2;
                vnode.ce = ce;
                delete parent.vnode.ce;
                return vnode;
            }
            var isKeepAlive = function(vnode) {
                return vnode.type.__isKeepAlive;
            };
            var KeepAliveImpl = {
                name: "KeepAlive",
                // Marker for special handling inside the renderer. We are not using a ===
                // check directly on KeepAlive in the renderer, because importing it directly
                // would prevent it from being tree-shaken.
                __isKeepAlive: true,
                props: {
                    include: [
                        String,
                        RegExp,
                        Array
                    ],
                    exclude: [
                        String,
                        RegExp,
                        Array
                    ],
                    max: [
                        String,
                        Number
                    ]
                },
                setup: function setup(props, param) {
                    var slots = param.slots;
                    var instance = getCurrentInstance();
                    var sharedContext = instance.ctx;
                    if (!sharedContext.renderer) {
                        return function() {
                            var children = slots.default && slots.default();
                            return children && children.length === 1 ? children[0] : children;
                        };
                    }
                    var cache = /* @__PURE__ */ new Map();
                    var keys = /* @__PURE__ */ new Set();
                    var current = null;
                    {
                        instance.__v_cache = cache;
                    }
                    var parentSuspense = instance.suspense;
                    var _sharedContext_renderer = sharedContext.renderer, patch = _sharedContext_renderer.p, move = _sharedContext_renderer.m, _unmount = _sharedContext_renderer.um, createElement = _sharedContext_renderer.o.createElement;
                    var storageContainer = createElement("div");
                    sharedContext.activate = function(vnode, container, anchor, namespace, optimized) {
                        var instance2 = vnode.component;
                        move(vnode, container, anchor, 0, parentSuspense);
                        patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, namespace, vnode.slotScopeIds, optimized);
                        queuePostRenderEffect(function() {
                            instance2.isDeactivated = false;
                            if (instance2.a) {
                                shared.invokeArrayFns(instance2.a);
                            }
                            var vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                            if (vnodeHook) {
                                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                            }
                        }, parentSuspense);
                        {
                            devtoolsComponentAdded(instance2);
                        }
                    };
                    sharedContext.deactivate = function(vnode) {
                        var instance2 = vnode.component;
                        invalidateMount(instance2.m);
                        invalidateMount(instance2.a);
                        move(vnode, storageContainer, null, 1, parentSuspense);
                        queuePostRenderEffect(function() {
                            if (instance2.da) {
                                shared.invokeArrayFns(instance2.da);
                            }
                            var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                            if (vnodeHook) {
                                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                            }
                            instance2.isDeactivated = true;
                        }, parentSuspense);
                        {
                            devtoolsComponentAdded(instance2);
                        }
                    };
                    function unmount(vnode) {
                        resetShapeFlag(vnode);
                        _unmount(vnode, instance, parentSuspense, true);
                    }
                    function pruneCache(filter) {
                        cache.forEach(function(vnode, key) {
                            var name = getComponentName(vnode.type);
                            if (name && !filter(name)) {
                                pruneCacheEntry(key);
                            }
                        });
                    }
                    function pruneCacheEntry(key) {
                        var cached = cache.get(key);
                        if (cached && (!current || !isSameVNodeType(cached, current))) {
                            unmount(cached);
                        } else if (current) {
                            resetShapeFlag(current);
                        }
                        cache.delete(key);
                        keys.delete(key);
                    }
                    watch(function() {
                        return [
                            props.include,
                            props.exclude
                        ];
                    }, function(param) {
                        var _param = _sliced_to_array(param, 2), include = _param[0], exclude = _param[1];
                        include && pruneCache(function(name) {
                            return matches(include, name);
                        });
                        exclude && pruneCache(function(name) {
                            return !matches(exclude, name);
                        });
                    }, // prune post-render after `current` has been updated
                    {
                        flush: "post",
                        deep: true
                    });
                    var pendingCacheKey = null;
                    var cacheSubtree = function() {
                        if (pendingCacheKey != null) {
                            if (isSuspense(instance.subTree.type)) {
                                queuePostRenderEffect(function() {
                                    cache.set(pendingCacheKey, getInnerChild(instance.subTree));
                                }, instance.subTree.suspense);
                            } else {
                                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
                            }
                        }
                    };
                    onMounted(cacheSubtree);
                    onUpdated(cacheSubtree);
                    onBeforeUnmount(function() {
                        cache.forEach(function(cached) {
                            var subTree = instance.subTree, suspense = instance.suspense;
                            var vnode = getInnerChild(subTree);
                            if (cached.type === vnode.type && cached.key === vnode.key) {
                                resetShapeFlag(vnode);
                                var da = vnode.component.da;
                                da && queuePostRenderEffect(da, suspense);
                                return;
                            }
                            unmount(cached);
                        });
                    });
                    return function() {
                        pendingCacheKey = null;
                        if (!slots.default) {
                            return current = null;
                        }
                        var children = slots.default();
                        var rawVNode = children[0];
                        if (children.length > 1) {
                            {
                                warn$1("KeepAlive should contain exactly one component child.");
                            }
                            current = null;
                            return children;
                        } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                            current = null;
                            return rawVNode;
                        }
                        var vnode = getInnerChild(rawVNode);
                        if (vnode.type === Comment) {
                            current = null;
                            return vnode;
                        }
                        var comp = vnode.type;
                        var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
                        var include = props.include, exclude = props.exclude, max = props.max;
                        if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                            vnode.shapeFlag &= ~256;
                            current = vnode;
                            return rawVNode;
                        }
                        var key = vnode.key == null ? comp : vnode.key;
                        var cachedVNode = cache.get(key);
                        if (vnode.el) {
                            vnode = cloneVNode(vnode);
                            if (rawVNode.shapeFlag & 128) {
                                rawVNode.ssContent = vnode;
                            }
                        }
                        pendingCacheKey = key;
                        if (cachedVNode) {
                            vnode.el = cachedVNode.el;
                            vnode.component = cachedVNode.component;
                            if (vnode.transition) {
                                setTransitionHooks(vnode, vnode.transition);
                            }
                            vnode.shapeFlag |= 512;
                            keys.delete(key);
                            keys.add(key);
                        } else {
                            keys.add(key);
                            if (max && keys.size > parseInt(max, 10)) {
                                pruneCacheEntry(keys.values().next().value);
                            }
                        }
                        vnode.shapeFlag |= 256;
                        current = vnode;
                        return isSuspense(rawVNode.type) ? rawVNode : vnode;
                    };
                }
            };
            var KeepAlive = KeepAliveImpl;
            function matches(pattern, name) {
                if (shared.isArray(pattern)) {
                    return pattern.some(function(p) {
                        return matches(p, name);
                    });
                } else if (shared.isString(pattern)) {
                    return pattern.split(",").includes(name);
                } else if (shared.isRegExp(pattern)) {
                    pattern.lastIndex = 0;
                    return pattern.test(name);
                }
                return false;
            }
            function onActivated(hook, target) {
                registerKeepAliveHook(hook, "a", target);
            }
            function onDeactivated(hook, target) {
                registerKeepAliveHook(hook, "da", target);
            }
            function registerKeepAliveHook(hook, type) {
                var target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : currentInstance;
                var wrappedHook = hook.__wdc || (hook.__wdc = function() {
                    var current = target;
                    while(current){
                        if (current.isDeactivated) {
                            return;
                        }
                        current = current.parent;
                    }
                    return hook();
                });
                injectHook(type, wrappedHook, target);
                if (target) {
                    var current = target.parent;
                    while(current && current.parent){
                        if (isKeepAlive(current.parent.vnode)) {
                            injectToKeepAliveRoot(wrappedHook, type, target, current);
                        }
                        current = current.parent;
                    }
                }
            }
            function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
                var injected = injectHook(type, hook, keepAliveRoot, true);
                onUnmounted(function() {
                    shared.remove(keepAliveRoot[type], injected);
                }, target);
            }
            function resetShapeFlag(vnode) {
                vnode.shapeFlag &= ~256;
                vnode.shapeFlag &= ~512;
            }
            function getInnerChild(vnode) {
                return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
            }
            function injectHook(type, hook) {
                var target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : currentInstance, prepend = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                if (target) {
                    var hooks = target[type] || (target[type] = []);
                    var wrappedHook = hook.__weh || (hook.__weh = function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                            args[_key] = arguments[_key];
                        }
                        reactivity.pauseTracking();
                        var reset = setCurrentInstance(target);
                        var res = callWithAsyncErrorHandling(hook, target, type, args);
                        reset();
                        reactivity.resetTracking();
                        return res;
                    });
                    if (prepend) {
                        hooks.unshift(wrappedHook);
                    } else {
                        hooks.push(wrappedHook);
                    }
                    return wrappedHook;
                } else {
                    var apiName = shared.toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
                    warn$1("".concat(apiName, " is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement."));
                }
            }
            var createHook = function(lifecycle) {
                return function(hook) {
                    var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentInstance;
                    if (!isInSSRComponentSetup || lifecycle === "sp") {
                        injectHook(lifecycle, function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return hook.apply(void 0, _to_consumable_array(args));
                        }, target);
                    }
                };
            };
            var onBeforeMount = createHook("bm");
            var onMounted = createHook("m");
            var onBeforeUpdate = createHook("bu");
            var onUpdated = createHook("u");
            var onBeforeUnmount = createHook("bum");
            var onUnmounted = createHook("um");
            var onServerPrefetch = createHook("sp");
            var onRenderTriggered = createHook("rtg");
            var onRenderTracked = createHook("rtc");
            function onErrorCaptured(hook) {
                var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : currentInstance;
                injectHook("ec", hook, target);
            }
            var COMPONENTS = "components";
            var DIRECTIVES = "directives";
            function resolveComponent(name, maybeSelfReference) {
                return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
            }
            var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
            function resolveDynamicComponent(component) {
                if (shared.isString(component)) {
                    return resolveAsset(COMPONENTS, component, false) || component;
                } else {
                    return component || NULL_DYNAMIC_COMPONENT;
                }
            }
            function resolveDirective(name) {
                return resolveAsset(DIRECTIVES, name);
            }
            function resolveAsset(type, name) {
                var warnMissing = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, maybeSelfReference = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                var instance = currentRenderingInstance || currentInstance;
                if (instance) {
                    var Component = instance.type;
                    if (type === COMPONENTS) {
                        var selfName = getComponentName(Component, false);
                        if (selfName && (selfName === name || selfName === shared.camelize(name) || selfName === shared.capitalize(shared.camelize(name)))) {
                            return Component;
                        }
                    }
                    var res = // local registration
                    // check instance[type] first which is resolved for options API
                    resolve(instance[type] || Component[type], name) || // global registration
                    resolve(instance.appContext[type], name);
                    if (!res && maybeSelfReference) {
                        return Component;
                    }
                    if (warnMissing && !res) {
                        var extra = type === COMPONENTS ? "\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement." : "";
                        warn$1("Failed to resolve ".concat(type.slice(0, -1), ": ").concat(name).concat(extra));
                    }
                    return res;
                } else {
                    warn$1("resolve".concat(shared.capitalize(type.slice(0, -1)), " can only be used in render() or setup()."));
                }
            }
            function resolve(registry, name) {
                return registry && (registry[name] || registry[shared.camelize(name)] || registry[shared.capitalize(shared.camelize(name))]);
            }
            function renderList(source, renderItem, cache, index) {
                var ret;
                var cached = cache && cache[index];
                var sourceIsArray = shared.isArray(source);
                if (sourceIsArray || shared.isString(source)) {
                    var sourceIsReactiveArray = sourceIsArray && reactivity.isReactive(source);
                    var needsWrap = false;
                    if (sourceIsReactiveArray) {
                        needsWrap = !reactivity.isShallow(source);
                        source = reactivity.shallowReadArray(source);
                    }
                    ret = new Array(source.length);
                    for(var i = 0, l = source.length; i < l; i++){
                        ret[i] = renderItem(needsWrap ? reactivity.toReactive(source[i]) : source[i], i, void 0, cached && cached[i]);
                    }
                } else if (typeof source === "number") {
                    if (!Number.isInteger(source)) {
                        warn$1("The v-for range expect an integer value but got ".concat(source, "."));
                    }
                    ret = new Array(source);
                    for(var i1 = 0; i1 < source; i1++){
                        ret[i1] = renderItem(i1 + 1, i1, void 0, cached && cached[i1]);
                    }
                } else if (shared.isObject(source)) {
                    if (source[Symbol.iterator]) {
                        ret = Array.from(source, function(item, i) {
                            return renderItem(item, i, void 0, cached && cached[i]);
                        });
                    } else {
                        var keys = Object.keys(source);
                        ret = new Array(keys.length);
                        for(var i2 = 0, l1 = keys.length; i2 < l1; i2++){
                            var key = keys[i2];
                            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
                        }
                    }
                } else {
                    ret = [];
                }
                if (cache) {
                    cache[index] = ret;
                }
                return ret;
            }
            function createSlots(slots, dynamicSlots) {
                var _loop = function(i) {
                    var slot = dynamicSlots[i];
                    if (shared.isArray(slot)) {
                        for(var j = 0; j < slot.length; j++){
                            slots[slot[j].name] = slot[j].fn;
                        }
                    } else if (slot) {
                        slots[slot.name] = slot.key ? function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            var _slot;
                            var res = (_slot = slot).fn.apply(_slot, _to_consumable_array(args));
                            if (res) res.key = slot.key;
                            return res;
                        } : slot.fn;
                    }
                };
                for(var i = 0; i < dynamicSlots.length; i++)_loop(i);
                return slots;
            }
            function renderSlot(slots, name) {
                var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, fallback = arguments.length > 3 ? arguments[3] : void 0, noSlotted = arguments.length > 4 ? arguments[4] : void 0;
                if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
                    if (name !== "default") props.name = name;
                    return openBlock(), createBlock(Fragment, null, [
                        createVNode("slot", props, fallback && fallback())
                    ], 64);
                }
                var slot = slots[name];
                if (slot && slot.length > 1) {
                    warn$1("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.");
                    slot = function() {
                        return [];
                    };
                }
                if (slot && slot._c) {
                    slot._d = false;
                }
                openBlock();
                var validSlotContent = slot && ensureValidVNode(slot(props));
                var slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
                // key attached in the `createSlots` helper, respect that
                validSlotContent && validSlotContent.key;
                var rendered = createBlock(Fragment, {
                    key: (slotKey && !shared.isSymbol(slotKey) ? slotKey : "_".concat(name)) + // #7256 force differentiate fallback content from actual content
                    (!validSlotContent && fallback ? "_fb" : "")
                }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
                if (!noSlotted && rendered.scopeId) {
                    rendered.slotScopeIds = [
                        rendered.scopeId + "-s"
                    ];
                }
                if (slot && slot._c) {
                    slot._d = true;
                }
                return rendered;
            }
            function ensureValidVNode(vnodes) {
                return vnodes.some(function(child) {
                    if (!isVNode(child)) return true;
                    if (child.type === Comment) return false;
                    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
                    return true;
                }) ? vnodes : null;
            }
            function toHandlers(obj, preserveCaseIfNecessary) {
                var ret = {};
                if (!shared.isObject(obj)) {
                    warn$1("v-on with no argument expects an object value.");
                    return ret;
                }
                for(var key in obj){
                    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? "on:".concat(key) : shared.toHandlerKey(key)] = obj[key];
                }
                return ret;
            }
            var getPublicInstance = function(i) {
                if (!i) return null;
                if (isStatefulComponent(i)) return getComponentPublicInstance(i);
                return getPublicInstance(i.parent);
            };
            var publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
            // due to type annotation
            /* @__PURE__ */ shared.extend(/* @__PURE__ */ Object.create(null), {
                $: function(i) {
                    return i;
                },
                $el: function(i) {
                    return i.vnode.el;
                },
                $data: function(i) {
                    return i.data;
                },
                $props: function(i) {
                    return reactivity.shallowReadonly(i.props);
                },
                $attrs: function(i) {
                    return reactivity.shallowReadonly(i.attrs);
                },
                $slots: function(i) {
                    return reactivity.shallowReadonly(i.slots);
                },
                $refs: function(i) {
                    return reactivity.shallowReadonly(i.refs);
                },
                $parent: function(i) {
                    return getPublicInstance(i.parent);
                },
                $root: function(i) {
                    return getPublicInstance(i.root);
                },
                $host: function(i) {
                    return i.ce;
                },
                $emit: function(i) {
                    return i.emit;
                },
                $options: function(i) {
                    return resolveMergedOptions(i);
                },
                $forceUpdate: function(i) {
                    return i.f || (i.f = function() {
                        queueJob(i.update);
                    });
                },
                $nextTick: function(i) {
                    return i.n || (i.n = nextTick.bind(i.proxy));
                },
                $watch: function(i) {
                    return instanceWatch.bind(i);
                }
            });
            var isReservedPrefix = function(key) {
                return key === "_" || key === "$";
            };
            var hasSetupBinding = function(state, key) {
                return state !== shared.EMPTY_OBJ && !state.__isScriptSetup && shared.hasOwn(state, key);
            };
            var PublicInstanceProxyHandlers = {
                get: function get(param, key) {
                    var instance = param._;
                    if (key === "__v_skip") {
                        return true;
                    }
                    var ctx = instance.ctx, setupState = instance.setupState, data = instance.data, props = instance.props, accessCache = instance.accessCache, type = instance.type, appContext = instance.appContext;
                    if (key === "__isVue") {
                        return true;
                    }
                    var normalizedProps;
                    if (key[0] !== "$") {
                        var n = accessCache[key];
                        if (n !== void 0) {
                            switch(n){
                                case 1:
                                    return setupState[key];
                                case 2:
                                    return data[key];
                                case 4:
                                    return ctx[key];
                                case 3:
                                    return props[key];
                            }
                        } else if (hasSetupBinding(setupState, key)) {
                            accessCache[key] = 1;
                            return setupState[key];
                        } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
                            accessCache[key] = 2;
                            return data[key];
                        } else if (// only cache other properties when instance has declared (thus stable)
                        // props
                        (normalizedProps = instance.propsOptions[0]) && shared.hasOwn(normalizedProps, key)) {
                            accessCache[key] = 3;
                            return props[key];
                        } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
                            accessCache[key] = 4;
                            return ctx[key];
                        } else if (shouldCacheAccess) {
                            accessCache[key] = 0;
                        }
                    }
                    var publicGetter = publicPropertiesMap[key];
                    var cssModule, globalProperties;
                    if (publicGetter) {
                        if (key === "$attrs") {
                            reactivity.track(instance.attrs, "get", "");
                            markAttrsAccessed();
                        } else if (key === "$slots") {
                            reactivity.track(instance, "get", key);
                        }
                        return publicGetter(instance);
                    } else if (// css module (injected by vue-loader)
                    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
                        return cssModule;
                    } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
                        accessCache[key] = 4;
                        return ctx[key];
                    } else if (// global properties
                    globalProperties = appContext.config.globalProperties, shared.hasOwn(globalProperties, key)) {
                        {
                            return globalProperties[key];
                        }
                    } else if (currentRenderingInstance && (!shared.isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
                    // to infinite warning loop
                    key.indexOf("__v") !== 0)) {
                        if (data !== shared.EMPTY_OBJ && isReservedPrefix(key[0]) && shared.hasOwn(data, key)) {
                            warn$1("Property ".concat(JSON.stringify(key), ' must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.'));
                        } else if (instance === currentRenderingInstance) {
                            warn$1("Property ".concat(JSON.stringify(key), " was accessed during render but is not defined on instance."));
                        }
                    }
                },
                set: function set(param, key, value) {
                    var instance = param._;
                    var data = instance.data, setupState = instance.setupState, ctx = instance.ctx;
                    if (hasSetupBinding(setupState, key)) {
                        setupState[key] = value;
                        return true;
                    } else if (setupState.__isScriptSetup && shared.hasOwn(setupState, key)) {
                        warn$1('Cannot mutate <script setup> binding "'.concat(key, '" from Options API.'));
                        return false;
                    } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
                        data[key] = value;
                        return true;
                    } else if (shared.hasOwn(instance.props, key)) {
                        warn$1('Attempting to mutate prop "'.concat(key, '". Props are readonly.'));
                        return false;
                    }
                    if (key[0] === "$" && key.slice(1) in instance) {
                        warn$1('Attempting to mutate public property "'.concat(key, '". Properties starting with $ are reserved and readonly.'));
                        return false;
                    } else {
                        if (key in instance.appContext.config.globalProperties) {
                            Object.defineProperty(ctx, key, {
                                enumerable: true,
                                configurable: true,
                                value: value
                            });
                        } else {
                            ctx[key] = value;
                        }
                    }
                    return true;
                },
                has: function has(param, key) {
                    var _param__ = param._, data = _param__.data, setupState = _param__.setupState, accessCache = _param__.accessCache, ctx = _param__.ctx, appContext = _param__.appContext, propsOptions = _param__.propsOptions;
                    var normalizedProps;
                    return !!accessCache[key] || data !== shared.EMPTY_OBJ && shared.hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key) || shared.hasOwn(ctx, key) || shared.hasOwn(publicPropertiesMap, key) || shared.hasOwn(appContext.config.globalProperties, key);
                },
                defineProperty: function defineProperty(target, key, descriptor) {
                    if (descriptor.get != null) {
                        target._.accessCache[key] = 0;
                    } else if (shared.hasOwn(descriptor, "value")) {
                        this.set(target, key, descriptor.value, null);
                    }
                    return Reflect.defineProperty(target, key, descriptor);
                }
            };
            {
                PublicInstanceProxyHandlers.ownKeys = function(target) {
                    warn$1("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.");
                    return Reflect.ownKeys(target);
                };
            }
            var RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ shared.extend({}, PublicInstanceProxyHandlers, {
                get: function get(target, key) {
                    if (key === Symbol.unscopables) {
                        return;
                    }
                    return PublicInstanceProxyHandlers.get(target, key, target);
                },
                has: function has(_, key) {
                    var has = key[0] !== "_" && !shared.isGloballyAllowed(key);
                    if (!has && PublicInstanceProxyHandlers.has(_, key)) {
                        warn$1("Property ".concat(JSON.stringify(key), " should not start with _ which is a reserved prefix for Vue internals."));
                    }
                    return has;
                }
            });
            function createDevRenderContext(instance) {
                var target = {};
                Object.defineProperty(target, "_", {
                    configurable: true,
                    enumerable: false,
                    get: function() {
                        return instance;
                    }
                });
                Object.keys(publicPropertiesMap).forEach(function(key) {
                    Object.defineProperty(target, key, {
                        configurable: true,
                        enumerable: false,
                        get: function() {
                            return publicPropertiesMap[key](instance);
                        },
                        // intercepted by the proxy so no need for implementation,
                        // but needed to prevent set errors
                        set: shared.NOOP
                    });
                });
                return target;
            }
            function exposePropsOnRenderContext(instance) {
                var ctx = instance.ctx, _instance_propsOptions = _sliced_to_array(instance.propsOptions, 1), propsOptions = _instance_propsOptions[0];
                if (propsOptions) {
                    Object.keys(propsOptions).forEach(function(key) {
                        Object.defineProperty(ctx, key, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                return instance.props[key];
                            },
                            set: shared.NOOP
                        });
                    });
                }
            }
            function exposeSetupStateOnRenderContext(instance) {
                var ctx = instance.ctx, setupState = instance.setupState;
                Object.keys(reactivity.toRaw(setupState)).forEach(function(key) {
                    if (!setupState.__isScriptSetup) {
                        if (isReservedPrefix(key[0])) {
                            warn$1("setup() return property ".concat(JSON.stringify(key), ' should not start with "$" or "_" which are reserved prefixes for Vue internals.'));
                            return;
                        }
                        Object.defineProperty(ctx, key, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                return setupState[key];
                            },
                            set: shared.NOOP
                        });
                    }
                });
            }
            var warnRuntimeUsage = function(method) {
                return warn$1("".concat(method, "() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect."));
            };
            function defineProps() {
                {
                    warnRuntimeUsage("defineProps");
                }
                return null;
            }
            function defineEmits() {
                {
                    warnRuntimeUsage("defineEmits");
                }
                return null;
            }
            function defineExpose(exposed) {
                {
                    warnRuntimeUsage("defineExpose");
                }
            }
            function defineOptions(options) {
                {
                    warnRuntimeUsage("defineOptions");
                }
            }
            function defineSlots() {
                {
                    warnRuntimeUsage("defineSlots");
                }
                return null;
            }
            function defineModel() {
                {
                    warnRuntimeUsage("defineModel");
                }
            }
            function withDefaults(props, defaults) {
                {
                    warnRuntimeUsage("withDefaults");
                }
                return null;
            }
            function useSlots() {
                return getContext().slots;
            }
            function useAttrs() {
                return getContext().attrs;
            }
            function getContext() {
                var i = getCurrentInstance();
                if (!i) {
                    warn$1("useContext() called without active instance.");
                }
                return i.setupContext || (i.setupContext = createSetupContext(i));
            }
            function normalizePropsOrEmits(props) {
                return shared.isArray(props) ? props.reduce(function(normalized, p) {
                    return normalized[p] = null, normalized;
                }, {}) : props;
            }
            function mergeDefaults(raw, defaults) {
                var props = normalizePropsOrEmits(raw);
                for(var key in defaults){
                    if (key.startsWith("__skip")) continue;
                    var opt = props[key];
                    if (opt) {
                        if (shared.isArray(opt) || shared.isFunction(opt)) {
                            opt = props[key] = {
                                type: opt,
                                default: defaults[key]
                            };
                        } else {
                            opt.default = defaults[key];
                        }
                    } else if (opt === null) {
                        opt = props[key] = {
                            default: defaults[key]
                        };
                    } else {
                        warn$1('props default key "'.concat(key, '" has no corresponding declaration.'));
                    }
                    if (opt && defaults["__skip_".concat(key)]) {
                        opt.skipFactory = true;
                    }
                }
                return props;
            }
            function mergeModels(a, b) {
                if (!a || !b) return a || b;
                if (shared.isArray(a) && shared.isArray(b)) return a.concat(b);
                return shared.extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
            }
            function createPropsRestProxy(props, excludedKeys) {
                var _loop = function(key) {
                    if (!excludedKeys.includes(key)) {
                        Object.defineProperty(ret, key, {
                            enumerable: true,
                            get: function() {
                                return props[key];
                            }
                        });
                    }
                };
                var ret = {};
                for(var key in props)_loop(key);
                return ret;
            }
            function withAsyncContext(getAwaitable) {
                var ctx = getCurrentInstance();
                if (!ctx) {
                    warn$1("withAsyncContext called without active current instance. This is likely a bug.");
                }
                var awaitable = getAwaitable();
                unsetCurrentInstance();
                if (shared.isPromise(awaitable)) {
                    awaitable = awaitable.catch(function(e) {
                        setCurrentInstance(ctx);
                        throw e;
                    });
                }
                return [
                    awaitable,
                    function() {
                        return setCurrentInstance(ctx);
                    }
                ];
            }
            function createDuplicateChecker() {
                var cache = /* @__PURE__ */ Object.create(null);
                return function(type, key) {
                    if (cache[key]) {
                        warn$1("".concat(type, ' property "').concat(key, '" is already defined in ').concat(cache[key], "."));
                    } else {
                        cache[key] = type;
                    }
                };
            }
            var shouldCacheAccess = true;
            function applyOptions(instance) {
                var options = resolveMergedOptions(instance);
                var publicThis = instance.proxy;
                var ctx = instance.ctx;
                shouldCacheAccess = false;
                if (options.beforeCreate) {
                    callHook(options.beforeCreate, instance, "bc");
                }
                var // state
                dataOptions = options.data, computedOptions = options.computed, methods = options.methods, watchOptions = options.watch, provideOptions = options.provide, injectOptions = options.inject, // lifecycle
                created = options.created, beforeMount = options.beforeMount, mounted = options.mounted, beforeUpdate = options.beforeUpdate, updated = options.updated, activated = options.activated, deactivated = options.deactivated, beforeDestroy = options.beforeDestroy, beforeUnmount = options.beforeUnmount, destroyed = options.destroyed, unmounted = options.unmounted, render = options.render, renderTracked = options.renderTracked, renderTriggered = options.renderTriggered, errorCaptured = options.errorCaptured, serverPrefetch = options.serverPrefetch, // public API
                expose = options.expose, inheritAttrs = options.inheritAttrs, // assets
                components = options.components, directives = options.directives, filters = options.filters;
                var checkDuplicateProperties = createDuplicateChecker();
                {
                    var _instance_propsOptions = _sliced_to_array(instance.propsOptions, 1), propsOptions = _instance_propsOptions[0];
                    if (propsOptions) {
                        for(var key in propsOptions){
                            checkDuplicateProperties("Props", key);
                        }
                    }
                }
                if (injectOptions) {
                    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
                }
                if (methods) {
                    for(var key1 in methods){
                        var methodHandler = methods[key1];
                        if (shared.isFunction(methodHandler)) {
                            {
                                Object.defineProperty(ctx, key1, {
                                    value: methodHandler.bind(publicThis),
                                    configurable: true,
                                    enumerable: true,
                                    writable: true
                                });
                            }
                            {
                                checkDuplicateProperties("Methods", key1);
                            }
                        } else {
                            warn$1('Method "'.concat(key1, '" has type "').concat(typeof methodHandler === "undefined" ? "undefined" : _type_of(methodHandler), '" in the component definition. Did you reference the function correctly?'));
                        }
                    }
                }
                if (dataOptions) {
                    if (!shared.isFunction(dataOptions)) {
                        warn$1("The data option must be a function. Plain object usage is no longer supported.");
                    }
                    var data = dataOptions.call(publicThis, publicThis);
                    if (shared.isPromise(data)) {
                        warn$1("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.");
                    }
                    if (!shared.isObject(data)) {
                        warn$1("data() should return an object.");
                    } else {
                        instance.data = reactivity.reactive(data);
                        {
                            var _loop = function(key2) {
                                checkDuplicateProperties("Data", key2);
                                if (!isReservedPrefix(key2[0])) {
                                    Object.defineProperty(ctx, key2, {
                                        configurable: true,
                                        enumerable: true,
                                        get: function() {
                                            return data[key2];
                                        },
                                        set: shared.NOOP
                                    });
                                }
                            };
                            for(var key2 in data)_loop(key2);
                        }
                    }
                }
                shouldCacheAccess = true;
                if (computedOptions) {
                    var _loop1 = function(key3) {
                        var opt = computedOptions[key3];
                        var get = shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared.NOOP;
                        if (get === shared.NOOP) {
                            warn$1('Computed property "'.concat(key3, '" has no getter.'));
                        }
                        var set = !shared.isFunction(opt) && shared.isFunction(opt.set) ? opt.set.bind(publicThis) : function() {
                            warn$1('Write operation failed: computed property "'.concat(key3, '" is readonly.'));
                        };
                        var c = computed({
                            get: get,
                            set: set
                        });
                        Object.defineProperty(ctx, key3, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                return c.value;
                            },
                            set: function(v1) {
                                return c.value = v1;
                            }
                        });
                        {
                            checkDuplicateProperties("Computed", key3);
                        }
                    };
                    for(var key3 in computedOptions)_loop1(key3);
                }
                if (watchOptions) {
                    for(var key4 in watchOptions){
                        createWatcher(watchOptions[key4], ctx, publicThis, key4);
                    }
                }
                if (provideOptions) {
                    var provides = shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
                    Reflect.ownKeys(provides).forEach(function(key) {
                        provide(key, provides[key]);
                    });
                }
                if (created) {
                    callHook(created, instance, "c");
                }
                function registerLifecycleHook(register, hook) {
                    if (shared.isArray(hook)) {
                        hook.forEach(function(_hook) {
                            return register(_hook.bind(publicThis));
                        });
                    } else if (hook) {
                        register(hook.bind(publicThis));
                    }
                }
                registerLifecycleHook(onBeforeMount, beforeMount);
                registerLifecycleHook(onMounted, mounted);
                registerLifecycleHook(onBeforeUpdate, beforeUpdate);
                registerLifecycleHook(onUpdated, updated);
                registerLifecycleHook(onActivated, activated);
                registerLifecycleHook(onDeactivated, deactivated);
                registerLifecycleHook(onErrorCaptured, errorCaptured);
                registerLifecycleHook(onRenderTracked, renderTracked);
                registerLifecycleHook(onRenderTriggered, renderTriggered);
                registerLifecycleHook(onBeforeUnmount, beforeUnmount);
                registerLifecycleHook(onUnmounted, unmounted);
                registerLifecycleHook(onServerPrefetch, serverPrefetch);
                if (shared.isArray(expose)) {
                    if (expose.length) {
                        var exposed = instance.exposed || (instance.exposed = {});
                        expose.forEach(function(key) {
                            Object.defineProperty(exposed, key, {
                                get: function() {
                                    return publicThis[key];
                                },
                                set: function(val) {
                                    return publicThis[key] = val;
                                }
                            });
                        });
                    } else if (!instance.exposed) {
                        instance.exposed = {};
                    }
                }
                if (render && instance.render === shared.NOOP) {
                    instance.render = render;
                }
                if (inheritAttrs != null) {
                    instance.inheritAttrs = inheritAttrs;
                }
                if (components) instance.components = components;
                if (directives) instance.directives = directives;
                if (serverPrefetch) {
                    markAsyncBoundary(instance);
                }
            }
            function resolveInjections(injectOptions, ctx) {
                var _loop = function(key) {
                    var opt = injectOptions[key];
                    var injected = void 0;
                    if (shared.isObject(opt)) {
                        if ("default" in opt) {
                            injected = inject(opt.from || key, opt.default, true);
                        } else {
                            injected = inject(opt.from || key);
                        }
                    } else {
                        injected = inject(opt);
                    }
                    if (reactivity.isRef(injected)) {
                        Object.defineProperty(ctx, key, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                return injected.value;
                            },
                            set: function(v1) {
                                return injected.value = v1;
                            }
                        });
                    } else {
                        ctx[key] = injected;
                    }
                    {
                        checkDuplicateProperties("Inject", key);
                    }
                };
                var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : shared.NOOP;
                if (shared.isArray(injectOptions)) {
                    injectOptions = normalizeInject(injectOptions);
                }
                for(var key in injectOptions)_loop(key);
            }
            function callHook(hook, instance, type) {
                callWithAsyncErrorHandling(shared.isArray(hook) ? hook.map(function(h2) {
                    return h2.bind(instance.proxy);
                }) : hook.bind(instance.proxy), instance, type);
            }
            function createWatcher(raw, ctx, publicThis, key) {
                var getter = key.includes(".") ? createPathGetter(publicThis, key) : function() {
                    return publicThis[key];
                };
                if (shared.isString(raw)) {
                    var handler = ctx[raw];
                    if (shared.isFunction(handler)) {
                        {
                            watch(getter, handler);
                        }
                    } else {
                        warn$1('Invalid watch handler specified by key "'.concat(raw, '"'), handler);
                    }
                } else if (shared.isFunction(raw)) {
                    {
                        watch(getter, raw.bind(publicThis));
                    }
                } else if (shared.isObject(raw)) {
                    if (shared.isArray(raw)) {
                        raw.forEach(function(r) {
                            return createWatcher(r, ctx, publicThis, key);
                        });
                    } else {
                        var handler1 = shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
                        if (shared.isFunction(handler1)) {
                            watch(getter, handler1, raw);
                        } else {
                            warn$1('Invalid watch handler specified by key "'.concat(raw.handler, '"'), handler1);
                        }
                    }
                } else {
                    warn$1('Invalid watch option: "'.concat(key, '"'), raw);
                }
            }
            function resolveMergedOptions(instance) {
                var base = instance.type;
                var mixins = base.mixins, extendsOptions = base.extends;
                var _instance_appContext = instance.appContext, globalMixins = _instance_appContext.mixins, cache = _instance_appContext.optionsCache, optionMergeStrategies = _instance_appContext.config.optionMergeStrategies;
                var cached = cache.get(base);
                var resolved;
                if (cached) {
                    resolved = cached;
                } else if (!globalMixins.length && !mixins && !extendsOptions) {
                    {
                        resolved = base;
                    }
                } else {
                    resolved = {};
                    if (globalMixins.length) {
                        globalMixins.forEach(function(m) {
                            return mergeOptions(resolved, m, optionMergeStrategies, true);
                        });
                    }
                    mergeOptions(resolved, base, optionMergeStrategies);
                }
                if (shared.isObject(base)) {
                    cache.set(base, resolved);
                }
                return resolved;
            }
            function mergeOptions(to, from, strats) {
                var asMixin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                var mixins = from.mixins, extendsOptions = from.extends;
                if (extendsOptions) {
                    mergeOptions(to, extendsOptions, strats, true);
                }
                if (mixins) {
                    mixins.forEach(function(m) {
                        return mergeOptions(to, m, strats, true);
                    });
                }
                for(var key in from){
                    if (asMixin && key === "expose") {
                        warn$1('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
                    } else {
                        var strat = internalOptionMergeStrats[key] || strats && strats[key];
                        to[key] = strat ? strat(to[key], from[key]) : from[key];
                    }
                }
                return to;
            }
            var internalOptionMergeStrats = {
                data: mergeDataFn,
                props: mergeEmitsOrPropsOptions,
                emits: mergeEmitsOrPropsOptions,
                // objects
                methods: mergeObjectOptions,
                computed: mergeObjectOptions,
                // lifecycle
                beforeCreate: mergeAsArray,
                created: mergeAsArray,
                beforeMount: mergeAsArray,
                mounted: mergeAsArray,
                beforeUpdate: mergeAsArray,
                updated: mergeAsArray,
                beforeDestroy: mergeAsArray,
                beforeUnmount: mergeAsArray,
                destroyed: mergeAsArray,
                unmounted: mergeAsArray,
                activated: mergeAsArray,
                deactivated: mergeAsArray,
                errorCaptured: mergeAsArray,
                serverPrefetch: mergeAsArray,
                // assets
                components: mergeObjectOptions,
                directives: mergeObjectOptions,
                // watch
                watch: mergeWatchOptions,
                // provide / inject
                provide: mergeDataFn,
                inject: mergeInject
            };
            function mergeDataFn(to, from) {
                if (!from) {
                    return to;
                }
                if (!to) {
                    return from;
                }
                return function mergedDataFn() {
                    return shared.extend(shared.isFunction(to) ? to.call(this, this) : to, shared.isFunction(from) ? from.call(this, this) : from);
                };
            }
            function mergeInject(to, from) {
                return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
            }
            function normalizeInject(raw) {
                if (shared.isArray(raw)) {
                    var res = {};
                    for(var i = 0; i < raw.length; i++){
                        res[raw[i]] = raw[i];
                    }
                    return res;
                }
                return raw;
            }
            function mergeAsArray(to, from) {
                return to ? _to_consumable_array(new Set([].concat(to, from))) : from;
            }
            function mergeObjectOptions(to, from) {
                return to ? shared.extend(/* @__PURE__ */ Object.create(null), to, from) : from;
            }
            function mergeEmitsOrPropsOptions(to, from) {
                if (to) {
                    if (shared.isArray(to) && shared.isArray(from)) {
                        return _to_consumable_array(/* @__PURE__ */ new Set(_to_consumable_array(to).concat(_to_consumable_array(from))));
                    }
                    return shared.extend(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
                } else {
                    return from;
                }
            }
            function mergeWatchOptions(to, from) {
                if (!to) return from;
                if (!from) return to;
                var merged = shared.extend(/* @__PURE__ */ Object.create(null), to);
                for(var key in from){
                    merged[key] = mergeAsArray(to[key], from[key]);
                }
                return merged;
            }
            function createAppContext() {
                return {
                    app: null,
                    config: {
                        isNativeTag: shared.NO,
                        performance: false,
                        globalProperties: {},
                        optionMergeStrategies: {},
                        errorHandler: void 0,
                        warnHandler: void 0,
                        compilerOptions: {}
                    },
                    mixins: [],
                    components: {},
                    directives: {},
                    provides: /* @__PURE__ */ Object.create(null),
                    optionsCache: /* @__PURE__ */ new WeakMap(),
                    propsCache: /* @__PURE__ */ new WeakMap(),
                    emitsCache: /* @__PURE__ */ new WeakMap()
                };
            }
            var uid$1 = 0;
            function createAppAPI(render, hydrate) {
                return function createApp(rootComponent) {
                    var rootProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    if (!shared.isFunction(rootComponent)) {
                        rootComponent = shared.extend({}, rootComponent);
                    }
                    if (rootProps != null && !shared.isObject(rootProps)) {
                        warn$1("root props passed to app.mount() must be an object.");
                        rootProps = null;
                    }
                    var context = createAppContext();
                    var installedPlugins = /* @__PURE__ */ new WeakSet();
                    var pluginCleanupFns = [];
                    var isMounted = false;
                    var app = context.app = {
                        _uid: uid$1++,
                        _component: rootComponent,
                        _props: rootProps,
                        _container: null,
                        _context: context,
                        _instance: null,
                        version: version,
                        get config () {
                            return context.config;
                        },
                        set config (v){
                            {
                                warn$1("app.config cannot be replaced. Modify individual options instead.");
                            }
                        },
                        use: function use(plugin) {
                            for(var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                options[_key - 1] = arguments[_key];
                            }
                            if (installedPlugins.has(plugin)) {
                                warn$1("Plugin has already been applied to target app.");
                            } else if (plugin && shared.isFunction(plugin.install)) {
                                var _plugin;
                                installedPlugins.add(plugin);
                                (_plugin = plugin).install.apply(_plugin, [
                                    app
                                ].concat(_to_consumable_array(options)));
                            } else if (shared.isFunction(plugin)) {
                                installedPlugins.add(plugin);
                                plugin.apply(void 0, [
                                    app
                                ].concat(_to_consumable_array(options)));
                            } else {
                                warn$1('A plugin must either be a function or an object with an "install" function.');
                            }
                            return app;
                        },
                        mixin: function mixin(mixin) {
                            {
                                if (!context.mixins.includes(mixin)) {
                                    context.mixins.push(mixin);
                                } else {
                                    warn$1("Mixin has already been applied to target app" + (mixin.name ? ": ".concat(mixin.name) : ""));
                                }
                            }
                            return app;
                        },
                        component: function component(name, component) {
                            {
                                validateComponentName(name, context.config);
                            }
                            if (!component) {
                                return context.components[name];
                            }
                            if (context.components[name]) {
                                warn$1('Component "'.concat(name, '" has already been registered in target app.'));
                            }
                            context.components[name] = component;
                            return app;
                        },
                        directive: function directive(name, directive) {
                            {
                                validateDirectiveName(name);
                            }
                            if (!directive) {
                                return context.directives[name];
                            }
                            if (context.directives[name]) {
                                warn$1('Directive "'.concat(name, '" has already been registered in target app.'));
                            }
                            context.directives[name] = directive;
                            return app;
                        },
                        mount: function mount(rootContainer, isHydrate, namespace) {
                            if (!isMounted) {
                                if (rootContainer.__vue_app__) {
                                    warn$1("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
                                }
                                var vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                                vnode.appContext = context;
                                if (namespace === true) {
                                    namespace = "svg";
                                } else if (namespace === false) {
                                    namespace = void 0;
                                }
                                {
                                    context.reload = function() {
                                        render(cloneVNode(vnode), rootContainer, namespace);
                                    };
                                }
                                if (isHydrate && hydrate) {
                                    hydrate(vnode, rootContainer);
                                } else {
                                    render(vnode, rootContainer, namespace);
                                }
                                isMounted = true;
                                app._container = rootContainer;
                                rootContainer.__vue_app__ = app;
                                {
                                    app._instance = vnode.component;
                                    devtoolsInitApp(app, version);
                                }
                                return getComponentPublicInstance(vnode.component);
                            } else {
                                warn$1("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
                            }
                        },
                        onUnmount: function onUnmount(cleanupFn) {
                            if (typeof cleanupFn !== "function") {
                                warn$1("Expected function as first argument to app.onUnmount(), but got ".concat(typeof cleanupFn === "undefined" ? "undefined" : _type_of(cleanupFn)));
                            }
                            pluginCleanupFns.push(cleanupFn);
                        },
                        unmount: function unmount() {
                            if (isMounted) {
                                callWithAsyncErrorHandling(pluginCleanupFns, app._instance, 16);
                                render(null, app._container);
                                {
                                    app._instance = null;
                                    devtoolsUnmountApp(app);
                                }
                                delete app._container.__vue_app__;
                            } else {
                                warn$1("Cannot unmount an app that is not mounted.");
                            }
                        },
                        provide: function provide(key, value) {
                            if (key in context.provides) {
                                warn$1('App already provides property with key "'.concat(String(key), '". It will be overwritten with the new value.'));
                            }
                            context.provides[key] = value;
                            return app;
                        },
                        runWithContext: function runWithContext(fn) {
                            var lastApp = currentApp;
                            currentApp = app;
                            try {
                                return fn();
                            } finally{
                                currentApp = lastApp;
                            }
                        }
                    };
                    return app;
                };
            }
            var currentApp = null;
            function provide(key, value) {
                if (!currentInstance) {
                    {
                        warn$1("provide() can only be used inside setup().");
                    }
                } else {
                    var provides = currentInstance.provides;
                    var parentProvides = currentInstance.parent && currentInstance.parent.provides;
                    if (parentProvides === provides) {
                        provides = currentInstance.provides = Object.create(parentProvides);
                    }
                    provides[key] = value;
                }
            }
            function inject(key, defaultValue) {
                var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var instance = currentInstance || currentRenderingInstance;
                if (instance || currentApp) {
                    var provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
                    if (provides && key in provides) {
                        return provides[key];
                    } else if (arguments.length > 1) {
                        return treatDefaultAsFactory && shared.isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
                    } else {
                        warn$1('injection "'.concat(String(key), '" not found.'));
                    }
                } else {
                    warn$1("inject() can only be used inside setup() or functional components.");
                }
            }
            function hasInjectionContext() {
                return !!(currentInstance || currentRenderingInstance || currentApp);
            }
            var internalObjectProto = {};
            var createInternalObject = function() {
                return Object.create(internalObjectProto);
            };
            var isInternalObject = function(obj) {
                return Object.getPrototypeOf(obj) === internalObjectProto;
            };
            function initProps(instance, rawProps, isStateful) {
                var isSSR = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                var props = {};
                var attrs = createInternalObject();
                instance.propsDefaults = /* @__PURE__ */ Object.create(null);
                setFullProps(instance, rawProps, props, attrs);
                for(var key in instance.propsOptions[0]){
                    if (!(key in props)) {
                        props[key] = void 0;
                    }
                }
                {
                    validateProps(rawProps || {}, props, instance);
                }
                if (isStateful) {
                    instance.props = isSSR ? props : reactivity.shallowReactive(props);
                } else {
                    if (!instance.type.props) {
                        instance.props = attrs;
                    } else {
                        instance.props = props;
                    }
                }
                instance.attrs = attrs;
            }
            function isInHmrContext(instance) {
                while(instance){
                    if (instance.type.__hmrId) return true;
                    instance = instance.parent;
                }
            }
            function updateProps(instance, rawProps, rawPrevProps, optimized) {
                var props = instance.props, attrs = instance.attrs, patchFlag = instance.vnode.patchFlag;
                var rawCurrentProps = reactivity.toRaw(props);
                var _instance_propsOptions = _sliced_to_array(instance.propsOptions, 1), options = _instance_propsOptions[0];
                var hasAttrsChanged = false;
                if (// always force full diff in dev
                // - #1942 if hmr is enabled with sfc component
                // - vite#872 non-sfc component used by sfc component
                !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
                    if (patchFlag & 8) {
                        var propsToUpdate = instance.vnode.dynamicProps;
                        for(var i = 0; i < propsToUpdate.length; i++){
                            var key = propsToUpdate[i];
                            if (isEmitListener(instance.emitsOptions, key)) {
                                continue;
                            }
                            var value = rawProps[key];
                            if (options) {
                                if (shared.hasOwn(attrs, key)) {
                                    if (value !== attrs[key]) {
                                        attrs[key] = value;
                                        hasAttrsChanged = true;
                                    }
                                } else {
                                    var camelizedKey = shared.camelize(key);
                                    props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                                }
                            } else {
                                if (value !== attrs[key]) {
                                    attrs[key] = value;
                                    hasAttrsChanged = true;
                                }
                            }
                        }
                    }
                } else {
                    if (setFullProps(instance, rawProps, props, attrs)) {
                        hasAttrsChanged = true;
                    }
                    var kebabKey;
                    for(var key1 in rawCurrentProps){
                        if (!rawProps || // for camelCase
                        !shared.hasOwn(rawProps, key1) && // it's possible the original props was passed in as kebab-case
                        // and converted to camelCase (#955)
                        ((kebabKey = shared.hyphenate(key1)) === key1 || !shared.hasOwn(rawProps, kebabKey))) {
                            if (options) {
                                if (rawPrevProps && // for camelCase
                                (rawPrevProps[key1] !== void 0 || // for kebab-case
                                rawPrevProps[kebabKey] !== void 0)) {
                                    props[key1] = resolvePropValue(options, rawCurrentProps, key1, void 0, instance, true);
                                }
                            } else {
                                delete props[key1];
                            }
                        }
                    }
                    if (attrs !== rawCurrentProps) {
                        for(var key2 in attrs){
                            if (!rawProps || !shared.hasOwn(rawProps, key2) && true) {
                                delete attrs[key2];
                                hasAttrsChanged = true;
                            }
                        }
                    }
                }
                if (hasAttrsChanged) {
                    reactivity.trigger(instance.attrs, "set", "");
                }
                {
                    validateProps(rawProps || {}, props, instance);
                }
            }
            function setFullProps(instance, rawProps, props, attrs) {
                var _instance_propsOptions = _sliced_to_array(instance.propsOptions, 2), options = _instance_propsOptions[0], needCastKeys = _instance_propsOptions[1];
                var hasAttrsChanged = false;
                var rawCastValues;
                if (rawProps) {
                    for(var key in rawProps){
                        if (shared.isReservedProp(key)) {
                            continue;
                        }
                        var value = rawProps[key];
                        var camelKey = void 0;
                        if (options && shared.hasOwn(options, camelKey = shared.camelize(key))) {
                            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                                props[camelKey] = value;
                            } else {
                                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                            }
                        } else if (!isEmitListener(instance.emitsOptions, key)) {
                            if (!(key in attrs) || value !== attrs[key]) {
                                attrs[key] = value;
                                hasAttrsChanged = true;
                            }
                        }
                    }
                }
                if (needCastKeys) {
                    var rawCurrentProps = reactivity.toRaw(props);
                    var castValues = rawCastValues || shared.EMPTY_OBJ;
                    for(var i = 0; i < needCastKeys.length; i++){
                        var key1 = needCastKeys[i];
                        props[key1] = resolvePropValue(options, rawCurrentProps, key1, castValues[key1], instance, !shared.hasOwn(castValues, key1));
                    }
                }
                return hasAttrsChanged;
            }
            function resolvePropValue(options, props, key, value, instance, isAbsent) {
                var opt = options[key];
                if (opt != null) {
                    var hasDefault = shared.hasOwn(opt, "default");
                    if (hasDefault && value === void 0) {
                        var defaultValue = opt.default;
                        if (opt.type !== Function && !opt.skipFactory && shared.isFunction(defaultValue)) {
                            var propsDefaults = instance.propsDefaults;
                            if (key in propsDefaults) {
                                value = propsDefaults[key];
                            } else {
                                var reset = setCurrentInstance(instance);
                                value = propsDefaults[key] = defaultValue.call(null, props);
                                reset();
                            }
                        } else {
                            value = defaultValue;
                        }
                        if (instance.ce) {
                            instance.ce._setProp(key, value);
                        }
                    }
                    if (opt[0]) {
                        if (isAbsent && !hasDefault) {
                            value = false;
                        } else if (opt[1] && (value === "" || value === shared.hyphenate(key))) {
                            value = true;
                        }
                    }
                }
                return value;
            }
            var mixinPropsCache = /* @__PURE__ */ new WeakMap();
            function normalizePropsOptions(comp, appContext) {
                var asMixin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var cache = asMixin ? mixinPropsCache : appContext.propsCache;
                var cached = cache.get(comp);
                if (cached) {
                    return cached;
                }
                var raw = comp.props;
                var normalized = {};
                var needCastKeys = [];
                var hasExtends = false;
                if (!shared.isFunction(comp)) {
                    var extendProps = function(raw2) {
                        var _needCastKeys;
                        hasExtends = true;
                        var _normalizePropsOptions = _sliced_to_array(normalizePropsOptions(raw2, appContext, true), 2), props = _normalizePropsOptions[0], keys = _normalizePropsOptions[1];
                        shared.extend(normalized, props);
                        if (keys) (_needCastKeys = needCastKeys).push.apply(_needCastKeys, _to_consumable_array(keys));
                    };
                    if (!asMixin && appContext.mixins.length) {
                        appContext.mixins.forEach(extendProps);
                    }
                    if (comp.extends) {
                        extendProps(comp.extends);
                    }
                    if (comp.mixins) {
                        comp.mixins.forEach(extendProps);
                    }
                }
                if (!raw && !hasExtends) {
                    if (shared.isObject(comp)) {
                        cache.set(comp, shared.EMPTY_ARR);
                    }
                    return shared.EMPTY_ARR;
                }
                if (shared.isArray(raw)) {
                    for(var i = 0; i < raw.length; i++){
                        if (!shared.isString(raw[i])) {
                            warn$1("props must be strings when using array syntax.", raw[i]);
                        }
                        var normalizedKey = shared.camelize(raw[i]);
                        if (validatePropName(normalizedKey)) {
                            normalized[normalizedKey] = shared.EMPTY_OBJ;
                        }
                    }
                } else if (raw) {
                    if (!shared.isObject(raw)) {
                        warn$1("invalid props options", raw);
                    }
                    for(var key in raw){
                        var normalizedKey1 = shared.camelize(key);
                        if (validatePropName(normalizedKey1)) {
                            var opt = raw[key];
                            var prop = normalized[normalizedKey1] = shared.isArray(opt) || shared.isFunction(opt) ? {
                                type: opt
                            } : shared.extend({}, opt);
                            var propType = prop.type;
                            var shouldCast = false;
                            var shouldCastTrue = true;
                            if (shared.isArray(propType)) {
                                for(var index = 0; index < propType.length; ++index){
                                    var type = propType[index];
                                    var typeName = shared.isFunction(type) && type.name;
                                    if (typeName === "Boolean") {
                                        shouldCast = true;
                                        break;
                                    } else if (typeName === "String") {
                                        shouldCastTrue = false;
                                    }
                                }
                            } else {
                                shouldCast = shared.isFunction(propType) && propType.name === "Boolean";
                            }
                            prop[0] = shouldCast;
                            prop[1] = shouldCastTrue;
                            if (shouldCast || shared.hasOwn(prop, "default")) {
                                needCastKeys.push(normalizedKey1);
                            }
                        }
                    }
                }
                var res = [
                    normalized,
                    needCastKeys
                ];
                if (shared.isObject(comp)) {
                    cache.set(comp, res);
                }
                return res;
            }
            function validatePropName(key) {
                if (key[0] !== "$" && !shared.isReservedProp(key)) {
                    return true;
                } else {
                    warn$1('Invalid prop name: "'.concat(key, '" is a reserved property.'));
                }
                return false;
            }
            function getType(ctor) {
                if (ctor === null) {
                    return "null";
                }
                if (typeof ctor === "function") {
                    return ctor.name || "";
                } else if ((typeof ctor === "undefined" ? "undefined" : _type_of(ctor)) === "object") {
                    var name = ctor.constructor && ctor.constructor.name;
                    return name || "";
                }
                return "";
            }
            function validateProps(rawProps, props, instance) {
                var resolvedValues = reactivity.toRaw(props);
                var options = instance.propsOptions[0];
                var camelizePropsKey = Object.keys(rawProps).map(function(key) {
                    return shared.camelize(key);
                });
                for(var key in options){
                    var opt = options[key];
                    if (opt == null) continue;
                    validateProp(key, resolvedValues[key], opt, reactivity.shallowReadonly(resolvedValues), !camelizePropsKey.includes(key));
                }
            }
            function validateProp(name, value, prop, props, isAbsent) {
                var type = prop.type, required = prop.required, validator = prop.validator, skipCheck = prop.skipCheck;
                if (required && isAbsent) {
                    warn$1('Missing required prop: "' + name + '"');
                    return;
                }
                if (value == null && !required) {
                    return;
                }
                if (type != null && type !== true && !skipCheck) {
                    var isValid = false;
                    var types = shared.isArray(type) ? type : [
                        type
                    ];
                    var expectedTypes = [];
                    for(var i = 0; i < types.length && !isValid; i++){
                        var _assertType = assertType(value, types[i]), valid = _assertType.valid, expectedType = _assertType.expectedType;
                        expectedTypes.push(expectedType || "");
                        isValid = valid;
                    }
                    if (!isValid) {
                        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
                        return;
                    }
                }
                if (validator && !validator(value, props)) {
                    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
                }
            }
            var isSimpleType = /* @__PURE__ */ shared.makeMap("String,Number,Boolean,Function,Symbol,BigInt");
            function assertType(value, type) {
                var valid;
                var expectedType = getType(type);
                if (expectedType === "null") {
                    valid = value === null;
                } else if (isSimpleType(expectedType)) {
                    var t = typeof value === "undefined" ? "undefined" : _type_of(value);
                    valid = t === expectedType.toLowerCase();
                    if (!valid && t === "object") {
                        valid = _instanceof(value, type);
                    }
                } else if (expectedType === "Object") {
                    valid = shared.isObject(value);
                } else if (expectedType === "Array") {
                    valid = shared.isArray(value);
                } else {
                    valid = _instanceof(value, type);
                }
                return {
                    valid: valid,
                    expectedType: expectedType
                };
            }
            function getInvalidTypeMessage(name, value, expectedTypes) {
                if (expectedTypes.length === 0) {
                    return 'Prop type [] for prop "'.concat(name, "\" won't match anything. Did you mean to use type Array instead?");
                }
                var message = 'Invalid prop: type check failed for prop "'.concat(name, '". Expected ').concat(expectedTypes.map(shared.capitalize).join(" | "));
                var expectedType = expectedTypes[0];
                var receivedType = shared.toRawType(value);
                var expectedValue = styleValue(value, expectedType);
                var receivedValue = styleValue(value, receivedType);
                if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
                    message += " with value ".concat(expectedValue);
                }
                message += ", got ".concat(receivedType, " ");
                if (isExplicable(receivedType)) {
                    message += "with value ".concat(receivedValue, ".");
                }
                return message;
            }
            function styleValue(value, type) {
                if (type === "String") {
                    return '"'.concat(value, '"');
                } else if (type === "Number") {
                    return "".concat(Number(value));
                } else {
                    return "".concat(value);
                }
            }
            function isExplicable(type) {
                var explicitTypes = [
                    "string",
                    "number",
                    "boolean"
                ];
                return explicitTypes.some(function(elem) {
                    return type.toLowerCase() === elem;
                });
            }
            function isBoolean() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return args.some(function(elem) {
                    return elem.toLowerCase() === "boolean";
                });
            }
            var isInternalKey = function(key) {
                return key[0] === "_" || key === "$stable";
            };
            var normalizeSlotValue = function(value) {
                return shared.isArray(value) ? value.map(normalizeVNode) : [
                    normalizeVNode(value)
                ];
            };
            var normalizeSlot = function(key, rawSlot, ctx) {
                if (rawSlot._n) {
                    return rawSlot;
                }
                var normalized = withCtx(function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
                        warn$1('Slot "'.concat(key, '" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.'));
                    }
                    return normalizeSlotValue(rawSlot.apply(void 0, _to_consumable_array(args)));
                }, ctx);
                normalized._c = false;
                return normalized;
            };
            var normalizeObjectSlots = function(rawSlots, slots, instance) {
                var _loop = function(key) {
                    if (isInternalKey(key)) return "continue";
                    var value = rawSlots[key];
                    if (shared.isFunction(value)) {
                        slots[key] = normalizeSlot(key, value, ctx);
                    } else if (value != null) {
                        {
                            warn$1('Non-function value encountered for slot "'.concat(key, '". Prefer function slots for better performance.'));
                        }
                        var normalized = normalizeSlotValue(value);
                        slots[key] = function() {
                            return normalized;
                        };
                    }
                };
                var ctx = rawSlots._ctx;
                for(var key in rawSlots)_loop(key);
            };
            var normalizeVNodeSlots = function(instance, children) {
                if (!isKeepAlive(instance.vnode) && true) {
                    warn$1("Non-function value encountered for default slot. Prefer function slots for better performance.");
                }
                var normalized = normalizeSlotValue(children);
                instance.slots.default = function() {
                    return normalized;
                };
            };
            var assignSlots = function(slots, children, optimized) {
                for(var key in children){
                    if (optimized || key !== "_") {
                        slots[key] = children[key];
                    }
                }
            };
            var initSlots = function(instance, children, optimized) {
                var slots = instance.slots = createInternalObject();
                if (instance.vnode.shapeFlag & 32) {
                    var type = children._;
                    if (type) {
                        assignSlots(slots, children, optimized);
                        if (optimized) {
                            shared.def(slots, "_", type, true);
                        }
                    } else {
                        normalizeObjectSlots(children, slots);
                    }
                } else if (children) {
                    normalizeVNodeSlots(instance, children);
                }
            };
            var updateSlots = function(instance, children, optimized) {
                var vnode = instance.vnode, slots = instance.slots;
                var needDeletionCheck = true;
                var deletionComparisonTarget = shared.EMPTY_OBJ;
                if (vnode.shapeFlag & 32) {
                    var type = children._;
                    if (type) {
                        if (isHmrUpdating) {
                            assignSlots(slots, children, optimized);
                            reactivity.trigger(instance, "set", "$slots");
                        } else if (optimized && type === 1) {
                            needDeletionCheck = false;
                        } else {
                            assignSlots(slots, children, optimized);
                        }
                    } else {
                        needDeletionCheck = !children.$stable;
                        normalizeObjectSlots(children, slots);
                    }
                    deletionComparisonTarget = children;
                } else if (children) {
                    normalizeVNodeSlots(instance, children);
                    deletionComparisonTarget = {
                        default: 1
                    };
                }
                if (needDeletionCheck) {
                    for(var key in slots){
                        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
                            delete slots[key];
                        }
                    }
                }
            };
            var supported;
            var perf;
            function startMeasure(instance, type) {
                if (instance.appContext.config.performance && isSupported()) {
                    perf.mark("vue-".concat(type, "-").concat(instance.uid));
                }
                {
                    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
                }
            }
            function endMeasure(instance, type) {
                if (instance.appContext.config.performance && isSupported()) {
                    var startTag = "vue-".concat(type, "-").concat(instance.uid);
                    var endTag = startTag + ":end";
                    perf.mark(endTag);
                    perf.measure("<".concat(formatComponentName(instance, instance.type), "> ").concat(type), startTag, endTag);
                    perf.clearMarks(startTag);
                    perf.clearMarks(endTag);
                }
                {
                    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
                }
            }
            function isSupported() {
                if (supported !== void 0) {
                    return supported;
                }
                if (typeof window !== "undefined" && window.performance) {
                    supported = true;
                    perf = window.performance;
                } else {
                    supported = false;
                }
                return supported;
            }
            var queuePostRenderEffect = queueEffectWithSuspense;
            function createRenderer(options) {
                return baseCreateRenderer(options);
            }
            function createHydrationRenderer(options) {
                return baseCreateRenderer(options, createHydrationFunctions);
            }
            function baseCreateRenderer(options, createHydrationFns) {
                var target = shared.getGlobalThis();
                target.__VUE__ = true;
                {
                    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
                }
                var hostInsert = options.insert, hostRemove = options.remove, hostPatchProp = options.patchProp, hostCreateElement = options.createElement, hostCreateText = options.createText, hostCreateComment = options.createComment, hostSetText = options.setText, hostSetElementText = options.setElementText, hostParentNode = options.parentNode, hostNextSibling = options.nextSibling, tmp = options.setScopeId, hostSetScopeId = tmp === void 0 ? shared.NOOP : tmp, hostInsertStaticContent = options.insertStaticContent;
                var patch = function(n1, n2, container) {
                    var anchor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, parentComponent = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, parentSuspense = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, namespace = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0, slotScopeIds = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, optimized = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : isHmrUpdating ? false : !!n2.dynamicChildren;
                    if (n1 === n2) {
                        return;
                    }
                    if (n1 && !isSameVNodeType(n1, n2)) {
                        anchor = getNextHostNode(n1);
                        unmount(n1, parentComponent, parentSuspense, true);
                        n1 = null;
                    }
                    if (n2.patchFlag === -2) {
                        optimized = false;
                        n2.dynamicChildren = null;
                    }
                    var type = n2.type, ref = n2.ref, shapeFlag = n2.shapeFlag;
                    switch(type){
                        case Text:
                            processText(n1, n2, container, anchor);
                            break;
                        case Comment:
                            processCommentNode(n1, n2, container, anchor);
                            break;
                        case Static:
                            if (n1 == null) {
                                mountStaticNode(n2, container, anchor, namespace);
                            } else {
                                patchStaticNode(n1, n2, container, namespace);
                            }
                            break;
                        case Fragment:
                            processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            break;
                        default:
                            if (shapeFlag & 1) {
                                processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            } else if (shapeFlag & 6) {
                                processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            } else if (shapeFlag & 64) {
                                type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                            } else if (shapeFlag & 128) {
                                type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                            } else {
                                warn$1("Invalid VNode type:", type, "(".concat(typeof type === "undefined" ? "undefined" : _type_of(type), ")"));
                            }
                    }
                    if (ref != null && parentComponent) {
                        setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
                    }
                };
                var processText = function(n1, n2, container, anchor) {
                    if (n1 == null) {
                        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
                    } else {
                        var el = n2.el = n1.el;
                        if (n2.children !== n1.children) {
                            hostSetText(el, n2.children);
                        }
                    }
                };
                var processCommentNode = function(n1, n2, container, anchor) {
                    if (n1 == null) {
                        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
                    } else {
                        n2.el = n1.el;
                    }
                };
                var mountStaticNode = function(n2, container, anchor, namespace) {
                    var ref;
                    ref = _sliced_to_array(hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor), 2), n2.el = ref[0], n2.anchor = ref[1], ref;
                };
                var patchStaticNode = function(n1, n2, container, namespace) {
                    if (n2.children !== n1.children) {
                        var anchor = hostNextSibling(n1.anchor);
                        removeStaticNode(n1);
                        var ref;
                        ref = _sliced_to_array(hostInsertStaticContent(n2.children, container, anchor, namespace), 2), n2.el = ref[0], n2.anchor = ref[1], ref;
                    } else {
                        n2.el = n1.el;
                        n2.anchor = n1.anchor;
                    }
                };
                var moveStaticNode = function(param, container, nextSibling) {
                    var el = param.el, anchor = param.anchor;
                    var next;
                    while(el && el !== anchor){
                        next = hostNextSibling(el);
                        hostInsert(el, container, nextSibling);
                        el = next;
                    }
                    hostInsert(anchor, container, nextSibling);
                };
                var removeStaticNode = function(param) {
                    var el = param.el, anchor = param.anchor;
                    var next;
                    while(el && el !== anchor){
                        next = hostNextSibling(el);
                        hostRemove(el);
                        el = next;
                    }
                    hostRemove(anchor);
                };
                var processElement = function(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    if (n2.type === "svg") {
                        namespace = "svg";
                    } else if (n2.type === "math") {
                        namespace = "mathml";
                    }
                    if (n1 == null) {
                        mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    } else {
                        patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    }
                };
                var mountElement = function(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    var el;
                    var vnodeHook;
                    var props = vnode.props, shapeFlag = vnode.shapeFlag, transition = vnode.transition, dirs = vnode.dirs;
                    el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);
                    if (shapeFlag & 8) {
                        hostSetElementText(el, vnode.children);
                    } else if (shapeFlag & 16) {
                        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);
                    }
                    if (dirs) {
                        invokeDirectiveHook(vnode, null, parentComponent, "created");
                    }
                    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
                    if (props) {
                        for(var key in props){
                            if (key !== "value" && !shared.isReservedProp(key)) {
                                hostPatchProp(el, key, null, props[key], namespace, parentComponent);
                            }
                        }
                        if ("value" in props) {
                            hostPatchProp(el, "value", null, props.value, namespace);
                        }
                        if (vnodeHook = props.onVnodeBeforeMount) {
                            invokeVNodeHook(vnodeHook, parentComponent, vnode);
                        }
                    }
                    {
                        shared.def(el, "__vnode", vnode, true);
                        shared.def(el, "__vueParentComponent", parentComponent, true);
                    }
                    if (dirs) {
                        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
                    }
                    var needCallTransitionHooks = needTransition(parentSuspense, transition);
                    if (needCallTransitionHooks) {
                        transition.beforeEnter(el);
                    }
                    hostInsert(el, container, anchor);
                    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
                        queuePostRenderEffect(function() {
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                            needCallTransitionHooks && transition.enter(el);
                            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                        }, parentSuspense);
                    }
                };
                var setScopeId = function(el, vnode, scopeId, slotScopeIds, parentComponent) {
                    if (scopeId) {
                        hostSetScopeId(el, scopeId);
                    }
                    if (slotScopeIds) {
                        for(var i = 0; i < slotScopeIds.length; i++){
                            hostSetScopeId(el, slotScopeIds[i]);
                        }
                    }
                    if (parentComponent) {
                        var subTree = parentComponent.subTree;
                        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
                            subTree = filterSingleRoot(subTree.children) || subTree;
                        }
                        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
                            var parentVNode = parentComponent.vnode;
                            setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
                        }
                    }
                };
                var mountChildren = function(children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    var start = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0;
                    for(var i = start; i < children.length; i++){
                        var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
                        patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    }
                };
                var patchElement = function(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    var el = n2.el = n1.el;
                    {
                        el.__vnode = n2;
                    }
                    var patchFlag = n2.patchFlag, dynamicChildren = n2.dynamicChildren, dirs = n2.dirs;
                    patchFlag |= n1.patchFlag & 16;
                    var oldProps = n1.props || shared.EMPTY_OBJ;
                    var newProps = n2.props || shared.EMPTY_OBJ;
                    var vnodeHook;
                    parentComponent && toggleRecurse(parentComponent, false);
                    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
                        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                    }
                    if (dirs) {
                        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
                    }
                    parentComponent && toggleRecurse(parentComponent, true);
                    if (isHmrUpdating) {
                        patchFlag = 0;
                        optimized = false;
                        dynamicChildren = null;
                    }
                    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
                        hostSetElementText(el, "");
                    }
                    if (dynamicChildren) {
                        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);
                        {
                            traverseStaticChildren(n1, n2);
                        }
                    } else if (!optimized) {
                        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);
                    }
                    if (patchFlag > 0) {
                        if (patchFlag & 16) {
                            patchProps(el, oldProps, newProps, parentComponent, namespace);
                        } else {
                            if (patchFlag & 2) {
                                if (oldProps.class !== newProps.class) {
                                    hostPatchProp(el, "class", null, newProps.class, namespace);
                                }
                            }
                            if (patchFlag & 4) {
                                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
                            }
                            if (patchFlag & 8) {
                                var propsToUpdate = n2.dynamicProps;
                                for(var i = 0; i < propsToUpdate.length; i++){
                                    var key = propsToUpdate[i];
                                    var prev = oldProps[key];
                                    var next = newProps[key];
                                    if (next !== prev || key === "value") {
                                        hostPatchProp(el, key, prev, next, namespace, parentComponent);
                                    }
                                }
                            }
                        }
                        if (patchFlag & 1) {
                            if (n1.children !== n2.children) {
                                hostSetElementText(el, n2.children);
                            }
                        }
                    } else if (!optimized && dynamicChildren == null) {
                        patchProps(el, oldProps, newProps, parentComponent, namespace);
                    }
                    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
                        queuePostRenderEffect(function() {
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
                        }, parentSuspense);
                    }
                };
                var patchBlockChildren = function(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) {
                    for(var i = 0; i < newChildren.length; i++){
                        var oldVNode = oldChildren[i];
                        var newVNode = newChildren[i];
                        var container = // oldVNode may be an errored async setup() component inside Suspense
                        // which will not have a mounted element
                        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
                        // of the Fragment itself so it can move its children.
                        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
                        // which also requires the correct parent container
                        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
                        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
                        // just pass the block element here to avoid a DOM parentNode call.
                        fallbackContainer;
                        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);
                    }
                };
                var patchProps = function(el, oldProps, newProps, parentComponent, namespace) {
                    if (oldProps !== newProps) {
                        if (oldProps !== shared.EMPTY_OBJ) {
                            for(var key in oldProps){
                                if (!shared.isReservedProp(key) && !(key in newProps)) {
                                    hostPatchProp(el, key, oldProps[key], null, namespace, parentComponent);
                                }
                            }
                        }
                        for(var key1 in newProps){
                            if (shared.isReservedProp(key1)) continue;
                            var next = newProps[key1];
                            var prev = oldProps[key1];
                            if (next !== prev && key1 !== "value") {
                                hostPatchProp(el, key1, prev, next, namespace, parentComponent);
                            }
                        }
                        if ("value" in newProps) {
                            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
                        }
                    }
                };
                var processFragment = function(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
                    var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
                    var patchFlag = n2.patchFlag, dynamicChildren = n2.dynamicChildren, fragmentSlotScopeIds = n2.slotScopeIds;
                    if (// #5523 dev root fragment may inherit directives
                    isHmrUpdating || patchFlag & 2048) {
                        patchFlag = 0;
                        optimized = false;
                        dynamicChildren = null;
                    }
                    if (fragmentSlotScopeIds) {
                        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
                    }
                    if (n1 == null) {
                        hostInsert(fragmentStartAnchor, container, anchor);
                        hostInsert(fragmentEndAnchor, container, anchor);
                        mountChildren(// #10007
                        // such fragment like `<></>` will be compiled into
                        // a fragment which doesn't have a children.
                        // In this case fallback to an empty array
                        n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    } else {
                        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
                        // of renderSlot() with no valid children
                        n1.dynamicChildren) {
                            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);
                            {
                                traverseStaticChildren(n1, n2);
                            }
                        } else {
                            patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                        }
                    }
                };
                var processComponent = function(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    n2.slotScopeIds = slotScopeIds;
                    if (n1 == null) {
                        if (n2.shapeFlag & 512) {
                            parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);
                        } else {
                            mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);
                        }
                    } else {
                        updateComponent(n1, n2, optimized);
                    }
                };
                var mountComponent = function(initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) {
                    var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
                    if (instance.type.__hmrId) {
                        registerHMR(instance);
                    }
                    {
                        pushWarningContext(initialVNode);
                        startMeasure(instance, "mount");
                    }
                    if (isKeepAlive(initialVNode)) {
                        instance.ctx.renderer = internals;
                    }
                    {
                        {
                            startMeasure(instance, "init");
                        }
                        setupComponent(instance, false, optimized);
                        {
                            endMeasure(instance, "init");
                        }
                    }
                    if (instance.asyncDep) {
                        if (isHmrUpdating) initialVNode.el = null;
                        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
                        if (!initialVNode.el) {
                            var placeholder = instance.subTree = createVNode(Comment);
                            processCommentNode(null, placeholder, container, anchor);
                        }
                    } else {
                        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
                    }
                    {
                        popWarningContext();
                        endMeasure(instance, "mount");
                    }
                };
                var updateComponent = function(n1, n2, optimized) {
                    var instance = n2.component = n1.component;
                    if (shouldUpdateComponent(n1, n2, optimized)) {
                        if (instance.asyncDep && !instance.asyncResolved) {
                            {
                                pushWarningContext(n2);
                            }
                            updateComponentPreRender(instance, n2, optimized);
                            {
                                popWarningContext();
                            }
                            return;
                        } else {
                            instance.next = n2;
                            instance.update();
                        }
                    } else {
                        n2.el = n1.el;
                        instance.vnode = n2;
                    }
                };
                var setupRenderEffect = function(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) {
                    var componentUpdateFn = function() {
                        if (!instance.isMounted) {
                            var vnodeHook;
                            var el = initialVNode.el, props = initialVNode.props;
                            var bm = instance.bm, m = instance.m, parent = instance.parent, root = instance.root, type = instance.type;
                            var isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                            toggleRecurse(instance, false);
                            if (bm) {
                                shared.invokeArrayFns(bm);
                            }
                            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                                invokeVNodeHook(vnodeHook, parent, initialVNode);
                            }
                            toggleRecurse(instance, true);
                            if (el && hydrateNode) {
                                var hydrateSubTree = function() {
                                    {
                                        startMeasure(instance, "render");
                                    }
                                    instance.subTree = renderComponentRoot(instance);
                                    {
                                        endMeasure(instance, "render");
                                    }
                                    {
                                        startMeasure(instance, "hydrate");
                                    }
                                    hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                                    {
                                        endMeasure(instance, "hydrate");
                                    }
                                };
                                if (isAsyncWrapperVNode && type.__asyncHydrate) {
                                    type.__asyncHydrate(el, instance, hydrateSubTree);
                                } else {
                                    hydrateSubTree();
                                }
                            } else {
                                if (root.ce) {
                                    root.ce._injectChildStyle(type);
                                }
                                {
                                    startMeasure(instance, "render");
                                }
                                var subTree = instance.subTree = renderComponentRoot(instance);
                                {
                                    endMeasure(instance, "render");
                                }
                                {
                                    startMeasure(instance, "patch");
                                }
                                patch(null, subTree, container, anchor, instance, parentSuspense, namespace);
                                {
                                    endMeasure(instance, "patch");
                                }
                                initialVNode.el = subTree.el;
                            }
                            if (m) {
                                queuePostRenderEffect(m, parentSuspense);
                            }
                            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                                var scopedInitialVNode = initialVNode;
                                queuePostRenderEffect(function() {
                                    return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
                                }, parentSuspense);
                            }
                            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                            }
                            instance.isMounted = true;
                            {
                                devtoolsComponentAdded(instance);
                            }
                            initialVNode = container = anchor = null;
                        } else {
                            var next = instance.next, bu = instance.bu, u = instance.u, parent1 = instance.parent, vnode = instance.vnode;
                            {
                                var nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                                if (nonHydratedAsyncRoot) {
                                    if (next) {
                                        next.el = vnode.el;
                                        updateComponentPreRender(instance, next, optimized);
                                    }
                                    nonHydratedAsyncRoot.asyncDep.then(function() {
                                        if (!instance.isUnmounted) {
                                            componentUpdateFn();
                                        }
                                    });
                                    return;
                                }
                            }
                            var originNext = next;
                            var vnodeHook1;
                            {
                                pushWarningContext(next || instance.vnode);
                            }
                            toggleRecurse(instance, false);
                            if (next) {
                                next.el = vnode.el;
                                updateComponentPreRender(instance, next, optimized);
                            } else {
                                next = vnode;
                            }
                            if (bu) {
                                shared.invokeArrayFns(bu);
                            }
                            if (vnodeHook1 = next.props && next.props.onVnodeBeforeUpdate) {
                                invokeVNodeHook(vnodeHook1, parent1, next, vnode);
                            }
                            toggleRecurse(instance, true);
                            {
                                startMeasure(instance, "render");
                            }
                            var nextTree = renderComponentRoot(instance);
                            {
                                endMeasure(instance, "render");
                            }
                            var prevTree = instance.subTree;
                            instance.subTree = nextTree;
                            {
                                startMeasure(instance, "patch");
                            }
                            patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                            hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                            getNextHostNode(prevTree), instance, parentSuspense, namespace);
                            {
                                endMeasure(instance, "patch");
                            }
                            next.el = nextTree.el;
                            if (originNext === null) {
                                updateHOCHostEl(instance, nextTree.el);
                            }
                            if (u) {
                                queuePostRenderEffect(u, parentSuspense);
                            }
                            if (vnodeHook1 = next.props && next.props.onVnodeUpdated) {
                                queuePostRenderEffect(function() {
                                    return invokeVNodeHook(vnodeHook1, parent1, next, vnode);
                                }, parentSuspense);
                            }
                            {
                                devtoolsComponentUpdated(instance);
                            }
                            {
                                popWarningContext();
                            }
                        }
                    };
                    instance.scope.on();
                    var effect = instance.effect = new reactivity.ReactiveEffect(componentUpdateFn);
                    instance.scope.off();
                    var update = instance.update = effect.run.bind(effect);
                    var job = instance.job = effect.runIfDirty.bind(effect);
                    job.i = instance;
                    job.id = instance.uid;
                    effect.scheduler = function() {
                        return queueJob(job);
                    };
                    toggleRecurse(instance, true);
                    {
                        effect.onTrack = instance.rtc ? function(e) {
                            return shared.invokeArrayFns(instance.rtc, e);
                        } : void 0;
                        effect.onTrigger = instance.rtg ? function(e) {
                            return shared.invokeArrayFns(instance.rtg, e);
                        } : void 0;
                    }
                    update();
                };
                var updateComponentPreRender = function(instance, nextVNode, optimized) {
                    nextVNode.component = instance;
                    var prevProps = instance.vnode.props;
                    instance.vnode = nextVNode;
                    instance.next = null;
                    updateProps(instance, nextVNode.props, prevProps, optimized);
                    updateSlots(instance, nextVNode.children, optimized);
                    reactivity.pauseTracking();
                    flushPreFlushCbs(instance);
                    reactivity.resetTracking();
                };
                var patchChildren = function(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds) {
                    var optimized = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
                    var c1 = n1 && n1.children;
                    var prevShapeFlag = n1 ? n1.shapeFlag : 0;
                    var c2 = n2.children;
                    var patchFlag = n2.patchFlag, shapeFlag = n2.shapeFlag;
                    if (patchFlag > 0) {
                        if (patchFlag & 128) {
                            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            return;
                        } else if (patchFlag & 256) {
                            patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            return;
                        }
                    }
                    if (shapeFlag & 8) {
                        if (prevShapeFlag & 16) {
                            unmountChildren(c1, parentComponent, parentSuspense);
                        }
                        if (c2 !== c1) {
                            hostSetElementText(container, c2);
                        }
                    } else {
                        if (prevShapeFlag & 16) {
                            if (shapeFlag & 16) {
                                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            } else {
                                unmountChildren(c1, parentComponent, parentSuspense, true);
                            }
                        } else {
                            if (prevShapeFlag & 8) {
                                hostSetElementText(container, "");
                            }
                            if (shapeFlag & 16) {
                                mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            }
                        }
                    }
                };
                var patchUnkeyedChildren = function(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    c1 = c1 || shared.EMPTY_ARR;
                    c2 = c2 || shared.EMPTY_ARR;
                    var oldLength = c1.length;
                    var newLength = c2.length;
                    var commonLength = Math.min(oldLength, newLength);
                    var i;
                    for(i = 0; i < commonLength; i++){
                        var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    }
                    if (oldLength > newLength) {
                        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
                    } else {
                        mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
                    }
                };
                var patchKeyedChildren = function(c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) {
                    var i = 0;
                    var l2 = c2.length;
                    var e1 = c1.length - 1;
                    var e2 = l2 - 1;
                    while(i <= e1 && i <= e2){
                        var n1 = c1[i];
                        var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                        if (isSameVNodeType(n1, n2)) {
                            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                        } else {
                            break;
                        }
                        i++;
                    }
                    while(i <= e1 && i <= e2){
                        var n11 = c1[e1];
                        var n21 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
                        if (isSameVNodeType(n11, n21)) {
                            patch(n11, n21, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                        } else {
                            break;
                        }
                        e1--;
                        e2--;
                    }
                    if (i > e1) {
                        if (i <= e2) {
                            var nextPos = e2 + 1;
                            var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                            while(i <= e2){
                                patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                                i++;
                            }
                        }
                    } else if (i > e2) {
                        while(i <= e1){
                            unmount(c1[i], parentComponent, parentSuspense, true);
                            i++;
                        }
                    } else {
                        var s1 = i;
                        var s2 = i;
                        var keyToNewIndexMap = /* @__PURE__ */ new Map();
                        for(i = s2; i <= e2; i++){
                            var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                            if (nextChild.key != null) {
                                if (keyToNewIndexMap.has(nextChild.key)) {
                                    warn$1("Duplicate keys found during update:", JSON.stringify(nextChild.key), "Make sure keys are unique.");
                                }
                                keyToNewIndexMap.set(nextChild.key, i);
                            }
                        }
                        var j;
                        var patched = 0;
                        var toBePatched = e2 - s2 + 1;
                        var moved = false;
                        var maxNewIndexSoFar = 0;
                        var newIndexToOldIndexMap = new Array(toBePatched);
                        for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
                        for(i = s1; i <= e1; i++){
                            var prevChild = c1[i];
                            if (patched >= toBePatched) {
                                unmount(prevChild, parentComponent, parentSuspense, true);
                                continue;
                            }
                            var newIndex = void 0;
                            if (prevChild.key != null) {
                                newIndex = keyToNewIndexMap.get(prevChild.key);
                            } else {
                                for(j = s2; j <= e2; j++){
                                    if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                                        newIndex = j;
                                        break;
                                    }
                                }
                            }
                            if (newIndex === void 0) {
                                unmount(prevChild, parentComponent, parentSuspense, true);
                            } else {
                                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                                if (newIndex >= maxNewIndexSoFar) {
                                    maxNewIndexSoFar = newIndex;
                                } else {
                                    moved = true;
                                }
                                patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                                patched++;
                            }
                        }
                        var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared.EMPTY_ARR;
                        j = increasingNewIndexSequence.length - 1;
                        for(i = toBePatched - 1; i >= 0; i--){
                            var nextIndex = s2 + i;
                            var nextChild1 = c2[nextIndex];
                            var anchor1 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                            if (newIndexToOldIndexMap[i] === 0) {
                                patch(null, nextChild1, container, anchor1, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                            } else if (moved) {
                                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                                    move(nextChild1, container, anchor1, 2);
                                } else {
                                    j--;
                                }
                            }
                        }
                    }
                };
                var move = function(vnode, container, anchor, moveType) {
                    var parentSuspense = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                    var el = vnode.el, type = vnode.type, transition = vnode.transition, children = vnode.children, shapeFlag = vnode.shapeFlag;
                    if (shapeFlag & 6) {
                        move(vnode.component.subTree, container, anchor, moveType);
                        return;
                    }
                    if (shapeFlag & 128) {
                        vnode.suspense.move(container, anchor, moveType);
                        return;
                    }
                    if (shapeFlag & 64) {
                        type.move(vnode, container, anchor, internals);
                        return;
                    }
                    if (type === Fragment) {
                        hostInsert(el, container, anchor);
                        for(var i = 0; i < children.length; i++){
                            move(children[i], container, anchor, moveType);
                        }
                        hostInsert(vnode.anchor, container, anchor);
                        return;
                    }
                    if (type === Static) {
                        moveStaticNode(vnode, container, anchor);
                        return;
                    }
                    var needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
                    if (needTransition2) {
                        if (moveType === 0) {
                            transition.beforeEnter(el);
                            hostInsert(el, container, anchor);
                            queuePostRenderEffect(function() {
                                return transition.enter(el);
                            }, parentSuspense);
                        } else {
                            var leave = transition.leave, delayLeave = transition.delayLeave, afterLeave = transition.afterLeave;
                            var remove2 = function() {
                                return hostInsert(el, container, anchor);
                            };
                            var performLeave = function() {
                                leave(el, function() {
                                    remove2();
                                    afterLeave && afterLeave();
                                });
                            };
                            if (delayLeave) {
                                delayLeave(el, remove2, performLeave);
                            } else {
                                performLeave();
                            }
                        }
                    } else {
                        hostInsert(el, container, anchor);
                    }
                };
                var unmount = function(vnode, parentComponent, parentSuspense) {
                    var doRemove = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, optimized = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
                    var type = vnode.type, props = vnode.props, ref = vnode.ref, children = vnode.children, dynamicChildren = vnode.dynamicChildren, shapeFlag = vnode.shapeFlag, patchFlag = vnode.patchFlag, dirs = vnode.dirs, cacheIndex = vnode.cacheIndex;
                    if (patchFlag === -2) {
                        optimized = false;
                    }
                    if (ref != null) {
                        setRef(ref, null, parentSuspense, vnode, true);
                    }
                    if (cacheIndex != null) {
                        parentComponent.renderCache[cacheIndex] = void 0;
                    }
                    if (shapeFlag & 256) {
                        parentComponent.ctx.deactivate(vnode);
                        return;
                    }
                    var shouldInvokeDirs = shapeFlag & 1 && dirs;
                    var shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
                    var vnodeHook;
                    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
                        invokeVNodeHook(vnodeHook, parentComponent, vnode);
                    }
                    if (shapeFlag & 6) {
                        unmountComponent(vnode.component, parentSuspense, doRemove);
                    } else {
                        if (shapeFlag & 128) {
                            vnode.suspense.unmount(parentSuspense, doRemove);
                            return;
                        }
                        if (shouldInvokeDirs) {
                            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
                        }
                        if (shapeFlag & 64) {
                            vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove);
                        } else if (dynamicChildren && // #5154
                        // when v-once is used inside a block, setBlockTracking(-1) marks the
                        // parent block with hasOnce: true
                        // so that it doesn't take the fast path during unmount - otherwise
                        // components nested in v-once are never unmounted.
                        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
                        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
                            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
                        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
                            unmountChildren(children, parentComponent, parentSuspense);
                        }
                        if (doRemove) {
                            remove(vnode);
                        }
                    }
                    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
                        queuePostRenderEffect(function() {
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
                        }, parentSuspense);
                    }
                };
                var remove = function(vnode) {
                    var type = vnode.type, el = vnode.el, anchor = vnode.anchor, transition = vnode.transition;
                    if (type === Fragment) {
                        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
                            vnode.children.forEach(function(child) {
                                if (child.type === Comment) {
                                    hostRemove(child.el);
                                } else {
                                    remove(child);
                                }
                            });
                        } else {
                            removeFragment(el, anchor);
                        }
                        return;
                    }
                    if (type === Static) {
                        removeStaticNode(vnode);
                        return;
                    }
                    var performRemove = function() {
                        hostRemove(el);
                        if (transition && !transition.persisted && transition.afterLeave) {
                            transition.afterLeave();
                        }
                    };
                    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
                        var leave = transition.leave, delayLeave = transition.delayLeave;
                        var performLeave = function() {
                            return leave(el, performRemove);
                        };
                        if (delayLeave) {
                            delayLeave(vnode.el, performRemove, performLeave);
                        } else {
                            performLeave();
                        }
                    } else {
                        performRemove();
                    }
                };
                var removeFragment = function(cur, end) {
                    var next;
                    while(cur !== end){
                        next = hostNextSibling(cur);
                        hostRemove(cur);
                        cur = next;
                    }
                    hostRemove(end);
                };
                var unmountComponent = function(instance, parentSuspense, doRemove) {
                    if (instance.type.__hmrId) {
                        unregisterHMR(instance);
                    }
                    var bum = instance.bum, scope = instance.scope, job = instance.job, subTree = instance.subTree, um = instance.um, m = instance.m, a = instance.a;
                    invalidateMount(m);
                    invalidateMount(a);
                    if (bum) {
                        shared.invokeArrayFns(bum);
                    }
                    scope.stop();
                    if (job) {
                        job.flags |= 8;
                        unmount(subTree, instance, parentSuspense, doRemove);
                    }
                    if (um) {
                        queuePostRenderEffect(um, parentSuspense);
                    }
                    queuePostRenderEffect(function() {
                        instance.isUnmounted = true;
                    }, parentSuspense);
                    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
                        parentSuspense.deps--;
                        if (parentSuspense.deps === 0) {
                            parentSuspense.resolve();
                        }
                    }
                    {
                        devtoolsComponentRemoved(instance);
                    }
                };
                var unmountChildren = function(children, parentComponent, parentSuspense) {
                    var doRemove = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, optimized = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, start = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
                    for(var i = start; i < children.length; i++){
                        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
                    }
                };
                var getNextHostNode = function(vnode) {
                    if (vnode.shapeFlag & 6) {
                        return getNextHostNode(vnode.component.subTree);
                    }
                    if (vnode.shapeFlag & 128) {
                        return vnode.suspense.next();
                    }
                    var el = hostNextSibling(vnode.anchor || vnode.el);
                    var teleportEnd = el && el[TeleportEndKey];
                    return teleportEnd ? hostNextSibling(teleportEnd) : el;
                };
                var isFlushing = false;
                var render = function(vnode, container, namespace) {
                    if (vnode == null) {
                        if (container._vnode) {
                            unmount(container._vnode, null, null, true);
                        }
                    } else {
                        patch(container._vnode || null, vnode, container, null, null, null, namespace);
                    }
                    container._vnode = vnode;
                    if (!isFlushing) {
                        isFlushing = true;
                        flushPreFlushCbs();
                        flushPostFlushCbs();
                        isFlushing = false;
                    }
                };
                var internals = {
                    p: patch,
                    um: unmount,
                    m: move,
                    r: remove,
                    mt: mountComponent,
                    mc: mountChildren,
                    pc: patchChildren,
                    pbc: patchBlockChildren,
                    n: getNextHostNode,
                    o: options
                };
                var hydrate;
                var hydrateNode;
                if (createHydrationFns) {
                    var ref;
                    ref = _sliced_to_array(createHydrationFns(internals), 2), hydrate = ref[0], hydrateNode = ref[1], ref;
                }
                return {
                    render: render,
                    hydrate: hydrate,
                    createApp: createAppAPI(render, hydrate)
                };
            }
            function resolveChildrenNamespace(param, currentNamespace) {
                var type = param.type, props = param.props;
                return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
            }
            function toggleRecurse(param, allowed) {
                var effect = param.effect, job = param.job;
                if (allowed) {
                    effect.flags |= 32;
                    job.flags |= 4;
                } else {
                    effect.flags &= ~32;
                    job.flags &= ~4;
                }
            }
            function needTransition(parentSuspense, transition) {
                return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
            }
            function traverseStaticChildren(n1, n2) {
                var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var ch1 = n1.children;
                var ch2 = n2.children;
                if (shared.isArray(ch1) && shared.isArray(ch2)) {
                    for(var i = 0; i < ch1.length; i++){
                        var c1 = ch1[i];
                        var c2 = ch2[i];
                        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
                            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                                c2.el = c1.el;
                            }
                            if (!shallow && c2.patchFlag !== -2) traverseStaticChildren(c1, c2);
                        }
                        if (c2.type === Text) {
                            c2.el = c1.el;
                        }
                        if (c2.type === Comment && !c2.el) {
                            c2.el = c1.el;
                        }
                    }
                }
            }
            function getSequence(arr) {
                var p = arr.slice();
                var result = [
                    0
                ];
                var i, j, u, v1, c;
                var len = arr.length;
                for(i = 0; i < len; i++){
                    var arrI = arr[i];
                    if (arrI !== 0) {
                        j = result[result.length - 1];
                        if (arr[j] < arrI) {
                            p[i] = j;
                            result.push(i);
                            continue;
                        }
                        u = 0;
                        v1 = result.length - 1;
                        while(u < v1){
                            c = u + v1 >> 1;
                            if (arr[result[c]] < arrI) {
                                u = c + 1;
                            } else {
                                v1 = c;
                            }
                        }
                        if (arrI < arr[result[u]]) {
                            if (u > 0) {
                                p[i] = result[u - 1];
                            }
                            result[u] = i;
                        }
                    }
                }
                u = result.length;
                v1 = result[u - 1];
                while(u-- > 0){
                    result[u] = v1;
                    v1 = p[v1];
                }
                return result;
            }
            function locateNonHydratedAsyncRoot(instance) {
                var subComponent = instance.subTree.component;
                if (subComponent) {
                    if (subComponent.asyncDep && !subComponent.asyncResolved) {
                        return subComponent;
                    } else {
                        return locateNonHydratedAsyncRoot(subComponent);
                    }
                }
            }
            function invalidateMount(hooks) {
                if (hooks) {
                    for(var i = 0; i < hooks.length; i++)hooks[i].flags |= 8;
                }
            }
            var ssrContextKey = Symbol.for("v-scx");
            var useSSRContext = function() {
                {
                    var ctx = inject(ssrContextKey);
                    if (!ctx) {
                        warn$1("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.");
                    }
                    return ctx;
                }
            };
            function watchEffect(effect, options) {
                return doWatch(effect, null, options);
            }
            function watchPostEffect(effect, options) {
                return doWatch(effect, null, shared.extend({}, options, {
                    flush: "post"
                }));
            }
            function watchSyncEffect(effect, options) {
                return doWatch(effect, null, shared.extend({}, options, {
                    flush: "sync"
                }));
            }
            function watch(source, cb, options) {
                if (!shared.isFunction(cb)) {
                    warn$1("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.");
                }
                return doWatch(source, cb, options);
            }
            function doWatch(source, cb) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : shared.EMPTY_OBJ;
                var immediate = options.immediate, deep = options.deep, flush = options.flush, once = options.once;
                if (!cb) {
                    if (immediate !== void 0) {
                        warn$1('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.');
                    }
                    if (deep !== void 0) {
                        warn$1('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.');
                    }
                    if (once !== void 0) {
                        warn$1('watch() "once" option is only respected when using the watch(source, callback, options?) signature.');
                    }
                }
                var baseWatchOptions = shared.extend({}, options);
                baseWatchOptions.onWarn = warn$1;
                var runsImmediately = cb && immediate || !cb && flush !== "post";
                var ssrCleanup;
                if (isInSSRComponentSetup) {
                    if (flush === "sync") {
                        var ctx = useSSRContext();
                        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
                    } else if (!runsImmediately) {
                        var watchStopHandle = function() {};
                        watchStopHandle.stop = shared.NOOP;
                        watchStopHandle.resume = shared.NOOP;
                        watchStopHandle.pause = shared.NOOP;
                        return watchStopHandle;
                    }
                }
                var instance = currentInstance;
                baseWatchOptions.call = function(fn, type, args) {
                    return callWithAsyncErrorHandling(fn, instance, type, args);
                };
                var isPre = false;
                if (flush === "post") {
                    baseWatchOptions.scheduler = function(job) {
                        queuePostRenderEffect(job, instance && instance.suspense);
                    };
                } else if (flush !== "sync") {
                    isPre = true;
                    baseWatchOptions.scheduler = function(job, isFirstRun) {
                        if (isFirstRun) {
                            job();
                        } else {
                            queueJob(job);
                        }
                    };
                }
                baseWatchOptions.augmentJob = function(job) {
                    if (cb) {
                        job.flags |= 4;
                    }
                    if (isPre) {
                        job.flags |= 2;
                        if (instance) {
                            job.id = instance.uid;
                            job.i = instance;
                        }
                    }
                };
                var watchHandle = reactivity.watch(source, cb, baseWatchOptions);
                if (isInSSRComponentSetup) {
                    if (ssrCleanup) {
                        ssrCleanup.push(watchHandle);
                    } else if (runsImmediately) {
                        watchHandle();
                    }
                }
                return watchHandle;
            }
            function instanceWatch(source, value, options) {
                var publicThis = this.proxy;
                var getter = shared.isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : function() {
                    return publicThis[source];
                } : source.bind(publicThis, publicThis);
                var cb;
                if (shared.isFunction(value)) {
                    cb = value;
                } else {
                    cb = value.handler;
                    options = value;
                }
                var reset = setCurrentInstance(this);
                var res = doWatch(getter, cb.bind(publicThis), options);
                reset();
                return res;
            }
            function createPathGetter(ctx, path) {
                var segments = path.split(".");
                return function() {
                    var cur = ctx;
                    for(var i = 0; i < segments.length && cur; i++){
                        cur = cur[segments[i]];
                    }
                    return cur;
                };
            }
            function useModel(props, name) {
                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : shared.EMPTY_OBJ;
                var i = getCurrentInstance();
                if (!i) {
                    warn$1("useModel() called without active instance.");
                    return reactivity.ref();
                }
                var camelizedName = shared.camelize(name);
                if (!i.propsOptions[0][camelizedName]) {
                    warn$1('useModel() called with prop "'.concat(name, '" which is not declared.'));
                    return reactivity.ref();
                }
                var hyphenatedName = shared.hyphenate(name);
                var modifiers = getModelModifiers(props, camelizedName);
                var res = reactivity.customRef(function(track, trigger) {
                    var localValue;
                    var prevSetValue = shared.EMPTY_OBJ;
                    var prevEmittedValue;
                    watchSyncEffect(function() {
                        var propValue = props[camelizedName];
                        if (shared.hasChanged(localValue, propValue)) {
                            localValue = propValue;
                            trigger();
                        }
                    });
                    return {
                        get: function get() {
                            track();
                            return options.get ? options.get(localValue) : localValue;
                        },
                        set: function set(value) {
                            var emittedValue = options.set ? options.set(value) : value;
                            if (!shared.hasChanged(emittedValue, localValue) && !(prevSetValue !== shared.EMPTY_OBJ && shared.hasChanged(value, prevSetValue))) {
                                return;
                            }
                            var rawProps = i.vnode.props;
                            if (!(rawProps && // check if parent has passed v-model
                            (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && ("onUpdate:".concat(name) in rawProps || "onUpdate:".concat(camelizedName) in rawProps || "onUpdate:".concat(hyphenatedName) in rawProps))) {
                                localValue = value;
                                trigger();
                            }
                            i.emit("update:".concat(name), emittedValue);
                            if (shared.hasChanged(value, emittedValue) && shared.hasChanged(value, prevSetValue) && !shared.hasChanged(emittedValue, prevEmittedValue)) {
                                trigger();
                            }
                            prevSetValue = value;
                            prevEmittedValue = emittedValue;
                        }
                    };
                });
                res[Symbol.iterator] = function() {
                    var i2 = 0;
                    return {
                        next: function next() {
                            if (i2 < 2) {
                                return {
                                    value: i2++ ? modifiers || shared.EMPTY_OBJ : res,
                                    done: false
                                };
                            } else {
                                return {
                                    done: true
                                };
                            }
                        }
                    };
                };
                return res;
            }
            var getModelModifiers = function(props, modelName) {
                return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props["".concat(modelName, "Modifiers")] || props["".concat(shared.camelize(modelName), "Modifiers")] || props["".concat(shared.hyphenate(modelName), "Modifiers")];
            };
            function emit(instance, event) {
                for(var _len = arguments.length, rawArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
                    rawArgs[_key - 2] = arguments[_key];
                }
                if (instance.isUnmounted) return;
                var props = instance.vnode.props || shared.EMPTY_OBJ;
                {
                    var emitsOptions = instance.emitsOptions, _instance_propsOptions = _sliced_to_array(instance.propsOptions, 1), propsOptions = _instance_propsOptions[0];
                    if (emitsOptions) {
                        if (!(event in emitsOptions) && true) {
                            if (!propsOptions || !(shared.toHandlerKey(shared.camelize(event)) in propsOptions)) {
                                warn$1('Component emitted event "'.concat(event, '" but it is neither declared in the emits option nor as an "').concat(shared.toHandlerKey(shared.camelize(event)), '" prop.'));
                            }
                        } else {
                            var validator = emitsOptions[event];
                            if (shared.isFunction(validator)) {
                                var isValid = validator.apply(void 0, _to_consumable_array(rawArgs));
                                if (!isValid) {
                                    warn$1('Invalid event arguments: event validation failed for event "'.concat(event, '".'));
                                }
                            }
                        }
                    }
                }
                var args = rawArgs;
                var isModelListener = event.startsWith("update:");
                var modifiers = isModelListener && getModelModifiers(props, event.slice(7));
                if (modifiers) {
                    if (modifiers.trim) {
                        args = rawArgs.map(function(a) {
                            return shared.isString(a) ? a.trim() : a;
                        });
                    }
                    if (modifiers.number) {
                        args = rawArgs.map(shared.looseToNumber);
                    }
                }
                {
                    devtoolsComponentEmit(instance, event, args);
                }
                {
                    var lowerCaseEvent = event.toLowerCase();
                    if (lowerCaseEvent !== event && props[shared.toHandlerKey(lowerCaseEvent)]) {
                        warn$1('Event "'.concat(lowerCaseEvent, '" is emitted in component ').concat(formatComponentName(instance, instance.type), ' but the handler is registered for "').concat(event, '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "').concat(shared.hyphenate(event), '" instead of "').concat(event, '".'));
                    }
                }
                var handlerName;
                var handler = props[handlerName = shared.toHandlerKey(event)] || // also try camelCase event handler (#2249)
                props[handlerName = shared.toHandlerKey(shared.camelize(event))];
                if (!handler && isModelListener) {
                    handler = props[handlerName = shared.toHandlerKey(shared.hyphenate(event))];
                }
                if (handler) {
                    callWithAsyncErrorHandling(handler, instance, 6, args);
                }
                var onceHandler = props[handlerName + "Once"];
                if (onceHandler) {
                    if (!instance.emitted) {
                        instance.emitted = {};
                    } else if (instance.emitted[handlerName]) {
                        return;
                    }
                    instance.emitted[handlerName] = true;
                    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
                }
            }
            function normalizeEmitsOptions(comp, appContext) {
                var asMixin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var cache = appContext.emitsCache;
                var cached = cache.get(comp);
                if (cached !== void 0) {
                    return cached;
                }
                var raw = comp.emits;
                var normalized = {};
                var hasExtends = false;
                if (!shared.isFunction(comp)) {
                    var extendEmits = function(raw2) {
                        var normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
                        if (normalizedFromExtend) {
                            hasExtends = true;
                            shared.extend(normalized, normalizedFromExtend);
                        }
                    };
                    if (!asMixin && appContext.mixins.length) {
                        appContext.mixins.forEach(extendEmits);
                    }
                    if (comp.extends) {
                        extendEmits(comp.extends);
                    }
                    if (comp.mixins) {
                        comp.mixins.forEach(extendEmits);
                    }
                }
                if (!raw && !hasExtends) {
                    if (shared.isObject(comp)) {
                        cache.set(comp, null);
                    }
                    return null;
                }
                if (shared.isArray(raw)) {
                    raw.forEach(function(key) {
                        return normalized[key] = null;
                    });
                } else {
                    shared.extend(normalized, raw);
                }
                if (shared.isObject(comp)) {
                    cache.set(comp, normalized);
                }
                return normalized;
            }
            function isEmitListener(options, key) {
                if (!options || !shared.isOn(key)) {
                    return false;
                }
                key = key.slice(2).replace(/Once$/, "");
                return shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared.hasOwn(options, shared.hyphenate(key)) || shared.hasOwn(options, key);
            }
            var accessedAttrs = false;
            function markAttrsAccessed() {
                accessedAttrs = true;
            }
            function renderComponentRoot(instance) {
                var Component = instance.type, vnode = instance.vnode, proxy = instance.proxy, withProxy = instance.withProxy, _instance_propsOptions = _sliced_to_array(instance.propsOptions, 1), propsOptions = _instance_propsOptions[0], slots = instance.slots, attrs = instance.attrs, emit2 = instance.emit, render = instance.render, renderCache = instance.renderCache, props = instance.props, data = instance.data, setupState = instance.setupState, ctx = instance.ctx, inheritAttrs = instance.inheritAttrs;
                var prev = setCurrentRenderingInstance(instance);
                var result;
                var fallthroughAttrs;
                {
                    accessedAttrs = false;
                }
                try {
                    if (vnode.shapeFlag & 4) {
                        var proxyToUse = withProxy || proxy;
                        var thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
                            get: function get(target, key, receiver) {
                                warn$1("Property '".concat(String(key), "' was accessed via 'this'. Avoid using 'this' in templates."));
                                return Reflect.get(target, key, receiver);
                            }
                        }) : proxyToUse;
                        result = normalizeVNode(render.call(thisProxy, proxyToUse, renderCache, true ? reactivity.shallowReadonly(props) : props, setupState, data, ctx));
                        fallthroughAttrs = attrs;
                    } else {
                        var render2 = Component;
                        if (attrs === props) {
                            markAttrsAccessed();
                        }
                        result = normalizeVNode(render2.length > 1 ? render2(true ? reactivity.shallowReadonly(props) : props, true ? {
                            get attrs () {
                                markAttrsAccessed();
                                return reactivity.shallowReadonly(attrs);
                            },
                            slots: slots,
                            emit: emit2
                        } : {
                            attrs: attrs,
                            slots: slots,
                            emit: emit2
                        }) : render2(true ? reactivity.shallowReadonly(props) : props, null));
                        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
                    }
                } catch (err) {
                    blockStack.length = 0;
                    handleError(err, instance, 1);
                    result = createVNode(Comment);
                }
                var root = result;
                var setRoot = void 0;
                if (result.patchFlag > 0 && result.patchFlag & 2048) {
                    var ref;
                    ref = _sliced_to_array(getChildRoot(result), 2), root = ref[0], setRoot = ref[1], ref;
                }
                if (fallthroughAttrs && inheritAttrs !== false) {
                    var keys = Object.keys(fallthroughAttrs);
                    var shapeFlag = root.shapeFlag;
                    if (keys.length) {
                        if (shapeFlag & (1 | 6)) {
                            if (propsOptions && keys.some(shared.isModelListener)) {
                                fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                            }
                            root = cloneVNode(root, fallthroughAttrs, false, true);
                        } else if (!accessedAttrs && root.type !== Comment) {
                            var allAttrs = Object.keys(attrs);
                            var eventAttrs = [];
                            var extraAttrs = [];
                            for(var i = 0, l = allAttrs.length; i < l; i++){
                                var key = allAttrs[i];
                                if (shared.isOn(key)) {
                                    if (!shared.isModelListener(key)) {
                                        eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                                    }
                                } else {
                                    extraAttrs.push(key);
                                }
                            }
                            if (extraAttrs.length) {
                                warn$1("Extraneous non-props attributes (".concat(extraAttrs.join(", "), ") were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes."));
                            }
                            if (eventAttrs.length) {
                                warn$1("Extraneous non-emits event listeners (".concat(eventAttrs.join(", "), ') were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.'));
                            }
                        }
                    }
                }
                if (vnode.dirs) {
                    if (!isElementRoot(root)) {
                        warn$1("Runtime directive used on component with non-element root node. The directives will not function as intended.");
                    }
                    root = cloneVNode(root, null, false, true);
                    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
                }
                if (vnode.transition) {
                    if (!isElementRoot(root)) {
                        warn$1("Component inside <Transition> renders non-element root node that cannot be animated.");
                    }
                    setTransitionHooks(root, vnode.transition);
                }
                if (setRoot) {
                    setRoot(root);
                } else {
                    result = root;
                }
                setCurrentRenderingInstance(prev);
                return result;
            }
            var getChildRoot = function(vnode) {
                var rawChildren = vnode.children;
                var dynamicChildren = vnode.dynamicChildren;
                var childRoot = filterSingleRoot(rawChildren, false);
                if (!childRoot) {
                    return [
                        vnode,
                        void 0
                    ];
                } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
                    return getChildRoot(childRoot);
                }
                var index = rawChildren.indexOf(childRoot);
                var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
                var setRoot = function(updatedRoot) {
                    rawChildren[index] = updatedRoot;
                    if (dynamicChildren) {
                        if (dynamicIndex > -1) {
                            dynamicChildren[dynamicIndex] = updatedRoot;
                        } else if (updatedRoot.patchFlag > 0) {
                            vnode.dynamicChildren = _to_consumable_array(dynamicChildren).concat([
                                updatedRoot
                            ]);
                        }
                    }
                };
                return [
                    normalizeVNode(childRoot),
                    setRoot
                ];
            };
            function filterSingleRoot(children) {
                var recurse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                var singleRoot;
                for(var i = 0; i < children.length; i++){
                    var child = children[i];
                    if (isVNode(child)) {
                        if (child.type !== Comment || child.children === "v-if") {
                            if (singleRoot) {
                                return;
                            } else {
                                singleRoot = child;
                                if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
                                    return filterSingleRoot(singleRoot.children);
                                }
                            }
                        }
                    } else {
                        return;
                    }
                }
                return singleRoot;
            }
            var getFunctionalFallthrough = function(attrs) {
                var res;
                for(var key in attrs){
                    if (key === "class" || key === "style" || shared.isOn(key)) {
                        (res || (res = {}))[key] = attrs[key];
                    }
                }
                return res;
            };
            var filterModelListeners = function(attrs, props) {
                var res = {};
                for(var key in attrs){
                    if (!shared.isModelListener(key) || !(key.slice(9) in props)) {
                        res[key] = attrs[key];
                    }
                }
                return res;
            };
            var isElementRoot = function(vnode) {
                return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
            };
            function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
                var prevProps = prevVNode.props, prevChildren = prevVNode.children, component = prevVNode.component;
                var nextProps = nextVNode.props, nextChildren = nextVNode.children, patchFlag = nextVNode.patchFlag;
                var emits = component.emitsOptions;
                if ((prevChildren || nextChildren) && isHmrUpdating) {
                    return true;
                }
                if (nextVNode.dirs || nextVNode.transition) {
                    return true;
                }
                if (optimized && patchFlag >= 0) {
                    if (patchFlag & 1024) {
                        return true;
                    }
                    if (patchFlag & 16) {
                        if (!prevProps) {
                            return !!nextProps;
                        }
                        return hasPropsChanged(prevProps, nextProps, emits);
                    } else if (patchFlag & 8) {
                        var dynamicProps = nextVNode.dynamicProps;
                        for(var i = 0; i < dynamicProps.length; i++){
                            var key = dynamicProps[i];
                            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                                return true;
                            }
                        }
                    }
                } else {
                    if (prevChildren || nextChildren) {
                        if (!nextChildren || !nextChildren.$stable) {
                            return true;
                        }
                    }
                    if (prevProps === nextProps) {
                        return false;
                    }
                    if (!prevProps) {
                        return !!nextProps;
                    }
                    if (!nextProps) {
                        return true;
                    }
                    return hasPropsChanged(prevProps, nextProps, emits);
                }
                return false;
            }
            function hasPropsChanged(prevProps, nextProps, emitsOptions) {
                var nextKeys = Object.keys(nextProps);
                if (nextKeys.length !== Object.keys(prevProps).length) {
                    return true;
                }
                for(var i = 0; i < nextKeys.length; i++){
                    var key = nextKeys[i];
                    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
                        return true;
                    }
                }
                return false;
            }
            function updateHOCHostEl(param, el) {
                var vnode = param.vnode, parent = param.parent;
                while(parent){
                    var root = parent.subTree;
                    if (root.suspense && root.suspense.activeBranch === vnode) {
                        root.el = vnode.el;
                    }
                    if (root === vnode) {
                        (vnode = parent.vnode).el = el;
                        parent = parent.parent;
                    } else {
                        break;
                    }
                }
            }
            var isSuspense = function(type) {
                return type.__isSuspense;
            };
            var suspenseId = 0;
            var SuspenseImpl = {
                name: "Suspense",
                // In order to make Suspense tree-shakable, we need to avoid importing it
                // directly in the renderer. The renderer checks for the __isSuspense flag
                // on a vnode's type and calls the `process` method, passing in renderer
                // internals.
                __isSuspense: true,
                process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
                    if (n1 == null) {
                        mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals);
                    } else {
                        if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
                            n2.suspense = n1.suspense;
                            n2.suspense.vnode = n2;
                            n2.el = n1.el;
                            return;
                        }
                        patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, rendererInternals);
                    }
                },
                hydrate: hydrateSuspense,
                normalize: normalizeSuspenseChildren
            };
            var Suspense = SuspenseImpl;
            function triggerEvent(vnode, name) {
                var eventListener = vnode.props && vnode.props[name];
                if (shared.isFunction(eventListener)) {
                    eventListener();
                }
            }
            function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
                var patch = rendererInternals.p, createElement = rendererInternals.o.createElement;
                var hiddenContainer = createElement("div");
                var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals);
                patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds);
                if (suspense.deps > 0) {
                    triggerEvent(vnode, "onPending");
                    triggerEvent(vnode, "onFallback");
                    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    namespace, slotScopeIds);
                    setActiveBranch(suspense, vnode.ssFallback);
                } else {
                    suspense.resolve(false, true);
                }
            }
            function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, param) {
                var patch = param.p, unmount = param.um, createElement = param.o.createElement;
                var suspense = n2.suspense = n1.suspense;
                suspense.vnode = n2;
                n2.el = n1.el;
                var newBranch = n2.ssContent;
                var newFallback = n2.ssFallback;
                var activeBranch = suspense.activeBranch, pendingBranch = suspense.pendingBranch, isInFallback = suspense.isInFallback, isHydrating = suspense.isHydrating;
                if (pendingBranch) {
                    suspense.pendingBranch = newBranch;
                    if (isSameVNodeType(newBranch, pendingBranch)) {
                        patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                        if (suspense.deps <= 0) {
                            suspense.resolve();
                        } else if (isInFallback) {
                            if (!isHydrating) {
                                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                                namespace, slotScopeIds, optimized);
                                setActiveBranch(suspense, newFallback);
                            }
                        }
                    } else {
                        suspense.pendingId = suspenseId++;
                        if (isHydrating) {
                            suspense.isHydrating = false;
                            suspense.activeBranch = pendingBranch;
                        } else {
                            unmount(pendingBranch, parentComponent, suspense);
                        }
                        suspense.deps = 0;
                        suspense.effects.length = 0;
                        suspense.hiddenContainer = createElement("div");
                        if (isInFallback) {
                            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                            if (suspense.deps <= 0) {
                                suspense.resolve();
                            } else {
                                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                                namespace, slotScopeIds, optimized);
                                setActiveBranch(suspense, newFallback);
                            }
                        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
                            suspense.resolve(true);
                        } else {
                            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                            if (suspense.deps <= 0) {
                                suspense.resolve();
                            }
                        }
                    }
                } else {
                    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);
                        setActiveBranch(suspense, newBranch);
                    } else {
                        triggerEvent(n2, "onPending");
                        suspense.pendingBranch = newBranch;
                        if (newBranch.shapeFlag & 512) {
                            suspense.pendingId = newBranch.component.suspenseId;
                        } else {
                            suspense.pendingId = suspenseId++;
                        }
                        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);
                        if (suspense.deps <= 0) {
                            suspense.resolve();
                        } else {
                            var timeout = suspense.timeout, pendingId = suspense.pendingId;
                            if (timeout > 0) {
                                setTimeout(function() {
                                    if (suspense.pendingId === pendingId) {
                                        suspense.fallback(newFallback);
                                    }
                                }, timeout);
                            } else if (timeout === 0) {
                                suspense.fallback(newFallback);
                            }
                        }
                    }
                }
            }
            var hasWarned = false;
            function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals) {
                var isHydrating = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : false;
                if (!hasWarned) {
                    hasWarned = true;
                    console[console.info ? "info" : "log"]("<Suspense> is an experimental feature and its API will likely change.");
                }
                var patch = rendererInternals.p, move = rendererInternals.m, unmount = rendererInternals.um, next = rendererInternals.n, _rendererInternals_o = rendererInternals.o, parentNode = _rendererInternals_o.parentNode, remove = _rendererInternals_o.remove;
                var parentSuspenseId;
                var isSuspensible = isVNodeSuspensible(vnode);
                if (isSuspensible) {
                    if (parentSuspense && parentSuspense.pendingBranch) {
                        parentSuspenseId = parentSuspense.pendingId;
                        parentSuspense.deps++;
                    }
                }
                var timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : void 0;
                {
                    assertNumber(timeout, "Suspense timeout");
                }
                var initialAnchor = anchor;
                var suspense = {
                    vnode: vnode,
                    parent: parentSuspense,
                    parentComponent: parentComponent,
                    namespace: namespace,
                    container: container,
                    hiddenContainer: hiddenContainer,
                    deps: 0,
                    pendingId: suspenseId++,
                    timeout: typeof timeout === "number" ? timeout : -1,
                    activeBranch: null,
                    pendingBranch: null,
                    isInFallback: !isHydrating,
                    isHydrating: isHydrating,
                    isUnmounted: false,
                    effects: [],
                    resolve: function resolve() {
                        var resume = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        {
                            if (!resume && !suspense.pendingBranch) {
                                throw new Error("suspense.resolve() is called without a pending branch.");
                            }
                            if (suspense.isUnmounted) {
                                throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");
                            }
                        }
                        var vnode2 = suspense.vnode, activeBranch = suspense.activeBranch, pendingBranch = suspense.pendingBranch, pendingId = suspense.pendingId, effects = suspense.effects, parentComponent2 = suspense.parentComponent, container2 = suspense.container;
                        var delayEnter = false;
                        if (suspense.isHydrating) {
                            suspense.isHydrating = false;
                        } else if (!resume) {
                            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                            if (delayEnter) {
                                activeBranch.transition.afterLeave = function() {
                                    if (pendingId === suspense.pendingId) {
                                        move(pendingBranch, container2, anchor === initialAnchor ? next(activeBranch) : anchor, 0);
                                        queuePostFlushCb(effects);
                                    }
                                };
                            }
                            if (activeBranch) {
                                if (parentNode(activeBranch.el) === container2) {
                                    anchor = next(activeBranch);
                                }
                                unmount(activeBranch, parentComponent2, suspense, true);
                            }
                            if (!delayEnter) {
                                move(pendingBranch, container2, anchor, 0);
                            }
                        }
                        setActiveBranch(suspense, pendingBranch);
                        suspense.pendingBranch = null;
                        suspense.isInFallback = false;
                        var parent = suspense.parent;
                        var hasUnresolvedAncestor = false;
                        while(parent){
                            if (parent.pendingBranch) {
                                var _parent_effects;
                                (_parent_effects = parent.effects).push.apply(_parent_effects, _to_consumable_array(effects));
                                hasUnresolvedAncestor = true;
                                break;
                            }
                            parent = parent.parent;
                        }
                        if (!hasUnresolvedAncestor && !delayEnter) {
                            queuePostFlushCb(effects);
                        }
                        suspense.effects = [];
                        if (isSuspensible) {
                            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                                parentSuspense.deps--;
                                if (parentSuspense.deps === 0 && !sync) {
                                    parentSuspense.resolve();
                                }
                            }
                        }
                        triggerEvent(vnode2, "onResolve");
                    },
                    fallback: function fallback(fallbackVNode) {
                        if (!suspense.pendingBranch) {
                            return;
                        }
                        var vnode2 = suspense.vnode, activeBranch = suspense.activeBranch, parentComponent2 = suspense.parentComponent, container2 = suspense.container, namespace2 = suspense.namespace;
                        triggerEvent(vnode2, "onFallback");
                        var anchor2 = next(activeBranch);
                        var mountFallback = function() {
                            if (!suspense.isInFallback) {
                                return;
                            }
                            patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                            namespace2, slotScopeIds, optimized);
                            setActiveBranch(suspense, fallbackVNode);
                        };
                        var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
                        if (delayEnter) {
                            activeBranch.transition.afterLeave = mountFallback;
                        }
                        suspense.isInFallback = true;
                        unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
                        true);
                        if (!delayEnter) {
                            mountFallback();
                        }
                    },
                    move: function move1(container2, anchor2, type) {
                        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
                        suspense.container = container2;
                    },
                    next: function next1() {
                        return suspense.activeBranch && next(suspense.activeBranch);
                    },
                    registerDep: function registerDep(instance, setupRenderEffect, optimized2) {
                        var isInPendingSuspense = !!suspense.pendingBranch;
                        if (isInPendingSuspense) {
                            suspense.deps++;
                        }
                        var hydratedEl = instance.vnode.el;
                        instance.asyncDep.catch(function(err) {
                            handleError(err, instance, 0);
                        }).then(function(asyncSetupResult) {
                            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
                                return;
                            }
                            instance.asyncResolved = true;
                            var vnode2 = instance.vnode;
                            {
                                pushWarningContext(vnode2);
                            }
                            handleSetupResult(instance, asyncSetupResult, false);
                            if (hydratedEl) {
                                vnode2.el = hydratedEl;
                            }
                            var placeholder = !hydratedEl && instance.subTree.el;
                            setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                            // if this is not a hydration, instance.subTree will be the comment
                            // placeholder.
                            parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                            // consider the comment placeholder case.
                            hydratedEl ? null : next(instance.subTree), suspense, namespace, optimized2);
                            if (placeholder) {
                                remove(placeholder);
                            }
                            updateHOCHostEl(instance, vnode2.el);
                            {
                                popWarningContext();
                            }
                            if (isInPendingSuspense && --suspense.deps === 0) {
                                suspense.resolve();
                            }
                        });
                    },
                    unmount: function unmount1(parentSuspense2, doRemove) {
                        suspense.isUnmounted = true;
                        if (suspense.activeBranch) {
                            unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
                        }
                        if (suspense.pendingBranch) {
                            unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
                        }
                    }
                };
                return suspense;
            }
            function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
                var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, // eslint-disable-next-line no-restricted-globals
                document.createElement("div"), null, namespace, slotScopeIds, optimized, rendererInternals, true);
                var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
                if (suspense.deps === 0) {
                    suspense.resolve(false, true);
                }
                return result;
            }
            function normalizeSuspenseChildren(vnode) {
                var shapeFlag = vnode.shapeFlag, children = vnode.children;
                var isSlotChildren = shapeFlag & 32;
                vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
                vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
            }
            function normalizeSuspenseSlot(s) {
                var block;
                if (shared.isFunction(s)) {
                    var trackBlock = isBlockTreeEnabled && s._c;
                    if (trackBlock) {
                        s._d = false;
                        openBlock();
                    }
                    s = s();
                    if (trackBlock) {
                        s._d = true;
                        block = currentBlock;
                        closeBlock();
                    }
                }
                if (shared.isArray(s)) {
                    var singleChild = filterSingleRoot(s);
                    if (!singleChild && s.filter(function(child) {
                        return child !== NULL_DYNAMIC_COMPONENT;
                    }).length > 0) {
                        warn$1("<Suspense> slots expect a single root node.");
                    }
                    s = singleChild;
                }
                s = normalizeVNode(s);
                if (block && !s.dynamicChildren) {
                    s.dynamicChildren = block.filter(function(c) {
                        return c !== s;
                    });
                }
                return s;
            }
            function queueEffectWithSuspense(fn, suspense) {
                if (suspense && suspense.pendingBranch) {
                    if (shared.isArray(fn)) {
                        var _suspense_effects;
                        (_suspense_effects = suspense.effects).push.apply(_suspense_effects, _to_consumable_array(fn));
                    } else {
                        suspense.effects.push(fn);
                    }
                } else {
                    queuePostFlushCb(fn);
                }
            }
            function setActiveBranch(suspense, branch) {
                suspense.activeBranch = branch;
                var vnode = suspense.vnode, parentComponent = suspense.parentComponent;
                var el = branch.el;
                while(!el && branch.component){
                    branch = branch.component.subTree;
                    el = branch.el;
                }
                vnode.el = el;
                if (parentComponent && parentComponent.subTree === vnode) {
                    parentComponent.vnode.el = el;
                    updateHOCHostEl(parentComponent, el);
                }
            }
            function isVNodeSuspensible(vnode) {
                var suspensible = vnode.props && vnode.props.suspensible;
                return suspensible != null && suspensible !== false;
            }
            var Fragment = Symbol.for("v-fgt");
            var Text = Symbol.for("v-txt");
            var Comment = Symbol.for("v-cmt");
            var Static = Symbol.for("v-stc");
            var blockStack = [];
            var currentBlock = null;
            function openBlock() {
                var disableTracking = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                blockStack.push(currentBlock = disableTracking ? null : []);
            }
            function closeBlock() {
                blockStack.pop();
                currentBlock = blockStack[blockStack.length - 1] || null;
            }
            var isBlockTreeEnabled = 1;
            function setBlockTracking(value) {
                var inVOnce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                isBlockTreeEnabled += value;
                if (value < 0 && currentBlock && inVOnce) {
                    currentBlock.hasOnce = true;
                }
            }
            function setupBlock(vnode) {
                vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared.EMPTY_ARR : null;
                closeBlock();
                if (isBlockTreeEnabled > 0 && currentBlock) {
                    currentBlock.push(vnode);
                }
                return vnode;
            }
            function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
                return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
            }
            function createBlock(type, props, children, patchFlag, dynamicProps) {
                return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
            }
            function isVNode(value) {
                return value ? value.__v_isVNode === true : false;
            }
            function isSameVNodeType(n1, n2) {
                if (n2.shapeFlag & 6 && n1.component) {
                    var dirtyInstances = hmrDirtyComponents.get(n2.type);
                    if (dirtyInstances && dirtyInstances.has(n1.component)) {
                        n1.shapeFlag &= ~256;
                        n2.shapeFlag &= ~512;
                        return false;
                    }
                }
                return n1.type === n2.type && n1.key === n2.key;
            }
            var vnodeArgsTransformer;
            function transformVNodeArgs(transformer) {
                vnodeArgsTransformer = transformer;
            }
            var createVNodeWithArgsTransform = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return _createVNode.apply(void 0, _to_consumable_array(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
            };
            var normalizeKey = function(param) {
                var key = param.key;
                return key != null ? key : null;
            };
            var normalizeRef = function(param) {
                var ref = param.ref, ref_key = param.ref_key, ref_for = param.ref_for;
                if (typeof ref === "number") {
                    ref = "" + ref;
                }
                return ref != null ? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref) ? {
                    i: currentRenderingInstance,
                    r: ref,
                    k: ref_key,
                    f: !!ref_for
                } : ref : null;
            };
            function createBaseVNode(type) {
                var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, children = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, patchFlag = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, dynamicProps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, shapeFlag = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : type === Fragment ? 0 : 1, isBlockNode = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
                var vnode = {
                    __v_isVNode: true,
                    __v_skip: true,
                    type: type,
                    props: props,
                    key: props && normalizeKey(props),
                    ref: props && normalizeRef(props),
                    scopeId: currentScopeId,
                    slotScopeIds: null,
                    children: children,
                    component: null,
                    suspense: null,
                    ssContent: null,
                    ssFallback: null,
                    dirs: null,
                    transition: null,
                    el: null,
                    anchor: null,
                    target: null,
                    targetStart: null,
                    targetAnchor: null,
                    staticCount: 0,
                    shapeFlag: shapeFlag,
                    patchFlag: patchFlag,
                    dynamicProps: dynamicProps,
                    dynamicChildren: null,
                    appContext: null,
                    ctx: currentRenderingInstance
                };
                if (needFullChildrenNormalization) {
                    normalizeChildren(vnode, children);
                    if (shapeFlag & 128) {
                        type.normalize(vnode);
                    }
                } else if (children) {
                    vnode.shapeFlag |= shared.isString(children) ? 8 : 16;
                }
                if (vnode.key !== vnode.key) {
                    warn$1("VNode created with invalid key (NaN). VNode type:", vnode.type);
                }
                if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
                !isBlockNode && // has current parent block
                currentBlock && // presence of a patch flag indicates this node needs patching on updates.
                // component nodes also should always be patched, because even if the
                // component doesn't need to update, it needs to persist the instance on to
                // the next vnode so that it can be properly unmounted later.
                (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
                // vnode should not be considered dynamic due to handler caching.
                vnode.patchFlag !== 32) {
                    currentBlock.push(vnode);
                }
                return vnode;
            }
            var createVNode = createVNodeWithArgsTransform;
            function _createVNode(type) {
                var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, children = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, patchFlag = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, dynamicProps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, isBlockNode = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
                if (!type || type === NULL_DYNAMIC_COMPONENT) {
                    if (!type) {
                        warn$1("Invalid vnode type when creating vnode: ".concat(type, "."));
                    }
                    type = Comment;
                }
                if (isVNode(type)) {
                    var cloned = cloneVNode(type, props, true);
                    if (children) {
                        normalizeChildren(cloned, children);
                    }
                    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
                        if (cloned.shapeFlag & 6) {
                            currentBlock[currentBlock.indexOf(type)] = cloned;
                        } else {
                            currentBlock.push(cloned);
                        }
                    }
                    cloned.patchFlag = -2;
                    return cloned;
                }
                if (isClassComponent(type)) {
                    type = type.__vccOpts;
                }
                if (props) {
                    props = guardReactiveProps(props);
                    var klass = props.class, style = props.style;
                    if (klass && !shared.isString(klass)) {
                        props.class = shared.normalizeClass(klass);
                    }
                    if (shared.isObject(style)) {
                        if (reactivity.isProxy(style) && !shared.isArray(style)) {
                            style = shared.extend({}, style);
                        }
                        props.style = shared.normalizeStyle(style);
                    }
                }
                var shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;
                if (shapeFlag & 4 && reactivity.isProxy(type)) {
                    type = reactivity.toRaw(type);
                    warn$1("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", "\nComponent that was made reactive: ", type);
                }
                return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
            }
            function guardReactiveProps(props) {
                if (!props) return null;
                return reactivity.isProxy(props) || isInternalObject(props) ? shared.extend({}, props) : props;
            }
            function cloneVNode(vnode, extraProps) {
                var mergeRef = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, cloneTransition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                var props = vnode.props, ref = vnode.ref, patchFlag = vnode.patchFlag, children = vnode.children, transition = vnode.transition;
                var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
                var cloned = {
                    __v_isVNode: true,
                    __v_skip: true,
                    type: vnode.type,
                    props: mergedProps,
                    key: mergedProps && normalizeKey(mergedProps),
                    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                    // if the vnode itself already has a ref, cloneVNode will need to merge
                    // the refs so the single vnode can be set on multiple refs
                    mergeRef && ref ? shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [
                        ref,
                        normalizeRef(extraProps)
                    ] : normalizeRef(extraProps) : ref,
                    scopeId: vnode.scopeId,
                    slotScopeIds: vnode.slotScopeIds,
                    children: patchFlag === -1 && shared.isArray(children) ? children.map(deepCloneVNode) : children,
                    target: vnode.target,
                    targetStart: vnode.targetStart,
                    targetAnchor: vnode.targetAnchor,
                    staticCount: vnode.staticCount,
                    shapeFlag: vnode.shapeFlag,
                    // if the vnode is cloned with extra props, we can no longer assume its
                    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
                    // note: preserve flag for fragments since they use the flag for children
                    // fast paths only.
                    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
                    dynamicProps: vnode.dynamicProps,
                    dynamicChildren: vnode.dynamicChildren,
                    appContext: vnode.appContext,
                    dirs: vnode.dirs,
                    transition: transition,
                    // These should technically only be non-null on mounted VNodes. However,
                    // they *should* be copied for kept-alive vnodes. So we just always copy
                    // them since them being non-null during a mount doesn't affect the logic as
                    // they will simply be overwritten.
                    component: vnode.component,
                    suspense: vnode.suspense,
                    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
                    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
                    el: vnode.el,
                    anchor: vnode.anchor,
                    ctx: vnode.ctx,
                    ce: vnode.ce
                };
                if (transition && cloneTransition) {
                    setTransitionHooks(cloned, transition.clone(cloned));
                }
                return cloned;
            }
            function deepCloneVNode(vnode) {
                var cloned = cloneVNode(vnode);
                if (shared.isArray(vnode.children)) {
                    cloned.children = vnode.children.map(deepCloneVNode);
                }
                return cloned;
            }
            function createTextVNode() {
                var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ", flag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                return createVNode(Text, null, text, flag);
            }
            function createStaticVNode(content, numberOfNodes) {
                var vnode = createVNode(Static, null, content);
                vnode.staticCount = numberOfNodes;
                return vnode;
            }
            function createCommentVNode() {
                var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", asBlock = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
            }
            function normalizeVNode(child) {
                if (child == null || typeof child === "boolean") {
                    return createVNode(Comment);
                } else if (shared.isArray(child)) {
                    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
                    child.slice());
                } else if (isVNode(child)) {
                    return cloneIfMounted(child);
                } else {
                    return createVNode(Text, null, String(child));
                }
            }
            function cloneIfMounted(child) {
                return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
            }
            function normalizeChildren(vnode, children) {
                var type = 0;
                var shapeFlag = vnode.shapeFlag;
                if (children == null) {
                    children = null;
                } else if (shared.isArray(children)) {
                    type = 16;
                } else if ((typeof children === "undefined" ? "undefined" : _type_of(children)) === "object") {
                    if (shapeFlag & (1 | 64)) {
                        var slot = children.default;
                        if (slot) {
                            slot._c && (slot._d = false);
                            normalizeChildren(vnode, slot());
                            slot._c && (slot._d = true);
                        }
                        return;
                    } else {
                        type = 32;
                        var slotFlag = children._;
                        if (!slotFlag && !isInternalObject(children)) {
                            children._ctx = currentRenderingInstance;
                        } else if (slotFlag === 3 && currentRenderingInstance) {
                            if (currentRenderingInstance.slots._ === 1) {
                                children._ = 1;
                            } else {
                                children._ = 2;
                                vnode.patchFlag |= 1024;
                            }
                        }
                    }
                } else if (shared.isFunction(children)) {
                    children = {
                        default: children,
                        _ctx: currentRenderingInstance
                    };
                    type = 32;
                } else {
                    children = String(children);
                    if (shapeFlag & 64) {
                        type = 16;
                        children = [
                            createTextVNode(children)
                        ];
                    } else {
                        type = 8;
                    }
                }
                vnode.children = children;
                vnode.shapeFlag |= type;
            }
            function mergeProps() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var ret = {};
                for(var i = 0; i < args.length; i++){
                    var toMerge = args[i];
                    for(var key in toMerge){
                        if (key === "class") {
                            if (ret.class !== toMerge.class) {
                                ret.class = shared.normalizeClass([
                                    ret.class,
                                    toMerge.class
                                ]);
                            }
                        } else if (key === "style") {
                            ret.style = shared.normalizeStyle([
                                ret.style,
                                toMerge.style
                            ]);
                        } else if (shared.isOn(key)) {
                            var existing = ret[key];
                            var incoming = toMerge[key];
                            if (incoming && existing !== incoming && !(shared.isArray(existing) && existing.includes(incoming))) {
                                ret[key] = existing ? [].concat(existing, incoming) : incoming;
                            }
                        } else if (key !== "") {
                            ret[key] = toMerge[key];
                        }
                    }
                }
                return ret;
            }
            function invokeVNodeHook(hook, instance, vnode) {
                var prevVNode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                callWithAsyncErrorHandling(hook, instance, 7, [
                    vnode,
                    prevVNode
                ]);
            }
            var emptyAppContext = createAppContext();
            var uid = 0;
            function createComponentInstance(vnode, parent, suspense) {
                var type = vnode.type;
                var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
                var instance = {
                    uid: uid++,
                    vnode: vnode,
                    type: type,
                    parent: parent,
                    appContext: appContext,
                    root: null,
                    // to be immediately set
                    next: null,
                    subTree: null,
                    // will be set synchronously right after creation
                    effect: null,
                    update: null,
                    // will be set synchronously right after creation
                    job: null,
                    scope: new reactivity.EffectScope(true),
                    render: null,
                    proxy: null,
                    exposed: null,
                    exposeProxy: null,
                    withProxy: null,
                    provides: parent ? parent.provides : Object.create(appContext.provides),
                    ids: parent ? parent.ids : [
                        "",
                        0,
                        0
                    ],
                    accessCache: null,
                    renderCache: [],
                    // local resolved assets
                    components: null,
                    directives: null,
                    // resolved props and emits options
                    propsOptions: normalizePropsOptions(type, appContext),
                    emitsOptions: normalizeEmitsOptions(type, appContext),
                    // emit
                    emit: null,
                    // to be set immediately
                    emitted: null,
                    // props default value
                    propsDefaults: shared.EMPTY_OBJ,
                    // inheritAttrs
                    inheritAttrs: type.inheritAttrs,
                    // state
                    ctx: shared.EMPTY_OBJ,
                    data: shared.EMPTY_OBJ,
                    props: shared.EMPTY_OBJ,
                    attrs: shared.EMPTY_OBJ,
                    slots: shared.EMPTY_OBJ,
                    refs: shared.EMPTY_OBJ,
                    setupState: shared.EMPTY_OBJ,
                    setupContext: null,
                    // suspense related
                    suspense: suspense,
                    suspenseId: suspense ? suspense.pendingId : 0,
                    asyncDep: null,
                    asyncResolved: false,
                    // lifecycle hooks
                    // not using enums here because it results in computed properties
                    isMounted: false,
                    isUnmounted: false,
                    isDeactivated: false,
                    bc: null,
                    c: null,
                    bm: null,
                    m: null,
                    bu: null,
                    u: null,
                    um: null,
                    bum: null,
                    da: null,
                    a: null,
                    rtg: null,
                    rtc: null,
                    ec: null,
                    sp: null
                };
                {
                    instance.ctx = createDevRenderContext(instance);
                }
                instance.root = parent ? parent.root : instance;
                instance.emit = emit.bind(null, instance);
                if (vnode.ce) {
                    vnode.ce(instance);
                }
                return instance;
            }
            var currentInstance = null;
            var getCurrentInstance = function() {
                return currentInstance || currentRenderingInstance;
            };
            var internalSetCurrentInstance;
            var setInSSRSetupState;
            {
                var g = shared.getGlobalThis();
                var registerGlobalSetter = function(key, setter) {
                    var setters;
                    if (!(setters = g[key])) setters = g[key] = [];
                    setters.push(setter);
                    return function(v1) {
                        if (setters.length > 1) setters.forEach(function(set) {
                            return set(v1);
                        });
                        else setters[0](v1);
                    };
                };
                internalSetCurrentInstance = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", function(v1) {
                    return currentInstance = v1;
                });
                setInSSRSetupState = registerGlobalSetter("__VUE_SSR_SETTERS__", function(v1) {
                    return isInSSRComponentSetup = v1;
                });
            }
            var setCurrentInstance = function(instance) {
                var prev = currentInstance;
                internalSetCurrentInstance(instance);
                instance.scope.on();
                return function() {
                    instance.scope.off();
                    internalSetCurrentInstance(prev);
                };
            };
            var unsetCurrentInstance = function() {
                currentInstance && currentInstance.scope.off();
                internalSetCurrentInstance(null);
            };
            var isBuiltInTag = /* @__PURE__ */ shared.makeMap("slot,component");
            function validateComponentName(name, param) {
                var isNativeTag = param.isNativeTag;
                if (isBuiltInTag(name) || isNativeTag(name)) {
                    warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
                }
            }
            function isStatefulComponent(instance) {
                return instance.vnode.shapeFlag & 4;
            }
            var isInSSRComponentSetup = false;
            function setupComponent(instance) {
                var isSSR = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, optimized = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                isSSR && setInSSRSetupState(isSSR);
                var _instance_vnode = instance.vnode, props = _instance_vnode.props, children = _instance_vnode.children;
                var isStateful = isStatefulComponent(instance);
                initProps(instance, props, isStateful, isSSR);
                initSlots(instance, children, optimized);
                var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
                isSSR && setInSSRSetupState(false);
                return setupResult;
            }
            function setupStatefulComponent(instance, isSSR) {
                var _a;
                var Component = instance.type;
                {
                    if (Component.name) {
                        validateComponentName(Component.name, instance.appContext.config);
                    }
                    if (Component.components) {
                        var names = Object.keys(Component.components);
                        for(var i = 0; i < names.length; i++){
                            validateComponentName(names[i], instance.appContext.config);
                        }
                    }
                    if (Component.directives) {
                        var names1 = Object.keys(Component.directives);
                        for(var i1 = 0; i1 < names1.length; i1++){
                            validateDirectiveName(names1[i1]);
                        }
                    }
                    if (Component.compilerOptions && isRuntimeOnly()) {
                        warn$1('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
                    }
                }
                instance.accessCache = /* @__PURE__ */ Object.create(null);
                instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
                {
                    exposePropsOnRenderContext(instance);
                }
                var setup = Component.setup;
                if (setup) {
                    reactivity.pauseTracking();
                    var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
                    var reset = setCurrentInstance(instance);
                    var setupResult = callWithErrorHandling(setup, instance, 0, [
                        reactivity.shallowReadonly(instance.props),
                        setupContext
                    ]);
                    var isAsyncSetup = shared.isPromise(setupResult);
                    reactivity.resetTracking();
                    reset();
                    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
                        markAsyncBoundary(instance);
                    }
                    if (isAsyncSetup) {
                        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
                        if (isSSR) {
                            return setupResult.then(function(resolvedResult) {
                                handleSetupResult(instance, resolvedResult, isSSR);
                            }).catch(function(e) {
                                handleError(e, instance, 0);
                            });
                        } else {
                            instance.asyncDep = setupResult;
                            if (!instance.suspense) {
                                var name = (_a = Component.name) != null ? _a : "Anonymous";
                                warn$1("Component <".concat(name, ">: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered."));
                            }
                        }
                    } else {
                        handleSetupResult(instance, setupResult, isSSR);
                    }
                } else {
                    finishComponentSetup(instance, isSSR);
                }
            }
            function handleSetupResult(instance, setupResult, isSSR) {
                if (shared.isFunction(setupResult)) {
                    if (instance.type.__ssrInlineRender) {
                        instance.ssrRender = setupResult;
                    } else {
                        instance.render = setupResult;
                    }
                } else if (shared.isObject(setupResult)) {
                    if (isVNode(setupResult)) {
                        warn$1("setup() should not return VNodes directly - return a render function instead.");
                    }
                    {
                        instance.devtoolsRawSetupState = setupResult;
                    }
                    instance.setupState = reactivity.proxyRefs(setupResult);
                    {
                        exposeSetupStateOnRenderContext(instance);
                    }
                } else if (setupResult !== void 0) {
                    warn$1("setup() should return an object. Received: ".concat(setupResult === null ? "null" : typeof setupResult === "undefined" ? "undefined" : _type_of(setupResult)));
                }
                finishComponentSetup(instance, isSSR);
            }
            var compile;
            var installWithProxy;
            function registerRuntimeCompiler(_compile) {
                compile = _compile;
                installWithProxy = function(i) {
                    if (i.render._rc) {
                        i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
                    }
                };
            }
            var isRuntimeOnly = function() {
                return !compile;
            };
            function finishComponentSetup(instance, isSSR, skipOptions) {
                var Component = instance.type;
                if (!instance.render) {
                    if (!isSSR && compile && !Component.render) {
                        var template = Component.template || resolveMergedOptions(instance).template;
                        if (template) {
                            {
                                startMeasure(instance, "compile");
                            }
                            var _instance_appContext_config = instance.appContext.config, isCustomElement = _instance_appContext_config.isCustomElement, compilerOptions = _instance_appContext_config.compilerOptions;
                            var delimiters = Component.delimiters, componentCompilerOptions = Component.compilerOptions;
                            var finalCompilerOptions = shared.extend(shared.extend({
                                isCustomElement: isCustomElement,
                                delimiters: delimiters
                            }, compilerOptions), componentCompilerOptions);
                            Component.render = compile(template, finalCompilerOptions);
                            {
                                endMeasure(instance, "compile");
                            }
                        }
                    }
                    instance.render = Component.render || shared.NOOP;
                    if (installWithProxy) {
                        installWithProxy(instance);
                    }
                }
                {
                    var reset = setCurrentInstance(instance);
                    reactivity.pauseTracking();
                    try {
                        applyOptions(instance);
                    } finally{
                        reactivity.resetTracking();
                        reset();
                    }
                }
                if (!Component.render && instance.render === shared.NOOP && !isSSR) {
                    if (!compile && Component.template) {
                        warn$1("Component provided template option but runtime compilation is not supported in this build of Vue.");
                    } else {
                        warn$1("Component is missing template or render function: ", Component);
                    }
                }
            }
            var attrsProxyHandlers = {
                get: function get(target, key) {
                    markAttrsAccessed();
                    reactivity.track(target, "get", "");
                    return target[key];
                },
                set: function set() {
                    warn$1("setupContext.attrs is readonly.");
                    return false;
                },
                deleteProperty: function deleteProperty() {
                    warn$1("setupContext.attrs is readonly.");
                    return false;
                }
            };
            function getSlotsProxy(instance) {
                return new Proxy(instance.slots, {
                    get: function get(target, key) {
                        reactivity.track(instance, "get", "$slots");
                        return target[key];
                    }
                });
            }
            function createSetupContext(instance) {
                var expose = function(exposed) {
                    {
                        if (instance.exposed) {
                            warn$1("expose() should be called only once per setup().");
                        }
                        if (exposed != null) {
                            var exposedType = typeof exposed === "undefined" ? "undefined" : _type_of(exposed);
                            if (exposedType === "object") {
                                if (shared.isArray(exposed)) {
                                    exposedType = "array";
                                } else if (reactivity.isRef(exposed)) {
                                    exposedType = "ref";
                                }
                            }
                            if (exposedType !== "object") {
                                warn$1("expose() should be passed a plain object, received ".concat(exposedType, "."));
                            }
                        }
                    }
                    instance.exposed = exposed || {};
                };
                {
                    var attrsProxy;
                    var slotsProxy;
                    return Object.freeze({
                        get attrs () {
                            return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
                        },
                        get slots () {
                            return slotsProxy || (slotsProxy = getSlotsProxy(instance));
                        },
                        get emit () {
                            var _instance;
                            return function(event) {
                                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                    args[_key - 1] = arguments[_key];
                                }
                                return (_instance = instance).emit.apply(_instance, [
                                    event
                                ].concat(_to_consumable_array(args)));
                            };
                        },
                        expose: expose
                    });
                }
            }
            function getComponentPublicInstance(instance) {
                if (instance.exposed) {
                    return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {
                        get: function get(target, key) {
                            if (key in target) {
                                return target[key];
                            } else if (key in publicPropertiesMap) {
                                return publicPropertiesMap[key](instance);
                            }
                        },
                        has: function has(target, key) {
                            return key in target || key in publicPropertiesMap;
                        }
                    }));
                } else {
                    return instance.proxy;
                }
            }
            var classifyRE = /(?:^|[-_])(\w)/g;
            var classify = function(str) {
                return str.replace(classifyRE, function(c) {
                    return c.toUpperCase();
                }).replace(/[-_]/g, "");
            };
            function getComponentName(Component) {
                var includeInferred = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
            }
            function formatComponentName(instance, Component) {
                var isRoot = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var name = getComponentName(Component);
                if (!name && Component.__file) {
                    var match = Component.__file.match(/([^/\\]+)\.\w+$/);
                    if (match) {
                        name = match[1];
                    }
                }
                if (!name && instance && instance.parent) {
                    var inferFromRegistry = function(registry) {
                        for(var key in registry){
                            if (registry[key] === Component) {
                                return key;
                            }
                        }
                    };
                    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
                }
                return name ? classify(name) : isRoot ? "App" : "Anonymous";
            }
            function isClassComponent(value) {
                return shared.isFunction(value) && "__vccOpts" in value;
            }
            var computed = function(getterOrOptions, debugOptions) {
                var c = reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
                {
                    var i = getCurrentInstance();
                    if (i && i.appContext.config.warnRecursiveComputed) {
                        c._warnRecursive = true;
                    }
                }
                return c;
            };
            function h(type, propsOrChildren, children) {
                var l = arguments.length;
                if (l === 2) {
                    if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {
                        if (isVNode(propsOrChildren)) {
                            return createVNode(type, null, [
                                propsOrChildren
                            ]);
                        }
                        return createVNode(type, propsOrChildren);
                    } else {
                        return createVNode(type, null, propsOrChildren);
                    }
                } else {
                    if (l > 3) {
                        children = Array.prototype.slice.call(arguments, 2);
                    } else if (l === 3 && isVNode(children)) {
                        children = [
                            children
                        ];
                    }
                    return createVNode(type, propsOrChildren, children);
                }
            }
            function initCustomFormatter() {
                if (typeof window === "undefined") {
                    return;
                }
                var vueStyle = {
                    style: "color:#3ba776"
                };
                var numberStyle = {
                    style: "color:#1677ff"
                };
                var stringStyle = {
                    style: "color:#f5222d"
                };
                var keywordStyle = {
                    style: "color:#eb2f96"
                };
                var formatter = {
                    __vue_custom_formatter: true,
                    header: function header(obj) {
                        if (!shared.isObject(obj)) {
                            return null;
                        }
                        if (obj.__isVue) {
                            return [
                                "div",
                                vueStyle,
                                "VueInstance"
                            ];
                        } else if (reactivity.isRef(obj)) {
                            return [
                                "div",
                                {},
                                [
                                    "span",
                                    vueStyle,
                                    genRefFlag(obj)
                                ],
                                "<",
                                // avoid debugger accessing value affecting behavior
                                formatValue("_value" in obj ? obj._value : obj),
                                ">"
                            ];
                        } else if (reactivity.isReactive(obj)) {
                            return [
                                "div",
                                {},
                                [
                                    "span",
                                    vueStyle,
                                    reactivity.isShallow(obj) ? "ShallowReactive" : "Reactive"
                                ],
                                "<",
                                formatValue(obj),
                                ">".concat(reactivity.isReadonly(obj) ? " (readonly)" : "")
                            ];
                        } else if (reactivity.isReadonly(obj)) {
                            return [
                                "div",
                                {},
                                [
                                    "span",
                                    vueStyle,
                                    reactivity.isShallow(obj) ? "ShallowReadonly" : "Readonly"
                                ],
                                "<",
                                formatValue(obj),
                                ">"
                            ];
                        }
                        return null;
                    },
                    hasBody: function hasBody(obj) {
                        return obj && obj.__isVue;
                    },
                    body: function body(obj) {
                        if (obj && obj.__isVue) {
                            return [
                                "div",
                                {}
                            ].concat(_to_consumable_array(formatInstance(obj.$)));
                        }
                    }
                };
                function formatInstance(instance) {
                    var blocks = [];
                    if (instance.type.props && instance.props) {
                        blocks.push(createInstanceBlock("props", reactivity.toRaw(instance.props)));
                    }
                    if (instance.setupState !== shared.EMPTY_OBJ) {
                        blocks.push(createInstanceBlock("setup", instance.setupState));
                    }
                    if (instance.data !== shared.EMPTY_OBJ) {
                        blocks.push(createInstanceBlock("data", reactivity.toRaw(instance.data)));
                    }
                    var computed2 = extractKeys(instance, "computed");
                    if (computed2) {
                        blocks.push(createInstanceBlock("computed", computed2));
                    }
                    var injected = extractKeys(instance, "inject");
                    if (injected) {
                        blocks.push(createInstanceBlock("injected", injected));
                    }
                    blocks.push([
                        "div",
                        {},
                        [
                            "span",
                            {
                                style: keywordStyle.style + ";opacity:0.66"
                            },
                            "$ (internal): "
                        ],
                        [
                            "object",
                            {
                                object: instance
                            }
                        ]
                    ]);
                    return blocks;
                }
                function createInstanceBlock(type, target) {
                    target = shared.extend({}, target);
                    if (!Object.keys(target).length) {
                        return [
                            "span",
                            {}
                        ];
                    }
                    return [
                        "div",
                        {
                            style: "line-height:1.25em;margin-bottom:0.6em"
                        },
                        [
                            "div",
                            {
                                style: "color:#476582"
                            },
                            type
                        ],
                        [
                            "div",
                            {
                                style: "padding-left:1.25em"
                            }
                        ].concat(_to_consumable_array(Object.keys(target).map(function(key) {
                            return [
                                "div",
                                {},
                                [
                                    "span",
                                    keywordStyle,
                                    key + ": "
                                ],
                                formatValue(target[key], false)
                            ];
                        })))
                    ];
                }
                function formatValue(v1) {
                    var asRaw = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (typeof v1 === "number") {
                        return [
                            "span",
                            numberStyle,
                            v1
                        ];
                    } else if (typeof v1 === "string") {
                        return [
                            "span",
                            stringStyle,
                            JSON.stringify(v1)
                        ];
                    } else if (typeof v1 === "boolean") {
                        return [
                            "span",
                            keywordStyle,
                            v1
                        ];
                    } else if (shared.isObject(v1)) {
                        return [
                            "object",
                            {
                                object: asRaw ? reactivity.toRaw(v1) : v1
                            }
                        ];
                    } else {
                        return [
                            "span",
                            stringStyle,
                            String(v1)
                        ];
                    }
                }
                function extractKeys(instance, type) {
                    var Comp = instance.type;
                    if (shared.isFunction(Comp)) {
                        return;
                    }
                    var extracted = {};
                    for(var key in instance.ctx){
                        if (isKeyOfType(Comp, key, type)) {
                            extracted[key] = instance.ctx[key];
                        }
                    }
                    return extracted;
                }
                function isKeyOfType(Comp, key, type) {
                    var opts = Comp[type];
                    if (shared.isArray(opts) && opts.includes(key) || shared.isObject(opts) && key in opts) {
                        return true;
                    }
                    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
                        return true;
                    }
                    if (Comp.mixins && Comp.mixins.some(function(m) {
                        return isKeyOfType(m, key, type);
                    })) {
                        return true;
                    }
                }
                function genRefFlag(v1) {
                    if (reactivity.isShallow(v1)) {
                        return "ShallowRef";
                    }
                    if (v1.effect) {
                        return "ComputedRef";
                    }
                    return "Ref";
                }
                if (window.devtoolsFormatters) {
                    window.devtoolsFormatters.push(formatter);
                } else {
                    window.devtoolsFormatters = [
                        formatter
                    ];
                }
            }
            function withMemo(memo, render, cache, index) {
                var cached = cache[index];
                if (cached && isMemoSame(cached, memo)) {
                    return cached;
                }
                var ret = render();
                ret.memo = memo.slice();
                ret.cacheIndex = index;
                return cache[index] = ret;
            }
            function isMemoSame(cached, memo) {
                var prev = cached.memo;
                if (prev.length != memo.length) {
                    return false;
                }
                for(var i = 0; i < prev.length; i++){
                    if (shared.hasChanged(prev[i], memo[i])) {
                        return false;
                    }
                }
                if (isBlockTreeEnabled > 0 && currentBlock) {
                    currentBlock.push(cached);
                }
                return true;
            }
            var version = "3.5.13";
            var warn = warn$1;
            var ErrorTypeStrings = ErrorTypeStrings$1;
            var devtools = devtools$1;
            var setDevtoolsHook = setDevtoolsHook$1;
            var _ssrUtils = {
                createComponentInstance: createComponentInstance,
                setupComponent: setupComponent,
                renderComponentRoot: renderComponentRoot,
                setCurrentRenderingInstance: setCurrentRenderingInstance,
                isVNode: isVNode,
                normalizeVNode: normalizeVNode,
                getComponentPublicInstance: getComponentPublicInstance,
                ensureValidVNode: ensureValidVNode,
                pushWarningContext: pushWarningContext,
                popWarningContext: popWarningContext
            };
            var ssrUtils = _ssrUtils;
            var resolveFilter = null;
            var compatUtils = null;
            var DeprecationTypes = null;
            exports.EffectScope = reactivity.EffectScope;
            exports.ReactiveEffect = reactivity.ReactiveEffect;
            exports.TrackOpTypes = reactivity.TrackOpTypes;
            exports.TriggerOpTypes = reactivity.TriggerOpTypes;
            exports.customRef = reactivity.customRef;
            exports.effect = reactivity.effect;
            exports.effectScope = reactivity.effectScope;
            exports.getCurrentScope = reactivity.getCurrentScope;
            exports.getCurrentWatcher = reactivity.getCurrentWatcher;
            exports.isProxy = reactivity.isProxy;
            exports.isReactive = reactivity.isReactive;
            exports.isReadonly = reactivity.isReadonly;
            exports.isRef = reactivity.isRef;
            exports.isShallow = reactivity.isShallow;
            exports.markRaw = reactivity.markRaw;
            exports.onScopeDispose = reactivity.onScopeDispose;
            exports.onWatcherCleanup = reactivity.onWatcherCleanup;
            exports.proxyRefs = reactivity.proxyRefs;
            exports.reactive = reactivity.reactive;
            exports.readonly = reactivity.readonly;
            exports.ref = reactivity.ref;
            exports.shallowReactive = reactivity.shallowReactive;
            exports.shallowReadonly = reactivity.shallowReadonly;
            exports.shallowRef = reactivity.shallowRef;
            exports.stop = reactivity.stop;
            exports.toRaw = reactivity.toRaw;
            exports.toRef = reactivity.toRef;
            exports.toRefs = reactivity.toRefs;
            exports.toValue = reactivity.toValue;
            exports.triggerRef = reactivity.triggerRef;
            exports.unref = reactivity.unref;
            exports.camelize = shared.camelize;
            exports.capitalize = shared.capitalize;
            exports.normalizeClass = shared.normalizeClass;
            exports.normalizeProps = shared.normalizeProps;
            exports.normalizeStyle = shared.normalizeStyle;
            exports.toDisplayString = shared.toDisplayString;
            exports.toHandlerKey = shared.toHandlerKey;
            exports.BaseTransition = BaseTransition;
            exports.BaseTransitionPropsValidators = BaseTransitionPropsValidators;
            exports.Comment = Comment;
            exports.DeprecationTypes = DeprecationTypes;
            exports.ErrorCodes = ErrorCodes;
            exports.ErrorTypeStrings = ErrorTypeStrings;
            exports.Fragment = Fragment;
            exports.KeepAlive = KeepAlive;
            exports.Static = Static;
            exports.Suspense = Suspense;
            exports.Teleport = Teleport;
            exports.Text = Text;
            exports.assertNumber = assertNumber;
            exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;
            exports.callWithErrorHandling = callWithErrorHandling;
            exports.cloneVNode = cloneVNode;
            exports.compatUtils = compatUtils;
            exports.computed = computed;
            exports.createBlock = createBlock;
            exports.createCommentVNode = createCommentVNode;
            exports.createElementBlock = createElementBlock;
            exports.createElementVNode = createBaseVNode;
            exports.createHydrationRenderer = createHydrationRenderer;
            exports.createPropsRestProxy = createPropsRestProxy;
            exports.createRenderer = createRenderer;
            exports.createSlots = createSlots;
            exports.createStaticVNode = createStaticVNode;
            exports.createTextVNode = createTextVNode;
            exports.createVNode = createVNode;
            exports.defineAsyncComponent = defineAsyncComponent;
            exports.defineComponent = defineComponent;
            exports.defineEmits = defineEmits;
            exports.defineExpose = defineExpose;
            exports.defineModel = defineModel;
            exports.defineOptions = defineOptions;
            exports.defineProps = defineProps;
            exports.defineSlots = defineSlots;
            exports.devtools = devtools;
            exports.getCurrentInstance = getCurrentInstance;
            exports.getTransitionRawChildren = getTransitionRawChildren;
            exports.guardReactiveProps = guardReactiveProps;
            exports.h = h;
            exports.handleError = handleError;
            exports.hasInjectionContext = hasInjectionContext;
            exports.hydrateOnIdle = hydrateOnIdle;
            exports.hydrateOnInteraction = hydrateOnInteraction;
            exports.hydrateOnMediaQuery = hydrateOnMediaQuery;
            exports.hydrateOnVisible = hydrateOnVisible;
            exports.initCustomFormatter = initCustomFormatter;
            exports.inject = inject;
            exports.isMemoSame = isMemoSame;
            exports.isRuntimeOnly = isRuntimeOnly;
            exports.isVNode = isVNode;
            exports.mergeDefaults = mergeDefaults;
            exports.mergeModels = mergeModels;
            exports.mergeProps = mergeProps;
            exports.nextTick = nextTick;
            exports.onActivated = onActivated;
            exports.onBeforeMount = onBeforeMount;
            exports.onBeforeUnmount = onBeforeUnmount;
            exports.onBeforeUpdate = onBeforeUpdate;
            exports.onDeactivated = onDeactivated;
            exports.onErrorCaptured = onErrorCaptured;
            exports.onMounted = onMounted;
            exports.onRenderTracked = onRenderTracked;
            exports.onRenderTriggered = onRenderTriggered;
            exports.onServerPrefetch = onServerPrefetch;
            exports.onUnmounted = onUnmounted;
            exports.onUpdated = onUpdated;
            exports.openBlock = openBlock;
            exports.popScopeId = popScopeId;
            exports.provide = provide;
            exports.pushScopeId = pushScopeId;
            exports.queuePostFlushCb = queuePostFlushCb;
            exports.registerRuntimeCompiler = registerRuntimeCompiler;
            exports.renderList = renderList;
            exports.renderSlot = renderSlot;
            exports.resolveComponent = resolveComponent;
            exports.resolveDirective = resolveDirective;
            exports.resolveDynamicComponent = resolveDynamicComponent;
            exports.resolveFilter = resolveFilter;
            exports.resolveTransitionHooks = resolveTransitionHooks;
            exports.setBlockTracking = setBlockTracking;
            exports.setDevtoolsHook = setDevtoolsHook;
            exports.setTransitionHooks = setTransitionHooks;
            exports.ssrContextKey = ssrContextKey;
            exports.ssrUtils = ssrUtils;
            exports.toHandlers = toHandlers;
            exports.transformVNodeArgs = transformVNodeArgs;
            exports.useAttrs = useAttrs;
            exports.useId = useId;
            exports.useModel = useModel;
            exports.useSSRContext = useSSRContext;
            exports.useSlots = useSlots;
            exports.useTemplateRef = useTemplateRef;
            exports.useTransitionState = useTransitionState;
            exports.version = version;
            exports.warn = warn;
            exports.watch = watch;
            exports.watchEffect = watchEffect;
            exports.watchPostEffect = watchPostEffect;
            exports.watchSyncEffect = watchSyncEffect;
            exports.withAsyncContext = withAsyncContext;
            exports.withCtx = withCtx;
            exports.withDefaults = withDefaults;
            exports.withDirectives = withDirectives;
            exports.withMemo = withMemo;
            exports.withScopeId = withScopeId;
        }
    });
    // ../../node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/index.js
    var require_runtime_core = __commonJS({
        "../../node_modules/.pnpm/@vue+runtime-core@3.5.13/node_modules/@vue/runtime-core/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_runtime_core_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/@vue+runtime-dom@3.5.13/node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js
    var require_runtime_dom_cjs = __commonJS({
        "../../node_modules/.pnpm/@vue+runtime-dom@3.5.13/node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var runtimeCore = require_runtime_core();
            var shared = require_shared();
            var policy = void 0;
            var tt = typeof window !== "undefined" && window.trustedTypes;
            if (tt) {
                try {
                    policy = /* @__PURE__ */ tt.createPolicy("vue", {
                        createHTML: function(val) {
                            return val;
                        }
                    });
                } catch (e) {
                    runtimeCore.warn("Error creating trusted types policy: ".concat(e));
                }
            }
            var unsafeToTrustedHTML = policy ? function(val) {
                return policy.createHTML(val);
            } : function(val) {
                return val;
            };
            var svgNS = "http://www.w3.org/2000/svg";
            var mathmlNS = "http://www.w3.org/1998/Math/MathML";
            var doc = typeof document !== "undefined" ? document : null;
            var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
            var nodeOps = {
                insert: function(child, parent, anchor) {
                    parent.insertBefore(child, anchor || null);
                },
                remove: function(child) {
                    var parent = child.parentNode;
                    if (parent) {
                        parent.removeChild(child);
                    }
                },
                createElement: function(tag, namespace, is, props) {
                    var el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, {
                        is: is
                    }) : doc.createElement(tag);
                    if (tag === "select" && props && props.multiple != null) {
                        el.setAttribute("multiple", props.multiple);
                    }
                    return el;
                },
                createText: function(text) {
                    return doc.createTextNode(text);
                },
                createComment: function(text) {
                    return doc.createComment(text);
                },
                setText: function(node, text) {
                    node.nodeValue = text;
                },
                setElementText: function(el, text) {
                    el.textContent = text;
                },
                parentNode: function(node) {
                    return node.parentNode;
                },
                nextSibling: function(node) {
                    return node.nextSibling;
                },
                querySelector: function(selector) {
                    return doc.querySelector(selector);
                },
                setScopeId: function setScopeId(el, id) {
                    el.setAttribute(id, "");
                },
                // __UNSAFE__
                // Reason: innerHTML.
                // Static content here can only come from compiled templates.
                // As long as the user only uses trusted templates, this is safe.
                insertStaticContent: function insertStaticContent(content, parent, anchor, namespace, start, end) {
                    var before = anchor ? anchor.previousSibling : parent.lastChild;
                    if (start && (start === end || start.nextSibling)) {
                        while(true){
                            parent.insertBefore(start.cloneNode(true), anchor);
                            if (start === end || !(start = start.nextSibling)) break;
                        }
                    } else {
                        templateContainer.innerHTML = unsafeToTrustedHTML(namespace === "svg" ? "<svg>".concat(content, "</svg>") : namespace === "mathml" ? "<math>".concat(content, "</math>") : content);
                        var template = templateContainer.content;
                        if (namespace === "svg" || namespace === "mathml") {
                            var wrapper = template.firstChild;
                            while(wrapper.firstChild){
                                template.appendChild(wrapper.firstChild);
                            }
                            template.removeChild(wrapper);
                        }
                        parent.insertBefore(template, anchor);
                    }
                    return [
                        // first
                        before ? before.nextSibling : parent.firstChild,
                        // last
                        anchor ? anchor.previousSibling : parent.lastChild
                    ];
                }
            };
            var TRANSITION = "transition";
            var ANIMATION = "animation";
            var vtcKey = Symbol("_vtc");
            var DOMTransitionPropsValidators = {
                name: String,
                type: String,
                css: {
                    type: Boolean,
                    default: true
                },
                duration: [
                    String,
                    Number,
                    Object
                ],
                enterFromClass: String,
                enterActiveClass: String,
                enterToClass: String,
                appearFromClass: String,
                appearActiveClass: String,
                appearToClass: String,
                leaveFromClass: String,
                leaveActiveClass: String,
                leaveToClass: String
            };
            var TransitionPropsValidators = /* @__PURE__ */ shared.extend({}, runtimeCore.BaseTransitionPropsValidators, DOMTransitionPropsValidators);
            var decorate$1 = function(t) {
                t.displayName = "Transition";
                t.props = TransitionPropsValidators;
                return t;
            };
            var Transition = /* @__PURE__ */ decorate$1(function(props, param) {
                var slots = param.slots;
                return runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);
            });
            var callHook = function(hook) {
                var args = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                if (shared.isArray(hook)) {
                    hook.forEach(function(h2) {
                        return h2.apply(void 0, _to_consumable_array(args));
                    });
                } else if (hook) {
                    hook.apply(void 0, _to_consumable_array(args));
                }
            };
            var hasExplicitCallback = function(hook) {
                return hook ? shared.isArray(hook) ? hook.some(function(h2) {
                    return h2.length > 1;
                }) : hook.length > 1 : false;
            };
            function resolveTransitionProps(rawProps) {
                var baseProps = {};
                for(var key in rawProps){
                    if (!(key in DOMTransitionPropsValidators)) {
                        baseProps[key] = rawProps[key];
                    }
                }
                if (rawProps.css === false) {
                    return baseProps;
                }
                var _rawProps_name = rawProps.name, name = _rawProps_name === void 0 ? "v" : _rawProps_name, type = rawProps.type, duration = rawProps.duration, _rawProps_enterFromClass = rawProps.enterFromClass, enterFromClass = _rawProps_enterFromClass === void 0 ? "".concat(name, "-enter-from") : _rawProps_enterFromClass, _rawProps_enterActiveClass = rawProps.enterActiveClass, enterActiveClass = _rawProps_enterActiveClass === void 0 ? "".concat(name, "-enter-active") : _rawProps_enterActiveClass, _rawProps_enterToClass = rawProps.enterToClass, enterToClass = _rawProps_enterToClass === void 0 ? "".concat(name, "-enter-to") : _rawProps_enterToClass, _rawProps_appearFromClass = rawProps.appearFromClass, appearFromClass = _rawProps_appearFromClass === void 0 ? enterFromClass : _rawProps_appearFromClass, _rawProps_appearActiveClass = rawProps.appearActiveClass, appearActiveClass = _rawProps_appearActiveClass === void 0 ? enterActiveClass : _rawProps_appearActiveClass, _rawProps_appearToClass = rawProps.appearToClass, appearToClass = _rawProps_appearToClass === void 0 ? enterToClass : _rawProps_appearToClass, _rawProps_leaveFromClass = rawProps.leaveFromClass, leaveFromClass = _rawProps_leaveFromClass === void 0 ? "".concat(name, "-leave-from") : _rawProps_leaveFromClass, _rawProps_leaveActiveClass = rawProps.leaveActiveClass, leaveActiveClass = _rawProps_leaveActiveClass === void 0 ? "".concat(name, "-leave-active") : _rawProps_leaveActiveClass, _rawProps_leaveToClass = rawProps.leaveToClass, leaveToClass = _rawProps_leaveToClass === void 0 ? "".concat(name, "-leave-to") : _rawProps_leaveToClass;
                var durations = normalizeDuration(duration);
                var enterDuration = durations && durations[0];
                var leaveDuration = durations && durations[1];
                var onBeforeEnter = baseProps.onBeforeEnter, onEnter = baseProps.onEnter, onEnterCancelled = baseProps.onEnterCancelled, onLeave = baseProps.onLeave, onLeaveCancelled = baseProps.onLeaveCancelled, _baseProps_onBeforeAppear = baseProps.onBeforeAppear, onBeforeAppear = _baseProps_onBeforeAppear === void 0 ? onBeforeEnter : _baseProps_onBeforeAppear, _baseProps_onAppear = baseProps.onAppear, onAppear = _baseProps_onAppear === void 0 ? onEnter : _baseProps_onAppear, _baseProps_onAppearCancelled = baseProps.onAppearCancelled, onAppearCancelled = _baseProps_onAppearCancelled === void 0 ? onEnterCancelled : _baseProps_onAppearCancelled;
                var finishEnter = function(el, isAppear, done, isCancelled) {
                    el._enterCancelled = isCancelled;
                    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
                    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
                    done && done();
                };
                var finishLeave = function(el, done) {
                    el._isLeaving = false;
                    removeTransitionClass(el, leaveFromClass);
                    removeTransitionClass(el, leaveToClass);
                    removeTransitionClass(el, leaveActiveClass);
                    done && done();
                };
                var makeEnterHook = function(isAppear) {
                    return function(el, done) {
                        var hook = isAppear ? onAppear : onEnter;
                        var resolve = function() {
                            return finishEnter(el, isAppear, done);
                        };
                        callHook(hook, [
                            el,
                            resolve
                        ]);
                        nextFrame(function() {
                            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                            if (!hasExplicitCallback(hook)) {
                                whenTransitionEnds(el, type, enterDuration, resolve);
                            }
                        });
                    };
                };
                return shared.extend(baseProps, {
                    onBeforeEnter: function onBeforeEnter1(el) {
                        callHook(onBeforeEnter, [
                            el
                        ]);
                        addTransitionClass(el, enterFromClass);
                        addTransitionClass(el, enterActiveClass);
                    },
                    onBeforeAppear: function onBeforeAppear1(el) {
                        callHook(onBeforeAppear, [
                            el
                        ]);
                        addTransitionClass(el, appearFromClass);
                        addTransitionClass(el, appearActiveClass);
                    },
                    onEnter: makeEnterHook(false),
                    onAppear: makeEnterHook(true),
                    onLeave: function onLeave1(el, done) {
                        el._isLeaving = true;
                        var resolve = function() {
                            return finishLeave(el, done);
                        };
                        addTransitionClass(el, leaveFromClass);
                        if (!el._enterCancelled) {
                            forceReflow();
                            addTransitionClass(el, leaveActiveClass);
                        } else {
                            addTransitionClass(el, leaveActiveClass);
                            forceReflow();
                        }
                        nextFrame(function() {
                            if (!el._isLeaving) {
                                return;
                            }
                            removeTransitionClass(el, leaveFromClass);
                            addTransitionClass(el, leaveToClass);
                            if (!hasExplicitCallback(onLeave)) {
                                whenTransitionEnds(el, type, leaveDuration, resolve);
                            }
                        });
                        callHook(onLeave, [
                            el,
                            resolve
                        ]);
                    },
                    onEnterCancelled: function onEnterCancelled1(el) {
                        finishEnter(el, false, void 0, true);
                        callHook(onEnterCancelled, [
                            el
                        ]);
                    },
                    onAppearCancelled: function onAppearCancelled1(el) {
                        finishEnter(el, true, void 0, true);
                        callHook(onAppearCancelled, [
                            el
                        ]);
                    },
                    onLeaveCancelled: function onLeaveCancelled1(el) {
                        finishLeave(el);
                        callHook(onLeaveCancelled, [
                            el
                        ]);
                    }
                });
            }
            function normalizeDuration(duration) {
                if (duration == null) {
                    return null;
                } else if (shared.isObject(duration)) {
                    return [
                        NumberOf(duration.enter),
                        NumberOf(duration.leave)
                    ];
                } else {
                    var n = NumberOf(duration);
                    return [
                        n,
                        n
                    ];
                }
            }
            function NumberOf(val) {
                var res = shared.toNumber(val);
                {
                    runtimeCore.assertNumber(res, "<transition> explicit duration");
                }
                return res;
            }
            function addTransitionClass(el, cls) {
                cls.split(/\s+/).forEach(function(c) {
                    return c && el.classList.add(c);
                });
                (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
            }
            function removeTransitionClass(el, cls) {
                cls.split(/\s+/).forEach(function(c) {
                    return c && el.classList.remove(c);
                });
                var _vtc = el[vtcKey];
                if (_vtc) {
                    _vtc.delete(cls);
                    if (!_vtc.size) {
                        el[vtcKey] = void 0;
                    }
                }
            }
            function nextFrame(cb) {
                requestAnimationFrame(function() {
                    requestAnimationFrame(cb);
                });
            }
            var endId = 0;
            function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
                var id = el._endId = ++endId;
                var resolveIfNotStale = function() {
                    if (id === el._endId) {
                        resolve();
                    }
                };
                if (explicitTimeout != null) {
                    return setTimeout(resolveIfNotStale, explicitTimeout);
                }
                var _getTransitionInfo = getTransitionInfo(el, expectedType), type = _getTransitionInfo.type, timeout = _getTransitionInfo.timeout, propCount = _getTransitionInfo.propCount;
                if (!type) {
                    return resolve();
                }
                var endEvent = type + "end";
                var ended = 0;
                var end = function() {
                    el.removeEventListener(endEvent, onEnd);
                    resolveIfNotStale();
                };
                var onEnd = function(e) {
                    if (e.target === el && ++ended >= propCount) {
                        end();
                    }
                };
                setTimeout(function() {
                    if (ended < propCount) {
                        end();
                    }
                }, timeout + 1);
                el.addEventListener(endEvent, onEnd);
            }
            function getTransitionInfo(el, expectedType) {
                var styles = window.getComputedStyle(el);
                var getStyleProperties = function(key) {
                    return (styles[key] || "").split(", ");
                };
                var transitionDelays = getStyleProperties("".concat(TRANSITION, "Delay"));
                var transitionDurations = getStyleProperties("".concat(TRANSITION, "Duration"));
                var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
                var animationDelays = getStyleProperties("".concat(ANIMATION, "Delay"));
                var animationDurations = getStyleProperties("".concat(ANIMATION, "Duration"));
                var animationTimeout = getTimeout(animationDelays, animationDurations);
                var type = null;
                var timeout = 0;
                var propCount = 0;
                if (expectedType === TRANSITION) {
                    if (transitionTimeout > 0) {
                        type = TRANSITION;
                        timeout = transitionTimeout;
                        propCount = transitionDurations.length;
                    }
                } else if (expectedType === ANIMATION) {
                    if (animationTimeout > 0) {
                        type = ANIMATION;
                        timeout = animationTimeout;
                        propCount = animationDurations.length;
                    }
                } else {
                    timeout = Math.max(transitionTimeout, animationTimeout);
                    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
                    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
                }
                var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties("".concat(TRANSITION, "Property")).toString());
                return {
                    type: type,
                    timeout: timeout,
                    propCount: propCount,
                    hasTransform: hasTransform
                };
            }
            function getTimeout(delays, durations) {
                var _Math;
                while(delays.length < durations.length){
                    delays = delays.concat(delays);
                }
                return (_Math = Math).max.apply(_Math, _to_consumable_array(durations.map(function(d, i) {
                    return toMs(d) + toMs(delays[i]);
                })));
            }
            function toMs(s) {
                if (s === "auto") return 0;
                return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
            }
            function forceReflow() {
                return document.body.offsetHeight;
            }
            function patchClass(el, value, isSVG) {
                var transitionClasses = el[vtcKey];
                if (transitionClasses) {
                    value = (value ? [
                        value
                    ].concat(_to_consumable_array(transitionClasses)) : _to_consumable_array(transitionClasses)).join(" ");
                }
                if (value == null) {
                    el.removeAttribute("class");
                } else if (isSVG) {
                    el.setAttribute("class", value);
                } else {
                    el.className = value;
                }
            }
            var vShowOriginalDisplay = Symbol("_vod");
            var vShowHidden = Symbol("_vsh");
            var vShow = {
                beforeMount: function beforeMount(el, param, param1) {
                    var value = param.value, transition = param1.transition;
                    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
                    if (transition && value) {
                        transition.beforeEnter(el);
                    } else {
                        setDisplay(el, value);
                    }
                },
                mounted: function mounted(el, param, param1) {
                    var value = param.value, transition = param1.transition;
                    if (transition && value) {
                        transition.enter(el);
                    }
                },
                updated: function updated(el, param, param1) {
                    var value = param.value, oldValue = param.oldValue, transition = param1.transition;
                    if (!value === !oldValue) return;
                    if (transition) {
                        if (value) {
                            transition.beforeEnter(el);
                            setDisplay(el, true);
                            transition.enter(el);
                        } else {
                            transition.leave(el, function() {
                                setDisplay(el, false);
                            });
                        }
                    } else {
                        setDisplay(el, value);
                    }
                },
                beforeUnmount: function beforeUnmount(el, param) {
                    var value = param.value;
                    setDisplay(el, value);
                }
            };
            {
                vShow.name = "show";
            }
            function setDisplay(el, value) {
                el.style.display = value ? el[vShowOriginalDisplay] : "none";
                el[vShowHidden] = !value;
            }
            function initVShowForSSR() {
                vShow.getSSRProps = function(param) {
                    var value = param.value;
                    if (!value) {
                        return {
                            style: {
                                display: "none"
                            }
                        };
                    }
                };
            }
            var CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
            function useCssVars(getter) {
                return;
            }
            var displayRE = /(^|;)\s*display\s*:/;
            function patchStyle(el, prev, next) {
                var style = el.style;
                var isCssString = shared.isString(next);
                var hasControlledDisplay = false;
                if (next && !isCssString) {
                    if (prev) {
                        if (!shared.isString(prev)) {
                            for(var key in prev){
                                if (next[key] == null) {
                                    setStyle(style, key, "");
                                }
                            }
                        } else {
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = prev.split(";")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var prevStyle = _step.value;
                                    var key1 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                                    if (next[key1] == null) {
                                        setStyle(style, key1, "");
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                    for(var key2 in next){
                        if (key2 === "display") {
                            hasControlledDisplay = true;
                        }
                        setStyle(style, key2, next[key2]);
                    }
                } else {
                    if (isCssString) {
                        if (prev !== next) {
                            var cssVarText = style[CSS_VAR_TEXT];
                            if (cssVarText) {
                                next += ";" + cssVarText;
                            }
                            style.cssText = next;
                            hasControlledDisplay = displayRE.test(next);
                        }
                    } else if (prev) {
                        el.removeAttribute("style");
                    }
                }
                if (vShowOriginalDisplay in el) {
                    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
                    if (el[vShowHidden]) {
                        style.display = "none";
                    }
                }
            }
            var semicolonRE = /[^\\];\s*$/;
            var importantRE = /\s*!important$/;
            function setStyle(style, name, val) {
                if (shared.isArray(val)) {
                    val.forEach(function(v1) {
                        return setStyle(style, name, v1);
                    });
                } else {
                    if (val == null) val = "";
                    {
                        if (semicolonRE.test(val)) {
                            runtimeCore.warn("Unexpected semicolon at the end of '".concat(name, "' style value: '").concat(val, "'"));
                        }
                    }
                    if (name.startsWith("--")) {
                        style.setProperty(name, val);
                    } else {
                        var prefixed = autoPrefix(style, name);
                        if (importantRE.test(val)) {
                            style.setProperty(shared.hyphenate(prefixed), val.replace(importantRE, ""), "important");
                        } else {
                            style[prefixed] = val;
                        }
                    }
                }
            }
            var prefixes = [
                "Webkit",
                "Moz",
                "ms"
            ];
            var prefixCache = {};
            function autoPrefix(style, rawName) {
                var cached = prefixCache[rawName];
                if (cached) {
                    return cached;
                }
                var name = runtimeCore.camelize(rawName);
                if (name !== "filter" && name in style) {
                    return prefixCache[rawName] = name;
                }
                name = shared.capitalize(name);
                for(var i = 0; i < prefixes.length; i++){
                    var prefixed = prefixes[i] + name;
                    if (prefixed in style) {
                        return prefixCache[rawName] = prefixed;
                    }
                }
                return rawName;
            }
            var xlinkNS = "http://www.w3.org/1999/xlink";
            function patchAttr(el, key, value, isSVG, instance) {
                var isBoolean = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : shared.isSpecialBooleanAttr(key);
                if (isSVG && key.startsWith("xlink:")) {
                    if (value == null) {
                        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
                    } else {
                        el.setAttributeNS(xlinkNS, key, value);
                    }
                } else {
                    if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {
                        el.removeAttribute(key);
                    } else {
                        el.setAttribute(key, isBoolean ? "" : shared.isSymbol(value) ? String(value) : value);
                    }
                }
            }
            function patchDOMProp(el, key, value, parentComponent, attrName) {
                if (key === "innerHTML" || key === "textContent") {
                    if (value != null) {
                        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
                    }
                    return;
                }
                var tag = el.tagName;
                if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
                !tag.includes("-")) {
                    var oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
                    var newValue = value == null ? // #11647: value should be set as empty string for null and undefined,
                    // but <input type="checkbox"> should be set as 'on'.
                    el.type === "checkbox" ? "on" : "" : String(value);
                    if (oldValue !== newValue || !("_value" in el)) {
                        el.value = newValue;
                    }
                    if (value == null) {
                        el.removeAttribute(key);
                    }
                    el._value = value;
                    return;
                }
                var needRemove = false;
                if (value === "" || value == null) {
                    var type = _type_of(el[key]);
                    if (type === "boolean") {
                        value = shared.includeBooleanAttr(value);
                    } else if (value == null && type === "string") {
                        value = "";
                        needRemove = true;
                    } else if (type === "number") {
                        value = 0;
                        needRemove = true;
                    }
                }
                try {
                    el[key] = value;
                } catch (e) {
                    if (!needRemove) {
                        runtimeCore.warn('Failed setting prop "'.concat(key, '" on <').concat(tag.toLowerCase(), ">: value ").concat(value, " is invalid."), e);
                    }
                }
                needRemove && el.removeAttribute(attrName || key);
            }
            function addEventListener(el, event, handler, options) {
                el.addEventListener(event, handler, options);
            }
            function removeEventListener(el, event, handler, options) {
                el.removeEventListener(event, handler, options);
            }
            var veiKey = Symbol("_vei");
            function patchEvent(el, rawName, prevValue, nextValue) {
                var instance = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
                var invokers = el[veiKey] || (el[veiKey] = {});
                var existingInvoker = invokers[rawName];
                if (nextValue && existingInvoker) {
                    existingInvoker.value = sanitizeEventValue(nextValue, rawName);
                } else {
                    var _parseName = _sliced_to_array(parseName(rawName), 2), name = _parseName[0], options = _parseName[1];
                    if (nextValue) {
                        var invoker = invokers[rawName] = createInvoker(sanitizeEventValue(nextValue, rawName), instance);
                        addEventListener(el, name, invoker, options);
                    } else if (existingInvoker) {
                        removeEventListener(el, name, existingInvoker, options);
                        invokers[rawName] = void 0;
                    }
                }
            }
            var optionsModifierRE = /(?:Once|Passive|Capture)$/;
            function parseName(name) {
                var options;
                if (optionsModifierRE.test(name)) {
                    options = {};
                    var m;
                    while(m = name.match(optionsModifierRE)){
                        name = name.slice(0, name.length - m[0].length);
                        options[m[0].toLowerCase()] = true;
                    }
                }
                var event = name[2] === ":" ? name.slice(3) : shared.hyphenate(name.slice(2));
                return [
                    event,
                    options
                ];
            }
            var cachedNow = 0;
            var p = /* @__PURE__ */ Promise.resolve();
            var getNow = function() {
                return cachedNow || (p.then(function() {
                    return cachedNow = 0;
                }), cachedNow = Date.now());
            };
            function createInvoker(initialValue, instance) {
                var invoker = function(e) {
                    if (!e._vts) {
                        e._vts = Date.now();
                    } else if (e._vts <= invoker.attached) {
                        return;
                    }
                    runtimeCore.callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
                        e
                    ]);
                };
                invoker.value = initialValue;
                invoker.attached = getNow();
                return invoker;
            }
            function sanitizeEventValue(value, propName) {
                if (shared.isFunction(value) || shared.isArray(value)) {
                    return value;
                }
                runtimeCore.warn("Wrong type passed as event handler to ".concat(propName, " - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ").concat(typeof value === "undefined" ? "undefined" : _type_of(value), "."));
                return shared.NOOP;
            }
            function patchStopImmediatePropagation(e, value) {
                if (shared.isArray(value)) {
                    var originalStop = e.stopImmediatePropagation;
                    e.stopImmediatePropagation = function() {
                        originalStop.call(e);
                        e._stopped = true;
                    };
                    return value.map(function(fn) {
                        return function(e2) {
                            return !e2._stopped && fn && fn(e2);
                        };
                    });
                } else {
                    return value;
                }
            }
            var isNativeOn = function(key) {
                return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
                key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
            };
            var patchProp = function(el, key, prevValue, nextValue, namespace, parentComponent) {
                var isSVG = namespace === "svg";
                if (key === "class") {
                    patchClass(el, nextValue, isSVG);
                } else if (key === "style") {
                    patchStyle(el, prevValue, nextValue);
                } else if (shared.isOn(key)) {
                    if (!shared.isModelListener(key)) {
                        patchEvent(el, key, prevValue, nextValue, parentComponent);
                    }
                } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
                    patchDOMProp(el, key, nextValue);
                    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
                        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
                    }
                } else if (// #11081 force set props for possible async custom element
                el._isVueCE && (/[A-Z]/.test(key) || !shared.isString(nextValue))) {
                    patchDOMProp(el, shared.camelize(key), nextValue, parentComponent, key);
                } else {
                    if (key === "true-value") {
                        el._trueValue = nextValue;
                    } else if (key === "false-value") {
                        el._falseValue = nextValue;
                    }
                    patchAttr(el, key, nextValue, isSVG);
                }
            };
            function shouldSetAsProp(el, key, value, isSVG) {
                if (isSVG) {
                    if (key === "innerHTML" || key === "textContent") {
                        return true;
                    }
                    if (key in el && isNativeOn(key) && shared.isFunction(value)) {
                        return true;
                    }
                    return false;
                }
                if (key === "spellcheck" || key === "draggable" || key === "translate") {
                    return false;
                }
                if (key === "form") {
                    return false;
                }
                if (key === "list" && el.tagName === "INPUT") {
                    return false;
                }
                if (key === "type" && el.tagName === "TEXTAREA") {
                    return false;
                }
                if (key === "width" || key === "height") {
                    var tag = el.tagName;
                    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
                        return false;
                    }
                }
                if (isNativeOn(key) && shared.isString(value)) {
                    return false;
                }
                return key in el;
            }
            var REMOVAL = {};
            // @__NO_SIDE_EFFECTS__
            function defineCustomElement(options, extraOptions, _createApp) {
                var Comp = runtimeCore.defineComponent(options, extraOptions);
                if (shared.isPlainObject(Comp)) shared.extend(Comp, extraOptions);
                var VueCustomElement = /*#__PURE__*/ function(VueElement) {
                    _inherits(VueCustomElement, VueElement);
                    function VueCustomElement(initialProps) {
                        _class_call_check(this, VueCustomElement);
                        return _call_super(this, VueCustomElement, [
                            Comp,
                            initialProps,
                            _createApp
                        ]);
                    }
                    return VueCustomElement;
                }(VueElement);
                VueCustomElement.def = Comp;
                return VueCustomElement;
            }
            var defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ function(options, extraOptions) {
                return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
            };
            var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : function _class() {
                _class_call_check(this, _class);
            };
            var VueElement = /*#__PURE__*/ function(BaseClass) {
                _inherits(_VueElement, BaseClass);
                function _VueElement(_def) {
                    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _createApp = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createApp;
                    _class_call_check(this, _VueElement);
                    var _this;
                    _this = _call_super(this, _VueElement);
                    _this._def = _def;
                    _this._props = _props;
                    _this._createApp = _createApp;
                    _this._isVueCE = true;
                    _this._instance = null;
                    _this._app = null;
                    _this._nonce = _this._def.nonce;
                    _this._connected = false;
                    _this._resolved = false;
                    _this._numberProps = null;
                    _this._styleChildren = /* @__PURE__ */ new WeakSet();
                    _this._ob = null;
                    if (_this.shadowRoot && _createApp !== createApp) {
                        _this._root = _this.shadowRoot;
                    } else {
                        if (_this.shadowRoot) {
                            runtimeCore.warn("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`.");
                        }
                        if (_def.shadowRoot !== false) {
                            _this.attachShadow({
                                mode: "open"
                            });
                            _this._root = _this.shadowRoot;
                        } else {
                            _this._root = _this;
                        }
                    }
                    if (!_this._def.__asyncLoader) {
                        _this._resolveProps(_this._def);
                    }
                    return _this;
                }
                _create_class(_VueElement, [
                    {
                        key: "connectedCallback",
                        value: function connectedCallback() {
                            var _this = this;
                            if (!this.isConnected) return;
                            if (!this.shadowRoot) {
                                this._parseSlots();
                            }
                            this._connected = true;
                            var parent = this;
                            while(parent = parent && (parent.parentNode || parent.host)){
                                if (_instanceof(parent, _VueElement)) {
                                    this._parent = parent;
                                    break;
                                }
                            }
                            if (!this._instance) {
                                if (this._resolved) {
                                    this._setParent();
                                    this._update();
                                } else {
                                    if (parent && parent._pendingResolve) {
                                        this._pendingResolve = parent._pendingResolve.then(function() {
                                            _this._pendingResolve = void 0;
                                            _this._resolveDef();
                                        });
                                    } else {
                                        this._resolveDef();
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "_setParent",
                        value: function _setParent() {
                            var parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this._parent;
                            if (parent) {
                                this._instance.parent = parent._instance;
                                this._instance.provides = parent._instance.provides;
                            }
                        }
                    },
                    {
                        key: "disconnectedCallback",
                        value: function disconnectedCallback() {
                            var _this = this;
                            this._connected = false;
                            runtimeCore.nextTick(function() {
                                if (!_this._connected) {
                                    if (_this._ob) {
                                        _this._ob.disconnect();
                                        _this._ob = null;
                                    }
                                    _this._app && _this._app.unmount();
                                    if (_this._instance) _this._instance.ce = void 0;
                                    _this._app = _this._instance = null;
                                }
                            });
                        }
                    },
                    {
                        /**
         * resolve inner component definition (handle possible async component)
         */ key: "_resolveDef",
                        value: function _resolveDef() {
                            var _this = this;
                            var _this1 = this;
                            if (this._pendingResolve) {
                                return;
                            }
                            for(var i = 0; i < this.attributes.length; i++){
                                this._setAttr(this.attributes[i].name);
                            }
                            this._ob = new MutationObserver(function(mutations) {
                                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                try {
                                    for(var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                        var m = _step.value;
                                        _this._setAttr(m.attributeName);
                                    }
                                } catch (err) {
                                    _didIteratorError = true;
                                    _iteratorError = err;
                                } finally{
                                    try {
                                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                                            _iterator.return();
                                        }
                                    } finally{
                                        if (_didIteratorError) {
                                            throw _iteratorError;
                                        }
                                    }
                                }
                            });
                            this._ob.observe(this, {
                                attributes: true
                            });
                            var resolve = function(def) {
                                var isAsync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                                _this1._resolved = true;
                                _this1._pendingResolve = void 0;
                                var props = def.props, styles = def.styles;
                                var numberProps;
                                if (props && !shared.isArray(props)) {
                                    for(var key in props){
                                        var opt = props[key];
                                        if (opt === Number || opt && opt.type === Number) {
                                            if (key in _this1._props) {
                                                _this1._props[key] = shared.toNumber(_this1._props[key]);
                                            }
                                            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[shared.camelize(key)] = true;
                                        }
                                    }
                                }
                                _this1._numberProps = numberProps;
                                if (isAsync) {
                                    _this1._resolveProps(def);
                                }
                                if (_this1.shadowRoot) {
                                    _this1._applyStyles(styles);
                                } else if (styles) {
                                    runtimeCore.warn("Custom element style injection is not supported when using shadowRoot: false");
                                }
                                _this1._mount(def);
                            };
                            var asyncDef = this._def.__asyncLoader;
                            if (asyncDef) {
                                this._pendingResolve = asyncDef().then(function(def) {
                                    return resolve(_this._def = def, true);
                                });
                            } else {
                                resolve(this._def);
                            }
                        }
                    },
                    {
                        key: "_mount",
                        value: function _mount(def) {
                            var _this, _loop = function(key) {
                                if (!shared.hasOwn(_this, key)) {
                                    Object.defineProperty(_this, key, {
                                        // unwrap ref to be consistent with public instance behavior
                                        get: function() {
                                            return runtimeCore.unref(exposed[key]);
                                        }
                                    });
                                } else {
                                    runtimeCore.warn('Exposed property "'.concat(key, '" already exists on custom element.'));
                                }
                            };
                            if (!def.name) {
                                def.name = "VueElement";
                            }
                            this._app = this._createApp(def);
                            if (def.configureApp) {
                                def.configureApp(this._app);
                            }
                            this._app._ceVNode = this._createVNode();
                            this._app.mount(this._root);
                            var exposed = this._instance && this._instance.exposed;
                            if (!exposed) return;
                            for(var key in exposed)_this = this, _loop(key);
                        }
                    },
                    {
                        key: "_resolveProps",
                        value: function _resolveProps(def) {
                            var props = def.props;
                            var declaredPropKeys = shared.isArray(props) ? props : Object.keys(props || {});
                            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                            try {
                                for(var _iterator = Object.keys(this)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var key = _step.value;
                                    if (key[0] !== "_" && declaredPropKeys.includes(key)) {
                                        this._setProp(key, this[key]);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return != null) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
                            try {
                                var _this, _loop = function() {
                                    var key = _step1.value;
                                    Object.defineProperty(_this, key, {
                                        get: function get() {
                                            return this._getProp(key);
                                        },
                                        set: function set(val) {
                                            this._setProp(key, val, true, true);
                                        }
                                    });
                                };
                                for(var _iterator1 = declaredPropKeys.map(shared.camelize)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true)_this = this, _loop();
                            } catch (err) {
                                _didIteratorError1 = true;
                                _iteratorError1 = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
                                        _iterator1.return();
                                    }
                                } finally{
                                    if (_didIteratorError1) {
                                        throw _iteratorError1;
                                    }
                                }
                            }
                        }
                    },
                    {
                        key: "_setAttr",
                        value: function _setAttr(key) {
                            if (key.startsWith("data-v-")) return;
                            var has = this.hasAttribute(key);
                            var value = has ? this.getAttribute(key) : REMOVAL;
                            var camelKey = shared.camelize(key);
                            if (has && this._numberProps && this._numberProps[camelKey]) {
                                value = shared.toNumber(value);
                            }
                            this._setProp(camelKey, value, false, true);
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "_getProp",
                        value: function _getProp(key) {
                            return this._props[key];
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "_setProp",
                        value: function _setProp(key, val) {
                            var shouldReflect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, shouldUpdate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                            if (val !== this._props[key]) {
                                if (val === REMOVAL) {
                                    delete this._props[key];
                                } else {
                                    this._props[key] = val;
                                    if (key === "key" && this._app) {
                                        this._app._ceVNode.key = val;
                                    }
                                }
                                if (shouldUpdate && this._instance) {
                                    this._update();
                                }
                                if (shouldReflect) {
                                    var ob = this._ob;
                                    ob && ob.disconnect();
                                    if (val === true) {
                                        this.setAttribute(shared.hyphenate(key), "");
                                    } else if (typeof val === "string" || typeof val === "number") {
                                        this.setAttribute(shared.hyphenate(key), val + "");
                                    } else if (!val) {
                                        this.removeAttribute(shared.hyphenate(key));
                                    }
                                    ob && ob.observe(this, {
                                        attributes: true
                                    });
                                }
                            }
                        }
                    },
                    {
                        key: "_update",
                        value: function _update() {
                            render(this._createVNode(), this._root);
                        }
                    },
                    {
                        key: "_createVNode",
                        value: function _createVNode() {
                            var _this = this;
                            var baseProps = {};
                            if (!this.shadowRoot) {
                                baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
                            }
                            var vnode = runtimeCore.createVNode(this._def, shared.extend(baseProps, this._props));
                            if (!this._instance) {
                                vnode.ce = function(instance) {
                                    _this._instance = instance;
                                    instance.ce = _this;
                                    instance.isCE = true;
                                    {
                                        instance.ceReload = function(newStyles) {
                                            if (_this._styles) {
                                                _this._styles.forEach(function(s) {
                                                    return _this._root.removeChild(s);
                                                });
                                                _this._styles.length = 0;
                                            }
                                            _this._applyStyles(newStyles);
                                            _this._instance = null;
                                            _this._update();
                                        };
                                    }
                                    var dispatch = function(event, args) {
                                        _this.dispatchEvent(new CustomEvent(event, shared.isPlainObject(args[0]) ? shared.extend({
                                            detail: args
                                        }, args[0]) : {
                                            detail: args
                                        }));
                                    };
                                    instance.emit = function(event) {
                                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                            args[_key - 1] = arguments[_key];
                                        }
                                        dispatch(event, args);
                                        if (shared.hyphenate(event) !== event) {
                                            dispatch(shared.hyphenate(event), args);
                                        }
                                    };
                                    _this._setParent();
                                };
                            }
                            return vnode;
                        }
                    },
                    {
                        key: "_applyStyles",
                        value: function _applyStyles(styles, owner) {
                            if (!styles) return;
                            if (owner) {
                                if (owner === this._def || this._styleChildren.has(owner)) {
                                    return;
                                }
                                this._styleChildren.add(owner);
                            }
                            var nonce = this._nonce;
                            for(var i = styles.length - 1; i >= 0; i--){
                                var s = document.createElement("style");
                                if (nonce) s.setAttribute("nonce", nonce);
                                s.textContent = styles[i];
                                this.shadowRoot.prepend(s);
                                {
                                    if (owner) {
                                        if (owner.__hmrId) {
                                            if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();
                                            var entry = this._childStyles.get(owner.__hmrId);
                                            if (!entry) {
                                                this._childStyles.set(owner.__hmrId, entry = []);
                                            }
                                            entry.push(s);
                                        }
                                    } else {
                                        (this._styles || (this._styles = [])).push(s);
                                    }
                                }
                            }
                        }
                    },
                    {
                        /**
         * Only called when shadowRoot is false
         */ key: "_parseSlots",
                        value: function _parseSlots() {
                            var slots = this._slots = {};
                            var n;
                            while(n = this.firstChild){
                                var slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
                                (slots[slotName] || (slots[slotName] = [])).push(n);
                                this.removeChild(n);
                            }
                        }
                    },
                    {
                        /**
         * Only called when shadowRoot is false
         */ key: "_renderSlots",
                        value: function _renderSlots() {
                            var outlets = (this._teleportTarget || this).querySelectorAll("slot");
                            var scopeId = this._instance.type.__scopeId;
                            for(var i = 0; i < outlets.length; i++){
                                var o = outlets[i];
                                var slotName = o.getAttribute("name") || "default";
                                var content = this._slots[slotName];
                                var parent = o.parentNode;
                                if (content) {
                                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                                    try {
                                        for(var _iterator = content[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                            var n = _step.value;
                                            if (scopeId && n.nodeType === 1) {
                                                var id = scopeId + "-s";
                                                var walker = document.createTreeWalker(n, 1);
                                                n.setAttribute(id, "");
                                                var child = void 0;
                                                while(child = walker.nextNode()){
                                                    child.setAttribute(id, "");
                                                }
                                            }
                                            parent.insertBefore(n, o);
                                        }
                                    } catch (err) {
                                        _didIteratorError = true;
                                        _iteratorError = err;
                                    } finally{
                                        try {
                                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                                _iterator.return();
                                            }
                                        } finally{
                                            if (_didIteratorError) {
                                                throw _iteratorError;
                                            }
                                        }
                                    }
                                } else {
                                    while(o.firstChild)parent.insertBefore(o.firstChild, o);
                                }
                                parent.removeChild(o);
                            }
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "_injectChildStyle",
                        value: function _injectChildStyle(comp) {
                            this._applyStyles(comp.styles, comp);
                        }
                    },
                    {
                        /**
         * @internal
         */ key: "_removeChildStyle",
                        value: function _removeChildStyle(comp) {
                            var _this = this;
                            {
                                this._styleChildren.delete(comp);
                                if (this._childStyles && comp.__hmrId) {
                                    var oldStyles = this._childStyles.get(comp.__hmrId);
                                    if (oldStyles) {
                                        oldStyles.forEach(function(s) {
                                            return _this._root.removeChild(s);
                                        });
                                        oldStyles.length = 0;
                                    }
                                }
                            }
                        }
                    }
                ]);
                return _VueElement;
            }(BaseClass);
            function useHost(caller) {
                var instance = runtimeCore.getCurrentInstance();
                var el = instance && instance.ce;
                if (el) {
                    return el;
                } else {
                    if (!instance) {
                        runtimeCore.warn("".concat(caller || "useHost", " called without an active component instance."));
                    } else {
                        runtimeCore.warn("".concat(caller || "useHost", " can only be used in components defined via defineCustomElement."));
                    }
                }
                return null;
            }
            function useShadowRoot() {
                var el = useHost("useShadowRoot");
                return el && el.shadowRoot;
            }
            function useCssModule() {
                var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$style";
                {
                    var instance = runtimeCore.getCurrentInstance();
                    if (!instance) {
                        runtimeCore.warn("useCssModule must be called inside setup()");
                        return shared.EMPTY_OBJ;
                    }
                    var modules = instance.type.__cssModules;
                    if (!modules) {
                        runtimeCore.warn("Current instance does not have CSS modules injected.");
                        return shared.EMPTY_OBJ;
                    }
                    var mod = modules[name];
                    if (!mod) {
                        runtimeCore.warn('Current instance does not have CSS module named "'.concat(name, '".'));
                        return shared.EMPTY_OBJ;
                    }
                    return mod;
                }
            }
            var positionMap = /* @__PURE__ */ new WeakMap();
            var newPositionMap = /* @__PURE__ */ new WeakMap();
            var moveCbKey = Symbol("_moveCb");
            var enterCbKey = Symbol("_enterCb");
            var decorate = function(t) {
                delete t.props.mode;
                return t;
            };
            var TransitionGroupImpl = /* @__PURE__ */ decorate({
                name: "TransitionGroup",
                props: /* @__PURE__ */ shared.extend({}, TransitionPropsValidators, {
                    tag: String,
                    moveClass: String
                }),
                setup: function setup(props, param) {
                    var slots = param.slots;
                    var instance = runtimeCore.getCurrentInstance();
                    var state = runtimeCore.useTransitionState();
                    var prevChildren;
                    var children;
                    runtimeCore.onUpdated(function() {
                        if (!prevChildren.length) {
                            return;
                        }
                        var moveClass = props.moveClass || "".concat(props.name || "v", "-move");
                        if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                            return;
                        }
                        prevChildren.forEach(callPendingCbs);
                        prevChildren.forEach(recordPosition);
                        var movedChildren = prevChildren.filter(applyTranslation);
                        forceReflow();
                        movedChildren.forEach(function(c) {
                            var el = c.el;
                            var style = el.style;
                            addTransitionClass(el, moveClass);
                            style.transform = style.webkitTransform = style.transitionDuration = "";
                            var cb = el[moveCbKey] = function(e) {
                                if (e && e.target !== el) {
                                    return;
                                }
                                if (!e || /transform$/.test(e.propertyName)) {
                                    el.removeEventListener("transitionend", cb);
                                    el[moveCbKey] = null;
                                    removeTransitionClass(el, moveClass);
                                }
                            };
                            el.addEventListener("transitionend", cb);
                        });
                    });
                    return function() {
                        var rawProps = runtimeCore.toRaw(props);
                        var cssTransitionProps = resolveTransitionProps(rawProps);
                        var tag = rawProps.tag || runtimeCore.Fragment;
                        prevChildren = [];
                        if (children) {
                            for(var i = 0; i < children.length; i++){
                                var child = children[i];
                                if (child.el && _instanceof(child.el, Element)) {
                                    prevChildren.push(child);
                                    runtimeCore.setTransitionHooks(child, runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));
                                    positionMap.set(child, child.el.getBoundingClientRect());
                                }
                            }
                        }
                        children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];
                        for(var i1 = 0; i1 < children.length; i1++){
                            var child1 = children[i1];
                            if (child1.key != null) {
                                runtimeCore.setTransitionHooks(child1, runtimeCore.resolveTransitionHooks(child1, cssTransitionProps, state, instance));
                            } else if (child1.type !== runtimeCore.Text) {
                                runtimeCore.warn("<TransitionGroup> children must be keyed.");
                            }
                        }
                        return runtimeCore.createVNode(tag, null, children);
                    };
                }
            });
            var TransitionGroup = TransitionGroupImpl;
            function callPendingCbs(c) {
                var el = c.el;
                if (el[moveCbKey]) {
                    el[moveCbKey]();
                }
                if (el[enterCbKey]) {
                    el[enterCbKey]();
                }
            }
            function recordPosition(c) {
                newPositionMap.set(c, c.el.getBoundingClientRect());
            }
            function applyTranslation(c) {
                var oldPos = positionMap.get(c);
                var newPos = newPositionMap.get(c);
                var dx = oldPos.left - newPos.left;
                var dy = oldPos.top - newPos.top;
                if (dx || dy) {
                    var s = c.el.style;
                    s.transform = s.webkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
                    s.transitionDuration = "0s";
                    return c;
                }
            }
            function hasCSSTransform(el, root, moveClass) {
                var clone = el.cloneNode();
                var _vtc = el[vtcKey];
                if (_vtc) {
                    _vtc.forEach(function(cls) {
                        cls.split(/\s+/).forEach(function(c) {
                            return c && clone.classList.remove(c);
                        });
                    });
                }
                moveClass.split(/\s+/).forEach(function(c) {
                    return c && clone.classList.add(c);
                });
                clone.style.display = "none";
                var container = root.nodeType === 1 ? root : root.parentNode;
                container.appendChild(clone);
                var hasTransform = getTransitionInfo(clone).hasTransform;
                container.removeChild(clone);
                return hasTransform;
            }
            var getModelAssigner = function(vnode) {
                var fn = vnode.props["onUpdate:modelValue"] || false;
                return shared.isArray(fn) ? function(value) {
                    return shared.invokeArrayFns(fn, value);
                } : fn;
            };
            function onCompositionStart(e) {
                e.target.composing = true;
            }
            function onCompositionEnd(e) {
                var target = e.target;
                if (target.composing) {
                    target.composing = false;
                    target.dispatchEvent(new Event("input"));
                }
            }
            var assignKey = Symbol("_assign");
            var vModelText = {
                created: function created(el, param, vnode) {
                    var _param_modifiers = param.modifiers, lazy = _param_modifiers.lazy, trim = _param_modifiers.trim, number = _param_modifiers.number;
                    el[assignKey] = getModelAssigner(vnode);
                    var castToNumber = number || vnode.props && vnode.props.type === "number";
                    addEventListener(el, lazy ? "change" : "input", function(e) {
                        if (e.target.composing) return;
                        var domValue = el.value;
                        if (trim) {
                            domValue = domValue.trim();
                        }
                        if (castToNumber) {
                            domValue = shared.looseToNumber(domValue);
                        }
                        el[assignKey](domValue);
                    });
                    if (trim) {
                        addEventListener(el, "change", function() {
                            el.value = el.value.trim();
                        });
                    }
                    if (!lazy) {
                        addEventListener(el, "compositionstart", onCompositionStart);
                        addEventListener(el, "compositionend", onCompositionEnd);
                        addEventListener(el, "change", onCompositionEnd);
                    }
                },
                // set value on mounted so it's after min/max for type="range"
                mounted: function mounted(el, param) {
                    var value = param.value;
                    el.value = value == null ? "" : value;
                },
                beforeUpdate: function beforeUpdate(el, param, vnode) {
                    var value = param.value, oldValue = param.oldValue, _param_modifiers = param.modifiers, lazy = _param_modifiers.lazy, trim = _param_modifiers.trim, number = _param_modifiers.number;
                    el[assignKey] = getModelAssigner(vnode);
                    if (el.composing) return;
                    var elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? shared.looseToNumber(el.value) : el.value;
                    var newValue = value == null ? "" : value;
                    if (elValue === newValue) {
                        return;
                    }
                    if (document.activeElement === el && el.type !== "range") {
                        if (lazy && value === oldValue) {
                            return;
                        }
                        if (trim && el.value.trim() === newValue) {
                            return;
                        }
                    }
                    el.value = newValue;
                }
            };
            var vModelCheckbox = {
                // #4096 array checkboxes need to be deep traversed
                deep: true,
                created: function created(el, _, vnode) {
                    el[assignKey] = getModelAssigner(vnode);
                    addEventListener(el, "change", function() {
                        var modelValue = el._modelValue;
                        var elementValue = getValue(el);
                        var checked = el.checked;
                        var assign = el[assignKey];
                        if (shared.isArray(modelValue)) {
                            var index = shared.looseIndexOf(modelValue, elementValue);
                            var found = index !== -1;
                            if (checked && !found) {
                                assign(modelValue.concat(elementValue));
                            } else if (!checked && found) {
                                var filtered = _to_consumable_array(modelValue);
                                filtered.splice(index, 1);
                                assign(filtered);
                            }
                        } else if (shared.isSet(modelValue)) {
                            var cloned = new Set(modelValue);
                            if (checked) {
                                cloned.add(elementValue);
                            } else {
                                cloned.delete(elementValue);
                            }
                            assign(cloned);
                        } else {
                            assign(getCheckboxValue(el, checked));
                        }
                    });
                },
                // set initial checked on mount to wait for true-value/false-value
                mounted: setChecked,
                beforeUpdate: function beforeUpdate(el, binding, vnode) {
                    el[assignKey] = getModelAssigner(vnode);
                    setChecked(el, binding, vnode);
                }
            };
            function setChecked(el, param, vnode) {
                var value = param.value, oldValue = param.oldValue;
                el._modelValue = value;
                var checked;
                if (shared.isArray(value)) {
                    checked = shared.looseIndexOf(value, vnode.props.value) > -1;
                } else if (shared.isSet(value)) {
                    checked = value.has(vnode.props.value);
                } else {
                    if (value === oldValue) return;
                    checked = shared.looseEqual(value, getCheckboxValue(el, true));
                }
                if (el.checked !== checked) {
                    el.checked = checked;
                }
            }
            var vModelRadio = {
                created: function created(el, param, vnode) {
                    var value = param.value;
                    el.checked = shared.looseEqual(value, vnode.props.value);
                    el[assignKey] = getModelAssigner(vnode);
                    addEventListener(el, "change", function() {
                        el[assignKey](getValue(el));
                    });
                },
                beforeUpdate: function beforeUpdate(el, param, vnode) {
                    var value = param.value, oldValue = param.oldValue;
                    el[assignKey] = getModelAssigner(vnode);
                    if (value !== oldValue) {
                        el.checked = shared.looseEqual(value, vnode.props.value);
                    }
                }
            };
            var vModelSelect = {
                // <select multiple> value need to be deep traversed
                deep: true,
                created: function created(el, param, vnode) {
                    var value = param.value, number = param.modifiers.number;
                    var isSetModel = shared.isSet(value);
                    addEventListener(el, "change", function() {
                        var selectedVal = Array.prototype.filter.call(el.options, function(o) {
                            return o.selected;
                        }).map(function(o) {
                            return number ? shared.looseToNumber(getValue(o)) : getValue(o);
                        });
                        el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
                        el._assigning = true;
                        runtimeCore.nextTick(function() {
                            el._assigning = false;
                        });
                    });
                    el[assignKey] = getModelAssigner(vnode);
                },
                // set value in mounted & updated because <select> relies on its children
                // <option>s.
                mounted: function mounted(el, param) {
                    var value = param.value;
                    setSelected(el, value);
                },
                beforeUpdate: function beforeUpdate(el, _binding, vnode) {
                    el[assignKey] = getModelAssigner(vnode);
                },
                updated: function updated(el, param) {
                    var value = param.value;
                    if (!el._assigning) {
                        setSelected(el, value);
                    }
                }
            };
            function setSelected(el, value) {
                var _loop = function(i, l) {
                    var option = el.options[i];
                    var optionValue = getValue(option);
                    if (isMultiple) {
                        if (isArrayValue) {
                            var optionType = typeof optionValue === "undefined" ? "undefined" : _type_of(optionValue);
                            if (optionType === "string" || optionType === "number") {
                                option.selected = value.some(function(v1) {
                                    return String(v1) === String(optionValue);
                                });
                            } else {
                                option.selected = shared.looseIndexOf(value, optionValue) > -1;
                            }
                        } else {
                            option.selected = value.has(optionValue);
                        }
                    } else if (shared.looseEqual(getValue(option), value)) {
                        if (el.selectedIndex !== i) el.selectedIndex = i;
                        return {
                            v: void void 0
                        };
                    }
                };
                var isMultiple = el.multiple;
                var isArrayValue = shared.isArray(value);
                if (isMultiple && !isArrayValue && !shared.isSet(value)) {
                    runtimeCore.warn("<select multiple v-model> expects an Array or Set value for its binding, but got ".concat(Object.prototype.toString.call(value).slice(8, -1), "."));
                    return;
                }
                for(var i = 0, l = el.options.length; i < l; i++){
                    var _ret = _loop(i, l);
                    if (_type_of(_ret) === "object") return _ret.v;
                }
                if (!isMultiple && el.selectedIndex !== -1) {
                    el.selectedIndex = -1;
                }
            }
            function getValue(el) {
                return "_value" in el ? el._value : el.value;
            }
            function getCheckboxValue(el, checked) {
                var key = checked ? "_trueValue" : "_falseValue";
                return key in el ? el[key] : checked;
            }
            var vModelDynamic = {
                created: function created(el, binding, vnode) {
                    callModelHook(el, binding, vnode, null, "created");
                },
                mounted: function mounted(el, binding, vnode) {
                    callModelHook(el, binding, vnode, null, "mounted");
                },
                beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
                    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
                },
                updated: function updated(el, binding, vnode, prevVNode) {
                    callModelHook(el, binding, vnode, prevVNode, "updated");
                }
            };
            function resolveDynamicModel(tagName, type) {
                switch(tagName){
                    case "SELECT":
                        return vModelSelect;
                    case "TEXTAREA":
                        return vModelText;
                    default:
                        switch(type){
                            case "checkbox":
                                return vModelCheckbox;
                            case "radio":
                                return vModelRadio;
                            default:
                                return vModelText;
                        }
                }
            }
            function callModelHook(el, binding, vnode, prevVNode, hook) {
                var modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
                var fn = modelToUse[hook];
                fn && fn(el, binding, vnode, prevVNode);
            }
            function initVModelForSSR() {
                vModelText.getSSRProps = function(param) {
                    var value = param.value;
                    return {
                        value: value
                    };
                };
                vModelRadio.getSSRProps = function(param, vnode) {
                    var value = param.value;
                    if (vnode.props && shared.looseEqual(vnode.props.value, value)) {
                        return {
                            checked: true
                        };
                    }
                };
                vModelCheckbox.getSSRProps = function(param, vnode) {
                    var value = param.value;
                    if (shared.isArray(value)) {
                        if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {
                            return {
                                checked: true
                            };
                        }
                    } else if (shared.isSet(value)) {
                        if (vnode.props && value.has(vnode.props.value)) {
                            return {
                                checked: true
                            };
                        }
                    } else if (value) {
                        return {
                            checked: true
                        };
                    }
                };
                vModelDynamic.getSSRProps = function(binding, vnode) {
                    if (typeof vnode.type !== "string") {
                        return;
                    }
                    var modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
                    vnode.type.toUpperCase(), vnode.props && vnode.props.type);
                    if (modelToUse.getSSRProps) {
                        return modelToUse.getSSRProps(binding, vnode);
                    }
                };
            }
            var systemModifiers = [
                "ctrl",
                "shift",
                "alt",
                "meta"
            ];
            var modifierGuards = {
                stop: function(e) {
                    return e.stopPropagation();
                },
                prevent: function(e) {
                    return e.preventDefault();
                },
                self: function(e) {
                    return e.target !== e.currentTarget;
                },
                ctrl: function(e) {
                    return !e.ctrlKey;
                },
                shift: function(e) {
                    return !e.shiftKey;
                },
                alt: function(e) {
                    return !e.altKey;
                },
                meta: function(e) {
                    return !e.metaKey;
                },
                left: function(e) {
                    return "button" in e && e.button !== 0;
                },
                middle: function(e) {
                    return "button" in e && e.button !== 1;
                },
                right: function(e) {
                    return "button" in e && e.button !== 2;
                },
                exact: function(e, modifiers) {
                    return systemModifiers.some(function(m) {
                        return e["".concat(m, "Key")] && !modifiers.includes(m);
                    });
                }
            };
            var withModifiers = function(fn, modifiers) {
                var cache = fn._withMods || (fn._withMods = {});
                var cacheKey = modifiers.join(".");
                return cache[cacheKey] || (cache[cacheKey] = function(event) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    for(var i = 0; i < modifiers.length; i++){
                        var guard = modifierGuards[modifiers[i]];
                        if (guard && guard(event, modifiers)) return;
                    }
                    return fn.apply(void 0, [
                        event
                    ].concat(_to_consumable_array(args)));
                });
            };
            var keyNames = {
                esc: "escape",
                space: " ",
                up: "arrow-up",
                left: "arrow-left",
                right: "arrow-right",
                down: "arrow-down",
                delete: "backspace"
            };
            var withKeys = function(fn, modifiers) {
                var cache = fn._withKeys || (fn._withKeys = {});
                var cacheKey = modifiers.join(".");
                return cache[cacheKey] || (cache[cacheKey] = function(event) {
                    if (!("key" in event)) {
                        return;
                    }
                    var eventKey = shared.hyphenate(event.key);
                    if (modifiers.some(function(k) {
                        return k === eventKey || keyNames[k] === eventKey;
                    })) {
                        return fn(event);
                    }
                });
            };
            var rendererOptions = /* @__PURE__ */ shared.extend({
                patchProp: patchProp
            }, nodeOps);
            var renderer;
            var enabledHydration = false;
            function ensureRenderer() {
                return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));
            }
            function ensureHydrationRenderer() {
                renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);
                enabledHydration = true;
                return renderer;
            }
            var render = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _ensureRenderer;
                (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, _to_consumable_array(args));
            };
            var hydrate = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _ensureHydrationRenderer;
                (_ensureHydrationRenderer = ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRenderer, _to_consumable_array(args));
            };
            var createApp = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _ensureRenderer;
                var app = (_ensureRenderer = ensureRenderer()).createApp.apply(_ensureRenderer, _to_consumable_array(args));
                {
                    injectNativeTagCheck(app);
                    injectCompilerOptionsCheck(app);
                }
                var mount = app.mount;
                app.mount = function(containerOrSelector) {
                    var container = normalizeContainer(containerOrSelector);
                    if (!container) return;
                    var component = app._component;
                    if (!shared.isFunction(component) && !component.render && !component.template) {
                        component.template = container.innerHTML;
                    }
                    if (container.nodeType === 1) {
                        container.textContent = "";
                    }
                    var proxy = mount(container, false, resolveRootNamespace(container));
                    if (_instanceof(container, Element)) {
                        container.removeAttribute("v-cloak");
                        container.setAttribute("data-v-app", "");
                    }
                    return proxy;
                };
                return app;
            };
            var createSSRApp = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _ensureHydrationRenderer;
                var app = (_ensureHydrationRenderer = ensureHydrationRenderer()).createApp.apply(_ensureHydrationRenderer, _to_consumable_array(args));
                {
                    injectNativeTagCheck(app);
                    injectCompilerOptionsCheck(app);
                }
                var mount = app.mount;
                app.mount = function(containerOrSelector) {
                    var container = normalizeContainer(containerOrSelector);
                    if (container) {
                        return mount(container, true, resolveRootNamespace(container));
                    }
                };
                return app;
            };
            function resolveRootNamespace(container) {
                if (_instanceof(container, SVGElement)) {
                    return "svg";
                }
                if (typeof MathMLElement === "function" && _instanceof(container, MathMLElement)) {
                    return "mathml";
                }
            }
            function injectNativeTagCheck(app) {
                Object.defineProperty(app.config, "isNativeTag", {
                    value: function(tag) {
                        return shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag);
                    },
                    writable: false
                });
            }
            function injectCompilerOptionsCheck(app) {
                if (runtimeCore.isRuntimeOnly()) {
                    var isCustomElement = app.config.isCustomElement;
                    Object.defineProperty(app.config, "isCustomElement", {
                        get: function get() {
                            return isCustomElement;
                        },
                        set: function set() {
                            runtimeCore.warn("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
                        }
                    });
                    var compilerOptions = app.config.compilerOptions;
                    var msg = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
                    Object.defineProperty(app.config, "compilerOptions", {
                        get: function get() {
                            runtimeCore.warn(msg);
                            return compilerOptions;
                        },
                        set: function set() {
                            runtimeCore.warn(msg);
                        }
                    });
                }
            }
            function normalizeContainer(container) {
                if (shared.isString(container)) {
                    var res = document.querySelector(container);
                    if (!res) {
                        runtimeCore.warn('Failed to mount app: mount target selector "'.concat(container, '" returned null.'));
                    }
                    return res;
                }
                if (window.ShadowRoot && _instanceof(container, window.ShadowRoot) && container.mode === "closed") {
                    runtimeCore.warn('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs');
                }
                return container;
            }
            var ssrDirectiveInitialized = false;
            var initDirectivesForSSR = function() {
                if (!ssrDirectiveInitialized) {
                    ssrDirectiveInitialized = true;
                    initVModelForSSR();
                    initVShowForSSR();
                }
            };
            exports.Transition = Transition;
            exports.TransitionGroup = TransitionGroup;
            exports.VueElement = VueElement;
            exports.createApp = createApp;
            exports.createSSRApp = createSSRApp;
            exports.defineCustomElement = defineCustomElement;
            exports.defineSSRCustomElement = defineSSRCustomElement;
            exports.hydrate = hydrate;
            exports.initDirectivesForSSR = initDirectivesForSSR;
            exports.render = render;
            exports.useCssModule = useCssModule;
            exports.useCssVars = useCssVars;
            exports.useHost = useHost;
            exports.useShadowRoot = useShadowRoot;
            exports.vModelCheckbox = vModelCheckbox;
            exports.vModelDynamic = vModelDynamic;
            exports.vModelRadio = vModelRadio;
            exports.vModelSelect = vModelSelect;
            exports.vModelText = vModelText;
            exports.vShow = vShow;
            exports.withKeys = withKeys;
            exports.withModifiers = withModifiers;
            Object.keys(runtimeCore).forEach(function(k) {
                if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeCore[k];
            });
        }
    });
    // ../../node_modules/.pnpm/@vue+runtime-dom@3.5.13/node_modules/@vue/runtime-dom/index.js
    var require_runtime_dom = __commonJS({
        "../../node_modules/.pnpm/@vue+runtime-dom@3.5.13/node_modules/@vue/runtime-dom/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_runtime_dom_cjs();
            }
        }
    });
    // ../../node_modules/.pnpm/vue@3.5.13_typescript@5.7.2/node_modules/vue/dist/vue.cjs.js
    var require_vue_cjs = __commonJS({
        "../../node_modules/.pnpm/vue@3.5.13_typescript@5.7.2/node_modules/vue/dist/vue.cjs.js": function(exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            var compilerDom = require_compiler_dom();
            var runtimeDom = require_runtime_dom();
            var shared = require_shared();
            function _interopNamespaceDefault(e) {
                var n = /* @__PURE__ */ Object.create(null);
                if (e) {
                    for(var k in e){
                        n[k] = e[k];
                    }
                }
                n.default = e;
                return Object.freeze(n);
            }
            var runtimeDom__namespace = /* @__PURE__ */ _interopNamespaceDefault(runtimeDom);
            var compileCache = /* @__PURE__ */ Object.create(null);
            function compileToFunction(template, options) {
                if (!shared.isString(template)) {
                    if (template.nodeType) {
                        template = template.innerHTML;
                    } else {
                        runtimeDom.warn("invalid template option: ", template);
                        return shared.NOOP;
                    }
                }
                var key = shared.genCacheKey(template, options);
                var cached = compileCache[key];
                if (cached) {
                    return cached;
                }
                if (template[0] === "#") {
                    var el = document.querySelector(template);
                    if (!el) {
                        runtimeDom.warn("Template element not found or is empty: ".concat(template));
                    }
                    template = el ? el.innerHTML : "";
                }
                var opts = shared.extend({
                    hoistStatic: true,
                    onError: onError,
                    onWarn: function(e) {
                        return onError(e, true);
                    }
                }, options);
                if (!opts.isCustomElement && typeof customElements !== "undefined") {
                    opts.isCustomElement = function(tag) {
                        return !!customElements.get(tag);
                    };
                }
                var code = compilerDom.compile(template, opts).code;
                function onError(err) {
                    var asWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    var message = asWarning ? err.message : "Template compilation error: ".concat(err.message);
                    var codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
                    runtimeDom.warn(codeFrame ? "".concat(message, "\n").concat(codeFrame) : message);
                }
                var render = new Function("Vue", code)(runtimeDom__namespace);
                render._rc = true;
                return compileCache[key] = render;
            }
            runtimeDom.registerRuntimeCompiler(compileToFunction);
            exports.compile = compileToFunction;
            Object.keys(runtimeDom).forEach(function(k) {
                if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = runtimeDom[k];
            });
        }
    });
    // ../../node_modules/.pnpm/vue@3.5.13_typescript@5.7.2/node_modules/vue/index.js
    var require_vue = __commonJS({
        "../../node_modules/.pnpm/vue@3.5.13_typescript@5.7.2/node_modules/vue/index.js": function(exports, module) {
            "use strict";
            if (false) {
                module.exports = null;
            } else {
                module.exports = require_vue_cjs();
            }
        }
    });
    // src/vue.ts
    var vue_exports2 = {};
    // ../../node_modules/.pnpm/vue@3.5.13_typescript@5.7.2/node_modules/vue/index.mjs
    var vue_exports = {};
    __reExport(vue_exports, __toESM(require_vue(), 1));
    // src/vue.ts
    __reExport(vue_exports2, vue_exports);
    return __toCommonJS(vue_exports2);
}();
//# sourceMappingURL=vue.development.umd.js.map